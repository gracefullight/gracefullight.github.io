---
title: 컴퓨터시스템구조
authors: me
tags: [정보처리]
date: 2017-09-19 23:11:40
---

# 컴퓨터의 역사

## 세대별 구분

### 1세대

- 진공관
- 프로그램 내장방식
- 전력소모 크고 발열 심함
- 기계어, 어셈블리어

### 2세대

- 트랜지스터
- 진공관 컴퓨터에서 1/100 축소
- 고급언어 (COBOL)

### 3세대

- 집적회로 (IC: Integrated Circuit)
- 고급언어 (베이직)

### 4세대

- 고밀도 집적회로 (LSI: Large Scale Integrated circuit)
- 초고밀도 집적회로 (VLSI: Very Large Scale Integrated Circuit)
- PC
- 고급언어, 문제지향적 언어

# 컴퓨터 시스템의 전체적 구성

## 시스템 버스

- CPU, 기억장치, I/O 장치들을 상호 연결해주는 중심 통로
- 단방향 어드레스 버스, 양방향 데이터 버스, 양방향 제어버스로 구성

## 입력장치

## 출력장치

## 기억장치

## 중앙처리장치

- 연산장치, 제어장치, 레지스터로 구성

| 사람   | 컴퓨터       |
| ------ | ------------ |
| 감각   | 입력장치     |
| 뇌세포 | 기억장치     |
| 신경망 | 중앙처리장치 |
| 움직임 | 출력장치     |

## 운영체제

- HW와 SW 자원을 관리하고 제어
- 편리한 인터페이스 제공
- 입출력의 보조적 기능 수행
- 오류 처리

### 자원관리

- 프로세스 관리
- 주기억장치 관리
- 보조기억장치 관리
- 입출력장치 관리
- 파일 관리

> 컴파일러, 인트프리터: 고급언어를 기계어로 변환하기 위한 번역기

## 분류

### 성능과 규모

- 마이크로 컴퓨터: 현재 범용컴퓨터
- 미니컴퓨터: 멀티유저 시스템
- 메인프레임: 범용목적의 대형컴퓨터, 다수의 터미널 사용
- 슈퍼컴퓨터

### 구조

- 병렬컴퓨터: 동시에 여러 개의 마이크로프로세서 사용
- 분산컴퓨터: 데이터가 네트워크 상에 분산되어 있을 때
- 클라우드컴퓨터

### 사용목적

- 전용컴퓨터: 군사용, 기상예보용, 천문학 등
- 범용컴퓨터: 여러 분야의 다양한 업무 처리할 목적으로 설계된 컴퓨터 (과학계산, 통계 등)

### 처리방법

- 일괄처리 컴퓨터: 일정 시점 단위로 한꺼번에 처리
- 실시간 처리 컴퓨터: real-time, 온라인 처리 시스템, 즉시처리 시스템

### 자료표현

- 디지털 컴퓨터
- 아날로그 컴퓨터: 자료를 입력받아 곡선이나 그래프로 출력하는 컴퓨터
- 하이브리드 컴퓨터: 아날로그, 디지털 데이터 모두 처리, A/D (Analog-Digital conveter) 변환기, D/A(Digital-Analog converter)로 데이터 변형 출력 가능

## 발달과정

| 특징              | 컴퓨터   |
| ----------------- | -------- |
| 최초 기계식       | 마크원   |
| 최초 전자식       | ENIAC    |
| 최초 프로그램내장 | EDSAC    |
| 최초 상업용       | UNIVAC-I |

> 진공관 > TR > IC > LSI > VLSI
> **폰노이만 모델**: 기억장치에 프로그램과 데이터를 넣고 순서대로 처리하는 방식 (프로그램 내장방식)
> **시스템버스**: 어드레스 버스, 데이터 버스, 제어 버스

# 컴퓨터 명령어

## 주소필드

- mode, operation code, address 필드로 구성
- mode = 0 => 주소가 직접번지, mode = 1 => 주소가 간접번지
- 주소필드는 **주소 || 레지스터 || 데이터**를 나타냄
- 16bit 명령어의 경우: 1bit, 3bit, 12bit

### 3주소 명령어

- 범용 레지스터 구조의 컴퓨터에서 사용
- 연산코드와 3개의 주소필드로 구성
- 프로그램은 간단하나 명령어의 길이가 너무 길다

### 2주소 명령어

- 범용 레지스터 구조의 컴퓨터에서 사용
- 연산코드와 2개의 주소필드로 구성
- 연산시에 주소1의 내용은 실행 후에 출력값으로 저장되므로 원래 주소1의 내용은 없어진다.

### 1주소 명령어

- 단일 **누산기** 방식의 컴퓨터에서 사용
- ACC와 Operand의 연산결과는 다시 ACC에 저장되는 형식
- 입력으로 사용된 누산기는 결과값이 저장되어 원래 값은 없어진다.

### 0주소 명령어

- STACK

## 주소지정방식

### 의미주소지정

- Implied Addressing Mode
- 묵시적 주소지정방식
- 데이터의 위치를 지정하지 않아도 묵시적으로 정해져 있음
- PUSH, POP: Stack Pointer 사용
- SHL, SHR: ACC의 내용을 시프트
- 명령어가 짧다

### 즉치주소지정

- Immediated Addressing Mode
- Operand의 내용이 연산에 사용될 실제 데이터
- 프로그램상에서 레지스터나 변수의 초기값을 설정하는데 사용

### 레지스터 주소지정

- Register Addressing Mode
- 레지스터에 데이터가 존재
- 레지스터를 지정하는 오퍼랜드가 4bit라면 16개의 레지스터를 지정할 수 있음
- 메모리를 액세스하지 않아 실행시간 단축
- 데이터를 저장하는 공간이 레지스터로 한정

### 레지스터 간접주소지정

- Register Indirect Addressing Mode
- 레지스터의 내용이 유효주소가 되기 때문에 지정된 레지스터의 내용이 메모리 주소가 되어 유효 데이터를 가져옴
- 레지스터가 10bit면 2^10B, 20bit면 1MB의 메모리 영역을 지정 가능
- 데이터 인출을 위해 한 번만 메모리를 액세스하면 된다.

### 직접주소지정

- Direct Addressing Mode
- 오퍼랜드가 데이터의 유효주소
- 데이터 인출을 위해 한 번만 메모리 액세스

### 간접주소지정

- Indirect Addressing Mode
- 오퍼랜드의 데이터가 가리키는 기억장소의 데이터가 유효주소 (2번)
- 오퍼랜드가 nbit면 최대 2^n개의 주소공간
- 명령어의 I비트가 0이면 직접주소, 1이면 간접주소

### 상대주소지정

- Relative Addressing Mode
- 명령어의 주소필드에 PC(Program Counter) 값이 더해져서 유효주소가 결정되는 방식
- 기준 주소는 명령어의 주소, 변위는 PC
- 주로 분기명령어에서 사용

### 인덱스된 주소지정

- Indexed Addressing Mode
- 인덱스 레지스터의 내용과 주소필드의 내용이 더해져서 유효주소가 결정
- 기준 주소는 명령어의 주소, 변위는 인덱스 레지스터

### 베이스 레지스터 주소지정

- Base Register Addressing Mode
- 베이스 레지스터의 내용과 주소필드의 내용이 더해져서 유효주소가 결정
- 기준 주소가 베이스 레지스터, 변위는 명령어의 주소필드

## 명령어의 종류

### 데이터 전송명령

- 데이터가 변경되지 않고 위치만 옮기는 명령

| 명령어 | 부호 | 기능            |
| ------ | ---- | --------------- |
| load   | LD   | mem => reg      |
| store  | ST   | reg => mem      |
| move   | MOV  | reg 간 전송     |
| input  | IN   | 입력장치 => reg |
| output | OUT  | reg => 출력장치 |
| push   | PUSH | reg => stack    |
| pop    | POP  | stack => reg    |

### 데이터 처리 명령

- 실제로 연산이 이뤄지는 명령
- 산술연산명령어, 논리연산명령어, 비트처리명령어, 시프트명령어로 구분

**산술연산**

| 명령어         | 부호 | 기능               |
| -------------- | ---- | ------------------ |
| add            | ADD  | 덧셈               |
| subtract       | SUB  | 뺄셈               |
| multiply       | MUL  | 곱셈               |
| increment      | INC  | mem, reg 1 증가    |
| decrement      | DEC  | mem, reg 1 감소    |
| negate         | NEG  | 2의 보수           |
| add with carry | ADDC | 올림수와 함께 덧셈 |

**논리연산**

| 명령어            | 부호 | 기능                |
| ----------------- | ---- | ------------------- |
| AND               | AND  | 특정부분 0으로 셋   |
| clear             | CLR  | 모든 비트 0으로 셋  |
| clear carry       | CLRC | 캐리비트를 0으로 셋 |
| enable interrupt  | EI   | 인터럽트 가능       |
| disable interrupt | DI   | 인터럽트 불가능     |

**시프트**

| 명령어              | 부호 | 기능                              |
| ------------------- | ---- | --------------------------------- |
| logical shift right | SHR  | 오른쪽 논리 시프트                |
| logical shift left  | SHL  | 왼쪽 논리 시프트                  |
| rotate right        | ROR  | 현재값 유지하면서 오른쪽 자리이동 |
| rotate lest         | ROL  | 현재값 유지하면서 왼쪽 자리이동   |

### 프로그램 제어명령

조건에 따라 PC가 변경되어 수행순서가 달라진다

| 명령어  | 부호 | 기능                            |
| ------- | ---- | ------------------------------- |
| branch  | BR   | 지정된 주소로 분기              |
| jump    | JMP  | 지정된 주소로 점프              |
| skip    | SKP  | PC값 증가 후 다음 명령으로 skip |
| call    | CALL | PC값 저장, 서브루틴 콜          |
| return  | RET  | 리턴 주소를 PC에 저장           |
| compare | CMP  | 두 수 크기 비교                 |

## 프로그램 인터럽트

### 외부 인터럽트

- 입출력장치, 전원 등 외부 요인으로 발생
- 입출력장치의 데이터 전송 요구, 정보전송의 마감, timeout, 전원공급이 끊어질 때 발생
- 프로그램 외적인 상황에서 발생

### 내부 인터럽트

- 올바르지 않은 명령어나 데이터 사용시 발생
- overflow, div 0, stack overflow, 메모리 보호영역 침범 등
- 프로그램 자체에서 주로 발생

### 소프트웨어 인터럽트

- 특수한 CALL 명령어로 프로그래머가 원하는 위치에서 인터럽트 발생
- supervisor call instruction
- 사용자 모드엥서 supervisor 모드로 CPU 상태를 변환

### 외부 인터럽트 처리

1. 외부 인터럽트 발생
2. CPU는 현재 수행하는 명령어의 실행 사이클 종료
3. 다음 실행할 PC의 내용을 스택에 저장
4. 인터럽트 서비스 루틴의 시작주소를 PC에 저장
5. 인터럽트 처리 후 스택영역에 저장된 PC를 복구
6. 프로그램 복귀 후 계속 실행

## 복합, 단축 명령어 컴퓨터

### CISC

- Complex Instruction Set Computer
- 다양한 데이터와 주소방식 제공
- 많은 명령어와 주소지정방식을 구현하기 위해 많은 하드웨어 필요
- 실행속도가 느림

### RISC

- Reduced Instruction Set Computer
- Load와 Store를 제외하고는 레지스터 간의 연산으로 구성
- 고정된 명령어 형식 사용
- 복잡한 간접주소지정방식은 사용하지 않음

# 시스템 버스

- 컴퓨터 시스템의 각각의 장치를 연결하여 정보를 전송하는 공유전송매체
- CPU를 중심으로 주기억장치, 보조기억장치, 입력장치, 출력장치가 데이터를 주고받는 통로

## 주소버스

- Address Bus
- 주기억장치에 데이터를 읽기/쓰기 위해서 주소를 지정하기 위한 선들의 집합
- 단방향 전송
- 주소 버스가 16bit이면 2^16 => 65536개의 주소 지정

## 데이터버스

- 각각의 장치들 사이의 데이터를 전송하는 선들의 집합
- 양방향 전송
- 버스의 폭은 주소를 지정하고 한 번에 R/W하는 비트의 수
- 주소당 32bit 씩 데이터를 전송한다면 데이터 버스의 수는 32개

## 제어버스

- CPU, I/O장치, Memory 장치를 제어하는 신호선들의 집합
- 인터럽트 요구 신호
- 인터럽트 승인 신호
- 버스요구 신호
- 버스승인 신호
- 기억장치 읽기 신호
- 기억장치 쓰기 신호
- 입출력장치 읽기 신호
- 입출력장치 쓰기 신호
- 리셋 신호
- 버스 클록
- 전송 확인 (transfer acknowledge)

## 동기식버스

- 클록 펄스에 의해 데이터 전송이 발생
- 마스터와 슬레이브는 모두 같은 클록 펄스에 동기
- 인터페이스 회로가 간단
- 클록의 주기보다 짧은 동작은 다음 주기까지 기다려야하는 단덤

## 비동기식버스

- 핸드셰이킹 프로토콜 사용
- 속도의 차이가 많은 장치에서 사용
- 복잡
- 소규모에선 비동기, 중형이상에선 동기방식을 주로 사용

## 버스중재

- 동시에 여러 장치에서 버스를 요구할 때 필요 = 버스 경합

### 중앙집중식 중재방식

- centralized arbitration scheme
- 시스템 내에 중재기가 1개

### 분산식 중재방식

- decentralized arbitration scheme
- 여러 개의 버스중재기가 존재

> 대표적 버스 중재기: 데이지 체인, 폴링 방식

## 내부버스

- 칩들 사이에 신호를 전달

## 외부버스

내부 버스를 경유해 CPU와 상호간을 연결하는 버스

### VME

- VMEbus 컴퓨터 버스 표준
- 모토로라, 톰슨 사 등이 개발한 32bit, 64bit 버스 규격

### 멀티 버스

- 인텔에서 개발한 범용 버스 시스템
- 현재 산업용으로 사용
- 멀티플렉서를 통해 다른 소자와 데이터를 송수신
- 다중처리 가능
- 마스터나 슬레이브로 동작
- 마스터는 버스사용권을 얻어 데이터 전송 가능
- 슬레이브는 스스로 버스를 제어할 수 없음

### ISA 버스

- Industry Standard Architecture bus
- CPU와 각종 주변장치를 연결하여 정보를 전달하는 버스 설계 규격
- AT 버스라고도 한다.
- 16bit 버스 구조, 현재는 PCI 버스로 대체

### EISA 버스

- Extended Industry Standard Architecture bus
- 32bit ISA 버스
- 비싸서 사용 안함

### VESA 로컬 버스

- Video Electronics Standards Association local bus
- 버스 제어기를 통하지 않고 직접 CPU와 데이터를 송수신하는 방식

### PCI 버스

- ISA, EISA, VESA의 후속
- 32bit, 64bit 사용 가능
- CPU의 종류가 달라도 CPU와 버스 사이의 브릿지 회로만 있으면 사용 가능
- 독자적으로 작업을 처리할 수 있음

### GPIB 버스

- General Purpose Interface bus
- 병렬 데이터를 전송하고 제어할 수 있는 버스
- 테스트 및 측정장치를 컴퓨터와 연결하여 자동 테스트 시스템을 만든다.

# 마이크로 연산

- 레지스터 사이의 전송정보 동작
- Micro Operation

## 레지스터 종류

- 소자는 플립플롭
- 고유의 주소값을 가진다.
- MAR, PC, SP, R0 등
- 데이터 레지스터, 주소 레지스터, 상태 레지스터로 구분
- 범용 레지스터 (GPR), 특수레지스터 (SPR)로 구분

## 주소 레지스터

- Address Register

### MAR

- 메모리 주소 레지스터
- 주소를 먼저 지정

### PC

- 프로그램 카운터
- 다음 명령어의 주소를 지정
- PC의 내용은 MAR로 전송되고 MAR의 내용이 주소 버스를 통해 메모리 주소를 지정

### SP

- 스택 포인터
- 서브루틴 또는 인터럽트가 발생시 현재 레지스터의 내용을 저장하는데 레지스터를 저장하기 위한 스택 영역 메모리의 주소를 기억

### CMAR

- Control Memory Address Register
- 마이크로프로그램이 있는 메모리의 주소를 기억

### XR

- 인덱스 레지스터
- 기준 되는 주소에 XR의 변위값을 더해서 유효 주소를 발생
- 데이터 블록 전송에 사용

### BR

- 베이스 레지스터
- 베이스 레지스터에 기준이 되는 주소가 있고 여기에 변위값이 더해져 유효주소를 발생

## 데이터 레지스터

### MBR

- Memory Buffer Register
- 주기억장치에서 데이터를 읽거나 데이터를 주기억장치에 기록할 때 사용되는 레지스터

### ACC

- ACCucmulator
- 연산장치의 입력값을 저장하거나 연산이 끝난 후의 결과값을 저장
- ACC => MBR => 데이터 버스 => 주기억장치 저장

### TR

- T buffer = Temporary Register
- 연산 중에 중간값을 임시 저장

### PSR

- Program Status Register
- CPU에서 수행되고 있는 프로그램의 상태정보를 기억하고 있는 레지스터
- Carry, Negative, oVerflow, Zero, Interrupt 플래그의 내용 표시

## 레지스터 전송

### 직렬전송

- 한 클록에 1bit씩 전송
- 워드 타임 (Word time): 4bit 모두 전송하는데 걸리는 시간

### 병렬전송

- 데이터 전송이 한 클록 펄스 동안 이루어지는 전송

## 산술 마이크로 연산

덧셈, 뺄셈, 1 증가, 1 감소, 보수
![image from hexo](https://i.imgur.com/KFwfVba.jpg)

## 논리 마이크로 연산

### SET

- 특정 비트를 강제로 1로 만들 때 사용
- OR 연산

### MASK

- 특정 비트를 강제로 0으로 만들 때 사용
- AND 연산

### Selective Complement

- 특정 비트를 강제로 보수로 만들 때 사용
- XOR 연산

## 시프트 마이크로 연산

### 논리 시프트

- Logical Shift
- 버리고 0 삽입

### 순환 시프트

- Circular Shift = Rotate
- 버린걸 반대편 끝으로 삽입

### 산술 시프트

- Arithmatic Shift
- 부호 비트를 고려하여 수행되는 시프트
- 부호 비트는 남기고 데이터 비트만 시프트

# 처리장치의 구성요소

- ALU: 제어장치에서 명령어를 해독한 다음 실질적으로 연산을 수행하는 장치
- 연산장치는 산술연산장치와 논리연산장치로 구성

## 단일 누산기 CPU의 내부 버스

### 3개의 레지스터 간 병렬전송

- 레지스터가 n비트면 6n개의 신호선

### 단일 버스에 연결된 레지스터 선택회로

- 4개의 레지스터 선택시 2X4 디코더 필요

## ALU

- 산술/논리 연산장치 = Arithmatic and Logical Unit
- 산술, 논리, 시프트 등을 수행하는 장치
- 가산기(산술연산장치), 시프트, 논리연산회로, 보수기(complementer), 상태레지스터(PSR)로 구성

### 산술연산장치

- 전가산기를 이용한 병렬 가산기
- n비트의 2진 병렬가산기는 n개의 전가산기로 구성

![image from hexo](https://i.imgur.com/QntOIgI.png)

### 상태 레지스터와 flag

- C: Carry bit
- S: Sign bit
- Z: Zero bit, 값이 0일시 1로 셋
- V: oVerflow bit
- 연산 결과에 따라 1 또는 0

### 논리연산장치

- AND, OR, NOT, XOR
- 멀티플렉서와 조합논리회로 (& | ! ^) 게이트를 이용하여 구성 가능

### 시프터

### 제어단어

- Control word
- 하드와이어드 제어방식과 마이크로프로그램 제어방식 (제어장치 구현방법)
- 마이크로 프로그램 제어방식은 제어장치 내의 기억장치에 마이크로 명령어를 저장하여 마이크로 연산을 순차적으로 수행시키는데 이 마이크로 명령어를 제어단어라고 한다.

## 파이프라인 처리구조

- 명령어 파이프라인: CPU에서 명령어를 읽어 순차적으로 실행, 하나의 명령어가 실행되는 도중에 다른 명령어 실행을 시작하는 식으로 동시에 여러 개의 명령어를 실행하는 기법

## 실행과정

- 명령어 인출: Instruction Fetch
- 명령어 해독: Instruction Decode
- 오퍼랜드 인출: Operand Fetch
- 실행: Excute

# 마이크로프로그램 제어

- 마이크로 명령어들의 집합

## 제어장치

- 주기억장치에 있는 프로그램, 명령어를 순서대로 읽어옴
- 명령어를 해독
- 각 장치에 신호를 보내 프로그램 처리

### 제어장치 제어기능

- 오퍼레이션 부분과 오퍼랜드로 구성 (Op Code와 Address)
- 명령어 수행단계는 인출단계와 실행단계로 나뉨

### 제어장치 구성

- IR (Instruction Register): 명령 레지스터, 주기억 장치에서 인출된 명령어를 기억하는 레지스터
- Instruction Decoder: 명령 해독기, 명령 레지스터로부터 명령코드를 받아서 해독하고 결과는 제어신호 발생기에 전송
- 제어신호 발생기: 타이밍 발생회로와 제어회로로 구성
- Program Counter: 프로그램 계수기, 다음 실행될 명령어를 가진 주기억장치의 주소를 기억하는 레지스터

### 명령어 수행 과정

1. PC의 주소를 MAR로 전송
2. MAR 번지에 있는 명령어를 읽어 MBR로 전송, PC 1 증가
3. MBR에서 IR로 전송, OP Code와 주소필드를 각각 해독기와 주소 레지스터로 전송
4. MAR에서 데이터와 Operand 주소를 계산하고 주기억장치에 접근
5. 제어신호 발생기에서는 연산자를 해독하여 명령수행을 위한 제어신호 발생
6. 반복

## 명령어 사이클

| 상태      | 기능                                                                                                                                                             |
| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Fetch     | 1. 명령어를 주기억장치에서 읽음<br/>2. 명령어 해독<br/>3. 1사이클이면 실행 후 fetch로 이동<br/>4. 아니면 유효주소를 계산해 간접주소면 indirect, 직접이면 execute |
| Indirect  | 1. 주소를 주기억장치에서 읽음<br/>2. 간접주소이면 다시 indirect<br/>3. 분기명령이면 실행 후 fetch<br/>4. 아니면 execute                                          |
| Execute   | 1. 데이터를 주기억장치에서 읽음<br/>2. 실행 후 fetch                                                                                                             |
| Interrupt | 1. PC 내용을 스택에 저장<br/>2. PC는 인터럽트 시작주소로 변경<br/>3. PSR I bit에 1 처리<br/>4. 인터럽트 처리루틴의 fetch로 이동                                  |

| 플리플롭 | 메이저 상태 |
| -------- | ----------- |
| 0 0      | Fetch       |
| 0 1      | Indirect    |
| 1 0      | Execute     |
| 1 1      | Interrupt   |

### Fetch Cycle

1. MAR <= PC
2. MBR <= M[MAR], PC <= PC + 1
3. IR <= MBR

### Indirect Cycle

1. MAR <= IR(addr)
2. MBR <= M[MAR]
3. IR(addr) <= MBR

### Execute Cycle

- ADD X
  1. MBR <= M[MAR]
  2. AC <= AC + MBR
- LDA X: X번지에서 데이터를 읽어 누산기에 저장하는 명령어 (LOAD)
  1. MBR <= M[MAR]
  2. AC <= MBR
- STA X: 누산기의 내용을 X번지에 저장하는 명령어 (STORE)
  1. M[MAR] <= AC
- ISZ X: X번지의 내용을 1증가 시키고 결과값이 0이면 다음 명령어를 실행하지 않고 건너뛰는 명령 (Increment & Skip if Zero)
  1. MBR <= M[MAR]
  2. MBR <= MBR + 1
  3. M[MAR] <= MBR, if( MBR = 0 ) then ( PC <= PC + 1 )
- AND X: 누산기와 X번지 내용을 AND 연산해 결과값을 누산기에 저장하는 명령어
  1. MBR <= M[MAR]
  2. AC <= AC & MBR

### Interrupt Cycle

1. MBR <= PC
2. MAR <= SP, PC <= ISR (Inturrupt Service Routine)
3. M[MAR] <= MBR

## 마이크로 연산

한 개의 클록펄스 동안 레지스터의 데이터가 실행하는 기본 동작

## 수평 마이크로 명령어

- 제어신호필드, 조건분기필드, 주소필드
- 마이크로 명령어는 0, 1로 제어신호 출력
- 한 개의 비트가 하나의 마이크로 연산을 지정
- 조건분기필드는 branch에 사용
- 주소필드는 다음에 실행될 마이크로 명령어의 주소 지정
- 동작속도가 빠르고 하드웨어를 효율적으로 사용하는 장점
- 긴 제어단어가 필요해 비용이 많이 드는 단점

## 수직 마이크로 명령어

- 디코딩을 통해 제어신호 발생
- 제어단어의 비트 수가 줄어든다
- nbit로 2^n개의 마이크로 연산 표시 가능
- 디코더 필요

## 단일 사이클 제어

모든 레지스터의 이동은 클록 펄스에 의해 제어

- 마이크로 사이클: 하나의 마이크로 연산이 수행되는 과정
- 마이크로 사이클 타임
- 마이크로 오퍼레이션: 마이크로 사이클 동작
- 동기식과 비동기식으로 구분
- 하드웨어 제어방식
- 1개의 클록 사이클에 1개의 명령어를 실행

### 동기 고정식

- 가장 수행시간이 긴 것을 사이클 타임으로 설정
- 모든 마이크로 연산의 시간이 유사한 경우 사용
- 구현 간단
- CPU 처리시간 낭비 발생

### 동기 가변식

- 유사한 것끼리 몇 개의 군으로 모아서 마이크로 사이클 타임을 설정
- CPU의 성능을 높이고 전체적으로 속도 향상
- 제어 복잡

### 비동기식

- 각각의 마이크로 연산에 대해 서로 다른 마이크로 사이클 타임을 설정
- 하나의 마이크로 연산이 끝나면 다음 마이크로 연산 타임이 신호가 발생
- 복잡해서 안 사용함

## 하드웨어 제어

2X2bit 인 경우 4개의 AND 게이트와 2개의 반가산기 필요

## 파이프라인 제어

하나의 프로세서를 서로 다른 기능을 가진 여러 개의 서브 프로세서로 나누어 각 프로세서가 동시에 서로 다른 데이터를 처리하도록 하는 기법

# 명령어 집합

## 마이크로 명령어의 형식

- 연산 필드
- 조건 필드: 상태 비트 조건 선택 필드
- 분기 필드
- 주소 필드: 다음 주소 지정

## 처리장치

### 명령어 해독기

- instruction decoder
- op code를 해독하고 연산의 시작주소를 결정

### 제어주소 레지스터

- CAR = Control Address Register
- 제어 메모리의 주소를 지정하는 레지스터
- 다음 실행할 마이크로 명령어의 주소를 저장

### 제어기억장치

- Control Memory
- 마이크로프로그램이 저장된 내부기억장치

### 제어 버퍼 레지스터

- CBR = Control Buffer Register
- 제어 메모리에서 읽은 마이크로 명령어를 일시적으로 저장하는 레지스터

### 서브루틴 레지스터

- SBR = Subroutine Register
- 서브루틴이 발생한 경우 현재 제어주소 레지스터(CAR)의 내용을 일시적으로 저장하는 레지스터

### 순서제어 모듈

- Sequencing Module
- 마이크로 명령어의 실행순서를 결정하는 모듈

## 명령어 주소 결정

1. 제어주소 레지스터 1 증가
2. 무조건 분기와 상태 비트 조건에 따른 조건부 분기
3. 명령어의 op code로부터 제어기억장치의 주소로 매핑
4. 서브루틴 call, return

## 제어기

### 순서 레지스터와 디코더를 이용한 방식

- 각 상태마다 하나의 출력신호가 발생하도록 디코더를 사용
- nbit의 순서 레지스터는 n개의 플리플롭과 게이트로 구성
- 2bit의 경우 2^2 = 4개의 상태 표시, 2X4 디코더 필요

### 상태 플리플롭을 이용한 제어방식

- 각 상태에 한 개의 플립플롭이 필요
- 한 순간에 여러 개의 플립플롭 중에 단 한 개만 1이 된다.
- 다수의 플립플롭이 필요
- 상태 수가 증가하면 상당히 복잡해진다
- 설계는 간편

## CISC

- Complex Instruction Set Computer
- 다양한 어드레싱 기능
- 명령어 길이와 실행시간이 가변적
- 명령어 복잡

## RISC

- CPU의 명령어 개수를 줄여 하드웨어 구조를 좀 더 간단하게 만드는 방식
- 높은 처리속도
- 단순 구조
- 주기억장치 액세스 명령어의 제한
- 주소지정방식의 단순화

> 사상(Mapping): 각 명령어의 실행 전용 루틴을 찾는 것

# 기억장치

## 참조 지역성

### 공간적 지역성

- Spatial locality
- 특정 데이터가 참조되면 그 부근의 데이터가 참조될 확률이 높아짐

### 시간적 지역성

- 특정 데이터를 액세스하면 빠른 시간 내에 그 데이터를 다시 참조하는 확률이 높음
- 캐시의 이유

## 기억장치 성능평가 요인

- 기억용량: capacity
- 접근시간: access time
- 사이클타임: 하나의 액세스 시작부터 다음 액세스를 시작할 때까지의 시간
- 기억장치 대역폭: bandwidth 1초동안 송수신할 수 있는 비트 수
- 가격

> 속도 순서: 레지스터 > 캐시 > 주기억장치 > 보조기억장치 (디스크 > 테이프)

## 주기억장치

> 폰 노이만 병목현상: 주기억장치를 이용하는데 CPU와 입출력장치가 경쟁해 주기억장치에 병목 현상이 발생하는 것

### 복수모듈기억장치

- 독자적으로 데이터를 저장할 수 있는 기억장치 모듈을 여러 개 가진 기억장치
- 기억장치 버스를 시분할하여 사용

### 메모리 인터리빙

CPU가 각 모듈로 전송할 주소를 교대로 배치한 후 차례대로 전송하여 여러 모듈을 병행 접근하는 기법

- 기억장치 접근시간을 효율적으로 높임
- 캐시, 고속 DMA 전송에 사용
- 각 모듈을 번갈아가며 접근 가능

### 연관기억장치

- CAM = Content Addressable Memory)
- 워드에 접근하여 원하는 정보를 찾는 기억장치
- bit serial, bit parallel 구조
- 내용에 의한 검색
- 캐시 내부에서 사용
- 외부 인자와 내용을 비교하기 위해 병렬판독논리회로, 하드웨어 장치가 필요

## 캐시기억장치

- 주기억장치보다 빠른 기억소자로 구성해 CPU와 주기억장치 속도차를 줄임
- 주기억장치에서 캐시로 워드를 전송할 때 그 주위 워드도 같이 전송됨 => 그 블록을 캐시로 이동
- 히트: 액세스하려는 단어가 캐시에 있을 경우
- 미스: 액세스하려는 단어가 캐시에 없을 경우
- 캐시에 공간이 없으면 희생 블록을 선택해야한다.

> 적중률 = 히트 수 / 전체 메모리 참조 수
> 교체알고리즘: FIFO, random, LRU (미사용 중 가장 오래된 것부터), LFU (최소 사용부터)

### 캐시 사상방식

- 직접사상: tag와 index 필요, 캐시와 주기억장치 인덱스 부분이 같은 경우에만 데이터가 저장
- 연관사상: 데이터와 주기억장치의 주소도 함께 저장
- 집합연관사상: 캐시 인덱스에 서로 다른 2개 이상의 데이터 블록을 저장

## 가상기억장치

- 대용량 보조기억장치 일부를 주기억장치로 사용
- 프로그램 명령어가 사용하는 주소를 가상주소, 주기억장치에 접근하기 위한 주소를 물리적 주소
- CPU에서 참조하는 가상주소는 주기억장치의 실제 주소로 변환되어야 하며 이 것을 사상(mapping) 이라고 함
- 사상방식에는 페이징 기법과 세그먼트 기법이 있다.

### 페이징 기법

- 가상기억공간과 실제기억공간의 프로그램 블록의 크기가 같고 각 블록의 크기도 모두 동일할 때 이 블록을 페이지라고 한다.
- 주기억장치에서 페이지를 찾지 못하는 경우를 page fault

### 세그먼트 기법

- 프로그램의 논리적 구조에 따라 세그먼트를 다양하게 나누는 방법

## 보조기억장치

### 자기디스크

- 블록: 자기디스크에서 주소에 의해 지정될 수 있는 정보의 단위
- 트랙: 디스크 표면의 동심원
- 헤드가 트랙을 지나가며 R/W
- 액세스 암: 금속 끝에 헤드가 달려 있음
- 이동 헤드 디스크: 플로피
- 고정 헤드 디스크: 하드
- 탐색시간: 헤드를 트랙까지 이동하는데 걸리는 시간
- 회전지연시간: 섹터의 시작주소에 헤더가 도달하는데 걸리는 시간
- 전송시간: 섹터에서 데이터를 읽어 주기억장치로 옮기는 데 걸리는 시간
- 디스크 access time = seek time + rotational delay + transfer time

### 자기테이프

- 순차접근방식
- 용량이 커 장시간 보관 용도로 사용
- DEBDIC 코드는 9트랙, BCD 코드는 7트랙
- BPI: Byte Per Inch 1인치당 저장하는 바이트 수
- 시작점은 BOT 끝점은 EOT
- IRG: Inter Record Gap 레코드 사이의 갭
- IBG: Inter Block Gap 블록 사이의 갭

## RAID

Redundant Array of Inexpensive Disks
여러 개의 하드를 하나듸 하드로 다루는 방법

- 하드웨어 RAID: 안정적이지만 고가
- 소프트웨어 RAID: 운영체제에서 레이드 구성, 신뢰성은 떨어져도 저렴하게 데이터 저장 가능
- 디스크 인터리빙: 데이터를 여러 개의 디스크에 분산 저장하는 기술

### RAID-0

- 빠른 입출력을 목적으로 하는 데이터를 여러 개의 하드에 분산 저장하는 스트라이핑 방법 사용
- 하나의 디스크에 저장하는데 걸리는 시간을 여러 개의 디스크에 동시적으로 분산하여 저장하는 방식
- 동영상 편집과 출판에 적합
- 장애 발생시 뻑남

### RAID-1

- 미러링 기법
- 한 드라이브에 기록되는 모든 데이터를 다른 드라이브로 복사
- 하드 용량을 50%만 사용가능

### RAID-2

- 에러 검출 능력이 없는 드라이브를 위해 검사 디스크를 추가하고 해밍코드로 에러 검출 및 정정
- 요즘은 오류 검출기능을 달고 나와서 거의 안씀

### RAID-3

- RAID-0의 빠른 I/O에 에러 보정 기술이 추가
- 별도의 패리티 드라이브를 사용
- 장애시 패리티 정보를 이용한 복구 가능

### RAID-4

- RAID-3에다가 각 드라이브에 데이터를 블록 단위로 분산 저장
- 데이터 출력시 빠른 성능이지만 저장시 패리티 블록도 변경해야하는 단점
- 최소 3개의 드라이브

### RAID-5

- RAID-3과 4의 단점 보완
- 패리티 갱신을 위한 디스크 액세스가 분산되어 패리티 디스크에 대한 병목현상이 사라져 쓰기를 병렬로 수행 가능

### RAID-6

- RIAD-5에 다차원 패리티 체계를 구축한 시스템
- 2개의 패리티 블록을 저장
- 쓰기시 2개의 패리티를 갱신해야함

## 광기억장치

### CD-ROM

- Compact Disk Read Only Memory
- 데이터는 트랙에 따라 순차적 저장
- 액세스는 순차적이 아닌 직접 액세스 방식

### DVD

- 용량은 4.7~8.5GB
- 2장의 얇은 디스크가 겹쳐져 있는 형태

> 1ns = 10^-9 s

# 입출력 제어기

## 입출력장치

- 데이터를 저장하고 시스템에서 처리한 결과를 출력

## 입출력장치 제어기

- 입출력장치를 움직이는 구동장치
- 보통 입출력 장치에 포함

## 입출력장치 인터페이스

- 입출력 포트 = I/O port
- CPU 내부 레지스터와 입출력장치 간의 정보전송을 제어

## 입출력 버스

- 데이터 전달 경로
- 고성능 시스템에서는 입출력 제어기를 통해 주기억장치 버스에 연결

## 주기억장치 버스

- 주소 버스
- 데이터 버스
- 제어 버스

> CPU에 의한 입출력 => DMA에 의한 입출력 => 채널에 의한 입출력

# 버스

- 버스에 연결된 장치는 master와 slave로 나뉨
- master는 데이터 전달회선의 사용권 획득 및 실제 데이터 전송에 필요한 데이터를 제어
- slave는 데이터 전달에 필요한 작업을 하는 장치

## 주기억장치버스

- 주기억장치의 데이터 버스 비트 수는 주기억장치 워드의 비트수와 같다
- R/W

## 입출력 버스

- 입출력에만 이용
- 한 쪽에는 입출력 인터페이스, 다른 쪽에는 입출력 제어기
- 입출력 데이터 버스의 비트 수는 1Byte
- 양방향
- 주소버스의 bit는 장치번호의 bit 수와 같다.

## 버스 중재 방식

### 중앙집중식 병렬중재

- centralized parallel arbitration
- 하나의 버스에 하나의 중재기를 사용하는 방식
- 모든 장치는 각각 버스 요청과 버스 허용회선에 의해 중재기에 연결됨
- 중재기 내의 장치들의 우선순위를 정해주는 논리회로가 있어야한다.

### 데이지 체인

- 직렬중재 = daisy chain
- 중재기 버스 사용의 우선순위는 외부 데이지 체인 하드웨어에서 결정
- 우선순위 높은 장치가 버스를 독점할 수 있다.
- 직렬연결이라 한 장치가 고장나면 다음 장치는 버스허용신호를 못 받는다.

### 폴링

- polling = 주기적 검사방식
- 버스중재기가 각 master에게 버스 사용 여부를 체크하는 방식
- 하드웨어 폴링: 버스 중재를 위해 폴링 회선이 따로 중재기와 각 장치에 연결, 중재기가 각 장치의 고유번호를 순차적으로 발생시키므로 버스 사용권을 받기까지 시간이 길다.
- 소프트웨어 폴링: 폴링의 순서를 CPU가 관리하는 방식으로 우선 순위 또는 융통성이 좋다. 하드웨어보다 느리다.

## 전송 제어 방식

### 스트로브 제어

- 데이터 전송시간을 맞추기 위해 제어회선이 추가
- 제어회선을 통해 송수신측에 데이터를 전송할 때 제어신호를 보낸다.
- 수신쪽에서 데이터를 받았는지, 송신쪽에서 데이터를 보냈는지 확인 불가

### 핸드쉐이킹

# 입출력장치 인터페이스

| Busy Done | 입출력 데이터 버퍼 상태                                                                  |
| --------- | ---------------------------------------------------------------------------------------- |
| 0 0       | 입출력장치 휴지 상태                                                                     |
| 0 1       | 금지 상태                                                                                |
| 1 0       | 입출력 작업 중 상태                                                                      |
| 1 1       | 입력 데이터 버퍼에서 데이터를 읽거나 출력 데이터 버퍼에서 데이터를 기억시킬 수 있는 상태 |

## 데이터 전달방법

### 직렬전송방식

입출력장치 인터페이스 내에 있는 입출력 데이터 버퍼는 시프트 레지스터

### 병렬전송방식

CPU 내의 레지스터 사이 데이터 전송방법과 같다.

## 에러 체크

- 패리티 비트: 데이터를 첨가하는 비트가 1bit
- 되울림: echo back 키보드에 입력한 문자를 화면에 나타내어 확인
- 입출력 반복: retry 한 바이트가 잘못 읽어지면 반복해서 읽어오는 방식
- 오류검사/수정코드: 오류가 검출될 때 수정할 수 있는 기능이 있음

# 입출력 제어기

## 주기억장치 사상 입출력

하나의 공통된 버스를 공유하는 입출력 시스템에서 주소를 지정하는 방식으로는 기억장치사상 입출력 방식과 고립형 입출력 방식이 있다.

### 기억장치 사상 입출력

- 하나의 주소공간
- 공통의 버스와 제어선

### 고립형 입출력

- 입출력장치의 주소영역은 주기억장치의 주소영역과는 별도로 지정
- 분리된 제어신호
- 2개의 제어선으로 지정된 주소가 주기억장치 워드에 해당되는지 입출력을 위한 인터페이스 레지스터를 지정하는 것인지 구분

## CPU에 의한 입출력

### 프로그램에 의한 입출력 방식

- CPU가 입출력장치의 처음부터 끝까지 제어
- 저속 컴퓨터에 적합
- 매번 플래그 검사를 해야하기 때문에 가장 비효율적

### 인터럽트 처리에 의한 입출력 방식

- 전송할 데이터가 준비되면 인터페이스가 CPU에 입출력을 요청하는 인터럽트 발생

### DMA를 사용한 입출력

- CPU의 개입 없이 입출력장치와 주기억장치 사이에 데이터를 직접 전송시키는 방법
- Direct Memory Access
- DMA에 의한 입출력이 수행되면 CPU는 주기억장치 버스를 제어하지 못함
- DMA 제어기 신호: 버스 요청, 버스 승인, 인터럽트 신호
- DMA 전송 방식
  - DMA burst transfer: DMA 대량전송 방식, DMA가 주기억장치 제어권을 가지고 있을 때 여러 개의 워드로 구성된 블록이 연속으로 전송
  - 사이클 스틸 방식: 한 번에 하나의 데이터 원드를 전송하고 주기억장치의 버스 제어를 CPU에 돌려줌

## 채널에 의한 입출력

- DMA는 초기화 데이터가 필요하며, 여러 입출력장치가 있을 때 많은 DMA 제어기가 필요
- 입출력 장치와 직접 통신하는 전용 프로세서
- CPU와 동급의 성능
- 고유의 입출력 명령어를 인출하고 실행
- 산술, 논리, 연산작업 수행 가능

### selector channel

- 선택된 입출력장치의 모든 동작이 완료될 때까지 어느 한 입출력장치의 전용인 것처럼 운용되는 채널
- 고속 입출력 장치와 입출력을 위해 사용
- burst 방식으로 블록 데이터 전송

### 바이트 멀티플렉서 채널

- 하나의 채널에 저속에 많은 입출력장치를 구동시키는데 알맞은 방식
- 채널을 시분할 공유

### 블록 멀티플렉서 채널

- 동시에 여러 고속 입출력장치를 공유하여 데이터를 고속으로 전송
- 대형 컴퓨터

> 채널 제어기의 연결형태: 고정 채널 제어기, 가변 채널 제어기
> CPU가 DMA제어에 보내는 초기화정보: R/W를 수행할 주기억장치의 시작주소, 전송할 데이터 워드 카운트, R/W 전송모드 지정, 입출력 수행할 장치주소

# 컴퓨터 시스템의 성능

- 처리능력: Throughput 작업량
- 처리속도: response time
- 신뢰도: reliability 정확하게 해결하는지
- 사용 가능도: usability 신속하게 사용 가능한지

## 처리속도

### MIPS

- Millions of Instruction Per Second
- 1초에 처리되는 총 명령어의 수
- 1MIPS는 1초에 106개 명령어

### MFLOPS

- Millions of Floating-Point Operation Per Second
- 메가플롭스
- 부동 소숫점 처리 속도를 나타내는 단위
- 1MFLOPS는 초당 10^6개 부동소수점 연산 가능

# 병렬컴퓨터

## 플린의 분류

### SISD

- Single Instruction stream, Single Data stream
- 명령어가 하나씩 순차로 실행
- 현재 많이 쓰는 컴퓨터 구조

### SIMD

- Single Instruction stream, Multiple Data stream
- 배열처리기 = array processor
- 모든 처리기들의 동작은 모두 하나의 제어장치의 지시를 받음

### MISD

- 여러 개의 처리기에서 수행되는 명령어는 다르지만 전체적으로 하나의 데이터 스트림을 갖고 있는 형태
- 사용하지 않음

### MIMD

- 대부분의 다중 프로세서 시스템과 다중 컴퓨터시스템
- 처리기들간의 상호작용 정도에 따라 밀결합 시스템, 소결합 시스템으로 나뉨
- 밀결합 시스템: tightly coupled system, 공유기억장치구조, 다중 프로세서 시스템
- 소결합 시스템: loosely coupled system, 지역기억장치를 가진 독립적인 컴퓨터 모듈, 프로세서 간 메세지 방식 통신, 다중 컴퓨터 시스템

## 팽의 분류

병렬 수행정도에 따라 분류

- WSBS: Word-Serial, Bit-Serial
- WPBS: Word-Parallel, Bit-Serial
- WSBP: Word-Serial, Bit-Parallel
- WPBP: Word-Parallel, Bit-Parallel

WBSP는 가장 많이 사용하는 방식으로 한 번에 한 워드씩 처리

## 구조에 의한 분류

- 분산처리: 하드웨어 자원이 프로세스 작업에 대해 상대적으로 약하게 결합하여 동작하는 것, 컴퓨터 네트워크 등
- 병렬처리: 프로세스 작업에 대해 강하게 결합되어 동작하는 것, 다중컴퓨터, 다중처리기로 구분됨

### 공유기억장치 시스템

- 공유기억장치를 갖는 다중처리기구조는 처리기와 기억장치 모듈사이에 완전한 연결성이 있는 강결합 시스템
- 기억장치 요청이 지역적인지 비지역적인지를 판단하기 위해 기억장치 대응장치(MMU: Memory Mapping Unit)이 필요

### 메세지 전달 시스템

- 데이터 통신이 메세지를 통해 이뤄짐
- 메세지는 여러 개의 고정된 길이를 갖는 패킷으로 구성
- 단순성과 확장성의 성질을 포함해 대규모에서 좋은 성능

## 다중 프로세서의 고려사항

- 병렬성
- 기억장치 (충돌, 접근 효율성, 캐시 일관성)
- 스케줄링
- 동기화
- 시스템 균형

# 병렬처리기

## 파이프라인 처리기

시간적 병렬성 활용

> 파이프라인: 하나의 프로세스를 서로 다른 기능을 가진 여러 개의 서브프로세스로 나ㅜ너 각 서브프로세스가 서로 다른 데이터를 취급하도록 하는 방식

## 배열 처리기

- 처리장치(PE)를 배열 형태로 갖고 있음
- PE는 레지스터, 연산장치, 지역기억장치로 구성
- PE는 상호연결망에 의해 데이터 교환 가능
- 벡터, 행렬 계산에 사용

## 다중처리기

- multiple processor
- 시스템상의 여러 처리기들에 여러 개의 독립적인 작업을 각각 배정하여 2개 이상의 처리기를 동시에 수행할 수 있는 기능을 갖춘 시스템
- 하드웨어 시스템 구성은 주로 기억장치와 처리기, 기억장치와 입출력 채널 간 상호연결구조에 의해 결정

## 데이터 흐름 컴퓨터

- 프로그램 내의 모든 명령어를 수행에 필요한 피연산자들이 모두 준비될 때 명령어의 순서와 관계없이 수행시키는 것
- Data Driven 방식

## VLSI 처리기

- 병렬 알고리즘을 직접 하드웨어로 구현하는 처리기
- 파이프라인 기법을 이용한 다중처리 기법
- systolic array 구조가 있는데 영상이나 신호처리를 위한 특수분야에 사용

# 상호연결망 구조

처리요소를 가진 병렬시스템에서 처리요소와 기억장치 사이를 연결해주는 네트워크

- 대역폭: bandwidth 네트워크를 통해 전송될 수 있는 최대 데이터 전송률, 단위는 MB/s
- 네트워크 지연: 네트워크를 통해 메세지 전송시 소요되는 지연시간
- 기능성: functionality 네트워크 데이터 경로설정, 동기화, 인터럽트 처리 및 메세지 송수신과 같은 동작을 어느정도 지원해 주는지
- 확장가능성: scalability 새로운 하드웨어 추가시 네트워크 확장이 가능한지
- 하드웨어 복잡성: hardware complexity 네트워크 구현시 필요한 하드웨어, 부품의 수와 복잡성

## 정적 상호연결망

### 성형

허브에 모두 연결됨

### 선형

노드가 차례대로 연결

### 링형

선형의 끝이 연결된 원형

### 2진 트리

완전한 트리형태, 통신거리가 상대적으로 김

### 펫 트리

채널의 크기가 상위계층으로 올라갈 수록 커져서 상위 수준에서의 병목현상 해결

### 메시, 토러스

노드가 2차원 사방으로 연결, 배열처리기에 적합

### 하이퍼큐브

- 처리기의 수가 증가하면 연결점 및 하드웨어가 급증하므로 많은 처리기를 연결할 때 좋은 효율
- 높은 확장성
- 모든 노드가 같은 경로배정방법 사용 가능

## 동적 상호연결망

### 버스

- 단일 버스 구조: 미니컴퓨터나 마이크로 컴퓨터에서 사용
- 다중 버스 구조: 고성능 시스템

### 크로스바

- 네트워크 규모가 커지면 비용이 크지만 지역적인 기반구조로 유용
- P개의 처리기와 M개의 기억장치 모듈을 동시에 연결

### 다단계 네트워크

- multistage network
- 근원지와 목적지 사이에 여러 개의 스위치 요소가 있는 상호연결망

# 파이프라이닝

- 어떤 일을 실행하는 데 있어서 하나의 일을 여러 단계로 나눠 중첩하여 실행함으로써 선능을 높이는 방법
- 수행 단계별로 2단계, 4단계, 6단계가 있다.
