---
title: 알고리즘
authors: me
tags: [정보처리]
date: 2017-04-01 23:06:24
---

# 객체지향

## 객체지향 기법

- 현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어 기계적인 부품들을 조립하여 제품을 만들 듯 소프트웨어를 개발할 때도 객체들을 조립해 작성할 수 있도록 하는 기법

## 객체

- 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈
- **데이터**: 객체가 가지고 있는 정보
- **함수**: 객체가 수행하는 기능, 객체가 갖는 데이터를 처리하는 알고리즘

## 클래스

- 공통된 속성과 연산을 갖는 객체의 집합
- 객체의 일반적인 타입
- 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
- **인스턴스**: 클래스에 속한 각각의 객체

## 메세지

- 객체들 간에 상호작용을 하는 데 사용되는 수단
- 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항

# 객체지향 기본 원칙

## 캡슐화

- Encapsulation
- 데이터와 데이터를 처리하는 함수를 하나로 묶는 것
- 연관된 데이터와 함수를 함께 묶어 외부와의 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 과정

## 정보 은닉

- Information Hiding
- 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것
- 캡슐화에서 가장 중요한 개념

## 추상화

- Abstraction
- 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략하는 것
- 모델화

## 상속성

- Inheritance
- 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

## 다형성

- Polymorphism
- 메세지에 의해 객체가 연산을 수행하게 될 때 하나의 메세지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답하는 것

# 객체지향 생명 주기

> 계획 및 분석 => 설계 => 구현 => 테스트 및 검증

## 객체지향 분석

- OOA = Object Oriented Analysis
- 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 이와 연관된 속성과 연산, 그들간의 관계 등을 정의하여 모델링하는 작업

## 객체지향 설계

- OOD = Object Oriented Design
- 객체지향 분석을 사용해 생성한 여러 가지 분석 모델을 설계 모델로 변환하는 작업
- 시스템 설계와 객체 설계를 수행

> 문제 정의 => 요구 명세화 => 객체 연산자 정의 => 객체 인터페이스 결정 => 객체 구현

## 객체지향 구현

- 설계 단계에서 생성된 설계 모델과 명세서를 근거로 하여 코딩하는 단계
- 객체 기반 언어: Ada, Actor와 같이 객체의 개념만을 지원
- 클래스 기반 언어: Clu와 같이 객체와 클래스의 개념을 지원
- 객체 지향성 언어: 객체, 클래스, 상속의 개념을 모두 지원, Simula, Smalltalk, C++, Objective C, Java

> **객체지향 프로그래밍**
>
> - OOP = Object Oriented Programming
> - 새로운 개념의 모듈 단위, 즉 객체를 중심으로 하여 프로그램을 개발하는 기법

## 객체지향 테스트

### 클래스 테스트

- 구조적 기법에서의 단위 테스트와 같은 개념
- 캡슐화된 클래스나 객체를 검사하는 것

### 통합 테스트

- 객체 몇 개를 결합하여 하나의 시스템으로 완성시키는 과정에서의 검사
- 스레드 기반 테스트: 시스템에 대한 하나의 입력이나 이벤트에 응답하는 데 요구되는 클래스들을 통합하는 것
- 사용 기반 테스트: 독립 클래스를 테스트한 후 독립 클래스를 사용하는 다음 계층의 종속 클래스를 테스트

### 확인 테스트

- 사용자 요구사항에 대한 만족 여부를 검사

### 시스템 테스트

- 모든 요소들이 적합하게 통합되고 올바른 기능을 수행하는지 검사

# 아키텍처

## IEEE 1471

- ANSI / IEEE 1471-2000
- 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 요소와 내용들, 이들 간의 관계를 규정하고 있는 국제 표준
- 표준화, 중립성, 유연성, 의사소통

## 저장소 구조

- 중앙자료구조와 독립된 컴포넌트로 구성된 아키텍처
- 큰 데이터의 이동 및 공유에 적합하며 컴포넌트 간 통신은 이뤄지지 않는다.
- 대량의 데이터를 저장하는데 효과적이다.
- 컴포넌트의 추가 삭제가 편리하다.
- 중앙 집중화를 통해 데이터 관리가 용이하고 보안이 뛰어나다.

## MVC 구조

- 애플리케이션을 모델, 뷰, 컨트롤러의 세 개의 컴포넌트로 구분하는 아키텍처
- 유저 인터페이스와 비지니스 로직들을 서로 분리하여 개발하는 방법
- 장점
  - 동일한 모델에 대해 다양한 뷰 제공
  - 효율적인 모듈화 가능
  - 모델과 뷰의 구분으로 사용자 인터페이스에 대한 요구 사항을 적용시키는데 용이

### 모델

- 애플리케이션의 핵심 기능을 포함
- 상태 변화시 컨트롤러와 뷰에 전달

### 뷰

- 정보 표시를 관리
- 결과물 생성을 위해 모델로부터 정보를 수신

### 컨트롤러

- 사용자로부터 입력을 받아 모델과 뷰에 명령을 전달
- 모델에 명령을 전달해 상태를 변경하고 뷰에 명령을 보내 표시 방법을 변경

## 클라이언트/서버 구조

- 클라이언트와 서버로 나뉘는 아키텍처
- 클라이언트: 사용자로부터 입력을 받아 서버에 요청을 전달
- 서버: 수신된 요청을 수행하고 데이터의 일관성을 유지
- 새로운 서버의 추가 및 업그레이드가 용이
- 데이터가 서버에 집중되어 데이터 관리 용이
- 서버에 네트워크 트래픽과 데이터가 집중되 처리 비용이 급증할 수 있다.

## 계층 구조

- 계층적으로 조직화가 가능한 애플리케이션에 적합한 아키텍처
- 인접 계층 사이에서만 요청과 응답이 이뤄지며 변경 사항을 적용할 때에도 두 개의 인접 계층에만 영향을 미쳐 원활한 변경이 가능
- OSI 7 Layer

## 파이프 필터 구조

- 데이터의 흐름을 점진적으로 처리하는 시스템을 위한 아키텍처
- 프로세싱을 위한 시스템이 각 필터에 캡슐화되어 있으며 데이터는 인접 필터 사이의 파이프를 통해 전달되는 형태

# 서식 문자열

- %d: 정수형 10진수 입출력
- %c: 문자 입출력
- %s: 문자열 입출력
  - %-8.3s: 8칸 확보 후 문자열 왼쪽부터 문자열 3개 출력
- %f: 소숫점을 포함하는 실수로 입출력
  - 자릿수 없으면 6자리까지 표기
  - %8.3f: 8칸 확보 후 오른쪽부터 정수 표기 후 소숫점은 3자리까지 출력

# 패딩 비트

- 양수: Left, Right 모두 0
- 음수: Left 0, Right 1

# 연산자 우선순위

1. 단항
2. 산술
3. 시프트
4. 관계: < <=가 == !=보다 우선
5. 비트: &(and), ^(xor), |(or) 순서
6. 논리: &&, || 순서
7. 삼항연산

> xor, 다른면 1 같으면 0

# 소수 판별

- N을 2~(N-1)까지 차례대로 나눠 떨어지는지 확인
- N을 2부터 차례대로 나눠 처음으로 나눠떨어질 때의 나눈 수와 N이 같으면 소수
- N를 2부터 루트N 까지 숫자로 나눠 떨어지는지 확인

# 소수의 개수

- 처음 나온 소수의 배수들은 소수가 아니다

# 최대공약수, 최소공배수

- 유클리드 호제법 사용
- 두 수 중 큰 수와 작은 수를 정한 뒤 큰 수를 작은 수로 나눠 나머지를 구한다.
- 나머지가 0이면 그 때의 작은 수가 최대공약수
- 두 수를 곱한 값을 최대공약수로 나눈 값이 최소공배수
- 나머지가 0이 아니면 작은 수를 큰 수로, 나머지를 작은 수로

# 약수

- N을 1부터 N까지 나눠 나머지가 0이 되는 수

# 소인수 분해

- N을 2에서 루트N까지 나눠 떨어지는지 확인
- 나눠 떨어졌다면 그 수는 소인수
- 나눌때의 몫을 다시 N으로 놓고 2에서 루트 N까지 나눠떨어지는지 확인

# 10진법에서 2진법

- 10진수를 2로 나눠 나머지를 구한 후 저장

# 10진법에서 N진법

- 10진수를 N진법의 가장 가까운 누승부터 1까지 차례대로 나누는 방법
