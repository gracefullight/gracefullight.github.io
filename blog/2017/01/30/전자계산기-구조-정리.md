---
title: 전자계산기 구조 정리
password: 1012
authors: me
tags: [정보처리]
date: 2017-01-30 00:35:16
---

# 불 대수

- 영국 수학자 불에 의해 개발
- AND : 입력 값이 모두 1일 때 1 출력
- OR : 입력 값이 하나라도 1일 때 1 출력
- NOT : 부정

## 기본 공식

- **합의 곱을 곱의 합으로 변환**
- 분배법칙 예외 : A ＋(B×C) = (A ＋ B)(B ＋ C)
- 드모르강
  - (A ＋ B)\` = A\`×B\`
  - (A×B)\` = A\`＋ B\`
- 멱등
  - A ＋ A = A
  - A×A = A
- 보수
  - A ＋ A\` = 1
  - A×A\` = 0
- 항등
  - A ＋ 0 = A
  - A ＋ 1 = 1
  - A×0 = 0
  - A×1 = A
- 콘센서스
  - AB ＋ BC ＋ CA\` = AB ＋ CA\`
  - (A ＋ B)(B ＋ C)(C ＋ A\`) = (A ＋ B)(C ＋ A\`)
- 복원 : A\`\` = A
- 기타
  - A ＋ A\`B = A ＋ B
  - A ＋ AB = A

## 카르노 맵

- 설계된 논리식을 도표로 표현하여 최소화 하는 방법
- Karnaugh map = K-map = 카노맵

![카르노 맵](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg/275px-K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg.png)
AB와 CD의 위치를 바꾸어 계산하는게 쉽다.

|        | **00** | **01** | **11** | **10** |
| ------ | ------ | ------ | ------ | ------ |
| **00** | 0      | 1      | 3      | 2      |
| **01** | 4      | 5      | 7      | 6      |
| **11** | 12     | 13     | 15     | 14     |
| **10** | 8      | 9      | 11     | 10     |

# 논리 게이트

- BUFFER : 입력된 정보를 그대로 출력
- NAND : NOT + AND
- NOR : NOT + OR
- XOR : 입력이 같으면 0, 다르면 1
  - X = A⊕B
  - X = A\`B + AB\`
  - X = (A + B)(A\` + B\`)
- XNOR : NOT + XOR
  - X = A&#8857;B
  - X = (A⊕B)\`
  - X = AB + A\`B\`

# 조합논리회로

반가산기, 전가산기, 병렬가산기, 반감산기, 전감산기, 디코더, 인코더, 멀티플렉서, 디멀티플렉서, 다수결회로, 비교기 등

## 반가산기

2진수 두 개를 더한 합과 자리올림수를 구하는 조합논리회로

- 합은 S, 자리올림(캐리)는 C
- C = AB
- S = A\`B + AB\` = A⊕B

## 전가산기

1bit 2진수 3자리를 더하여 합과 자리올림수를 구하는 조합논리회로

- 두 개의 반가산기와 한 개의 OR GATE로 구성
- 합은 S, 자리올림(캐리)는 C
- C = (A⊕B)C + AB
- S = (A⊕B)⊕C
- 3 × 8 디코더 1개 + 4 입력 OR 게이트 2개로 구성가능

## 병렬가산기

n bit로 된 2진수 A, B에 대한 덧셈을 n개의 전가산기를 이용하여 구현한 실질적인 가산기

- 전파지연을 줄이기 위해 Carry Look Ahead 사용
- 전파지연 : ALU Path에서 가장 긴 Delay

## 반감산기

1bit 2진수 2자리에 대한 감산을 하는 조합논리회로

- 차는 D, 빌려온 수는 B
- B = A\`B
- D = A\`B + A\`B = A⊕B
- 2 × 4 디코더 1개 + 3 입력 OR 게이트 1개로 구성가능

## 디코더

n bit의 코드화된 정보를 그 코드의 각 bit 조합에 따라 2^n개의 출력으로 번역하는 조합논리회로

- **n개의 입력을 2^n개의 출력으로**
- 명령어의 명령부나 번지를 해독할 때 사용
- 주로 AND 게이트로 구성
- 부호화된 데이터에서 정보를 찾아냄
- n × 2^n 디코더의 AND 게이트 수 : 2^n 개
  - 5 × 8 디코더 : 8개

## 인코더

2^n개의 입력선으로 입력된 값을 n개의 출력선으로 코드화해서 출력하는 조합논리회로

- **2^n개의 입력을 n개의 출력으로**
  - 16개의 입력선일 경우 4개의 출력선 필요 (2^4)

## 멀티플렉서

2^n개의 입력선 중 1개를 **선택**하여 그 선에서 입력되는 값을 1개의 출력선으로 출력하는 조합논리회로

- 2^n개의 입력선 중 1개의 선을 선택하기 위해 **n개의 선택선 이용**
  - 16개의 입력선일 경우 4개의 선택선 필요 (2^4)
  - **출력선은 하나**

## 디멀티플렉서

1개의 입력선으로 들어오는 데이터를 2^n개의 출력선 중 1개를 선택하여 출력하는 회로

- 2^n개의 출력선 중 1개의 선을 선택하기 위해 **n개의 선택선 이용**
- 16개의 출력선일 경우 4개의 선택선 필요 (2^4)
- **입력선은 하나**

# 순서논리회로

- 외부의 입력과 현재 상태에 따라 출력이 결정
- 논리 게이트 외에 메모리 요소와 피드백 기능을 포함
- 기억기능 존재
- 출력이 일정한 값을 갖지 않음
- **플리플롭과 논리 게이트로 구성**
- 동기식과 비동기식으로 나뉨
- **플리플롭, 카운터, 레지스터, RAM, CPU** 등

## 플리플롭

- 전원이 공급되는한 상태의 변화를 위한 외부신호가 발생할 때까지 현재의 상태를 그대로 유지하는 논리회로
- 레지스터, 카운터, 반도체메모리(RAM)의 기본 구성요소
- 2진수 1bit를 저장 가능
- 두 개의 NAND 또는 두 개의 NOR 게이트를 이용하여 구성

### 특성표

순서논리회로의 기능을 나타내는 표로 입력선의 값에 따라 현재 상태가 다음 상태로 어떻게 변하여 저장되는지를 나타낸다.

### 여기표

특성표 대신 순서논리회로의 기능을 표로 나타낸 것, 현재 상태 값을 새로운 값으로 변경시키려면 입력선으로 어떤 값을 입력해야 하는가를 나타낸다.
출력을 이용하여 입력을 알아내는 것.

### RS 플립플롭

- Reset-Set FF
- 특성표

|  S  |  R  |  Q   |
| :-: | :-: | :--: |
|  0  |  0  |  無  |
|  0  |  1  |  0   |
|  1  |  0  |  1   |
|  1  |  1  | 不可 |

- 여기표는 특성표를 떠올리면 구할 수 있다.

### D 플립플롭

- RS 플리플롭의 R선에 인버터(NOT 연산자)를 추가하여 S선과 하나로 묶어서 입력선을 하나만 구성한 플립플롭
- 입력값을 그대로 저장하는 기능을 수행
- 특성표

|  D  |  Q  |
| :-: | :-: |
|  0  |  0  |
|  1  |  1  |

### JK 플립플롭

- RS에서 S=1, R=1일 때 동작하지 않는 점을 보완한 플립플롭
- RS 플립플롭의 입력선 S와 R에 **AND 게이트 2개**를 추가하여 JK 플립플롭의 입력선 J와 K로 사용한다.
- 모든 플립플롭의 기능을 포함한다.
- 플립플롭의 네가지 기능을 모두 갖춘 것을 찾으라는 문제가 나오면 RS가 있으면 RS, JK가 있으면 JK
- 특성표

|  S  |  R  |  Q   |
| :-: | :-: | :--: |
|  0  |  0  |  無  |
|  0  |  1  |  0   |
|  1  |  0  |  1   |
|  1  |  1  | 보수 |

- 여기표는 특성표를 떠올리면 구할 수 있다.

### T 플립플롭

- JK 플립플롭의 두 입력선을 묶어서 한 개의 입력선으로 구성한 플립플롭
- T=1인 경우 현재 상태를 토글한다. **보수가 출력**된다.
- 카운터에 이용

|  T  |  Q   |
| :-: | :--: |
|  0  |  無  |
|  1  | 보수 |

### M/S 플립플롭

- 마스터-슬레이브 플립플롭
- 출력 측의 일부가 입력 측에 피드백되어 유발되는 레이스 현상을 없애기 위해 고안된 플립플롭
- 두 개의 플립플롭으로 구성
- 레이스 현상 : 입력이 되는 조합회로의 출력을 플리플롭이 받는 동안 플리플롭의 내부 상태가 변하고 있으면 그 상태값이 피드백통로를 통해 조합회로로 전달되므로 회로가 불안정해지는 현상

# 자료 구성 단위

## 비트

- 자료, 정보 표현의 최소 단위
- 0과 1을 표시하는 2진수 1자리

## 니블

- 4bit가 모여 구성
- 16진수 1자리를 표현하기에 적합

## 바이트

- **문자를 표현하는 최소 단위**
- 8bit가 모여 1Byte
- 1Byte는 256가지의 정보를 표현(2^8bit)
- Alphanumeric은 1Byte, 한글한자는 2Byte
- KB = 2의 10승, MB = 2의 20승...

## 워드

- 컴퓨터가 한 번에 처리할 수 있는 명령 단위
- **전워드 : 4Byte** (full word)
- 하프워드 : 2Byte (반워드)
- 더블워드 : 8Byte

## 필드

- 파일 구성의 최소 단위
- 의미 있는 정보를 표현하는 최소 단위

## 레코드

- 하나 이상의 관련된 필드가 모여서 구성
- 컴퓨터 내부 자료 처리 단위
- **논리 레코드**를 의미

## 블록

- **물리 레코드**
- 하나 이상의 논리 레코드가 모여서 구성
- 각종 저장 매체와의 입출력 단위를 의미

## 파일

- 프로그램 구성의 기본 단위
- 같은 종류의 여러 레코드가 모여서 구성

## 데이터베이스

- 여러 개의 관련된 파일의 집합
- 관계형, 계층형, 망형 DB

# 진법

## 2진수

정수는 나누고 소숫점은 곱하고

## 8진수

2진수를 구하고 3자리씩 묶고

## 16진수

2진수를 구하고 4자리씩 묶고

# 보수

- 덧셈회로를 이용하여 뺄셈을 수행하기 위해 사용
- 1의 보수 : 그냥 반전
- 2의 보수
  - 1의 보수를 구한 뒤 1을 더함
  - 뒤에서부터 1이 나올때까지는 그냥쓰고 나머지는 반전

## 뺄셈

- 1의 보수 이용 : 자리올림이 발생하면 결과에 자리올림수를 더한다.
- 2의 보수 이용 : 자리올림이 발생하면 버린다.

# 고정 소수점

정수 데이터 표현 및 연산에 사용하는 방법

## 2진연산

- 정수값을 2진수로 변환하여 표현하는 방식
- 표현할 수 있는 범위가 작음
- 연산속도 빠름
- 맨처음 1bit는 부호비트로 사용

### 음수연산

- 부호화 절대치법 : 양수 표현에 대해 부호비트만 바꾼다.
- 부호화 1의 보수법 : 양수 표현에 대해 1의 보수를 구한다.
- 부호화 2의 보수법 : 양수 표현에 대해 2의 보수를 구한다.
  - 1의 보수 표현법에 비해 음수 1개를 더 표현할 수 있다.
  - 자리올림을 무시하므로 1의 보수 표현에 비해 연산이 간단하다.
  - 0이 하나만 존재한다.

> **부호화 2진 표현을 10진수로 변경시**
>
> 1. 부호 비트를 빼고 2의 보수 연산
> 2. 부호를 대입

## 10진연산

### 언팩연산

- 존형 10진연산 = Zone Decimal
- **연산이 불가능**하다.
- **데이터 입출력에 사용**
- 1Byte로 10진수 1자리를 표현
- 4개의 존 비트와 4개의 숫자 비트를 사용
- **최하위 바이트의 존 부분을 부호로 사용**
- Zone = F, Digit = 4Bit 2진수
- Sign = 양수 C, 음수 D, 부호 없는 양수 F

### 팩연산

- **연산이 가능**
- **데이터 입출력 불가능**
- 1Byte로 10진수 2자리를 표현
- **최하위 바이트의 마지막 4Bit를 부호로 사용**
- Digit = 4Bit 2진수
- Sign = 양수 C, 음수 D, 부호 없는 양수 F

# 부동소수점

- 매우 크거나 작은 수, 매우 정밀한 수를 적은 비트로 표현 가능
- 연산시간이 느림
- 부동 소수점의 연산 수행횟수를 FLOPS로 표시
  - **FLOPS** : FLoating point Operations Per Second, 컴퓨터 연산속도의 단위
- 지수부와 가수부를 분리하는 **정규화** 과정 필요
  **정규화** : 0.1 <= 가수부분 < 1 을 만족시키게 변경
- 4Byte를 사용하는 단정도와 8Byte를 사용하는 배정도 표현법
- 지수부에는 정규화해서 분리한 지수값을 **64Bias**법으로 표현
  - 64Bias : 지수 7Bit에 100 0000이 입력되어 있고 2^n의 n만큼을 더하고 뺴서 지수를 표현하는 방식

## IEEE 표준

- IEEE 754 표준
- 정규화시 가수부가 1이되게 정규화
- **127Bais**를 사용해 지수 8Bit에 0111 1111이 들어있음

|   구분   |  크기  | 부호 |  지수  | 가수 |
| :------: | :----: | :--: | :----: | :--: |
|  single  | **32** |  1   | **8**  |  23  |
|  double  | **64** |  1   | **11** |  52  |
| extended |   80   |  1   |   11   |  68  |

## 연산

### 덧셈 및 뺄셈

1. 0인지 확인
2. 지수가 큰쪽에 수를 맞추어 정규화
3. 연산
4. 결과 정규화

### 곱셈

1. 0인지 확인
2. 지수 덧셈
3. 가수 곱셈
4. 결과 정규화

### 나눗셈

1. 0인지 확인
2. 레지스터 초기화
3. 부호 결정
4. 나눠지는 수가 나누는 수보다 작게 나눠지는 수를 정규화
5. 지수 뺄셈
6. 가수 나눗셈

# 자료 표현

## BCD

- 2진화 10진코드 = Binary Coded Decimal
- 6Bit 코드로 IBM에서 개발
- 1개의 문자를 2개의 Zone Bit와 4개의 Digit Bit로 표현
- 6Bit이므로 64개 문자 표현 가능
- 1Bit의 Parity Bit를 추가해 **7Bit로 사용**
- **영소문자 표현 불가**

## ASCII

- American Standard Code for Information Interchange
- 7Bit 코드로 미국 표준협회에서 개발
- 7Bit이므로 128개의 문자 표현 가능
- 1Bit의 Parity Bit를 추가해 **8Bit로 사용**
- **영대소문자, 숫자, 제어문자, 특수문자 등 표현 가능**
- 통신 제어용 및 마이크로 컴퓨터의 기본코드로 사용

## EBCDIC

- 8Bit 코드로 IBM에서 개발
- 1개의 문자를 4개의 Zone Bit와 4개의 Digit Bit로 표현
- 8Bit이므로 256개의 문자 표현 가능
- 1Bit의 Parity Bit를 추가해 **9Bit로 사용**
- **특수문자, 영대소문자, 숫자 등 표현 가능**

## BCD 코드

- 10진수 1자리를 2진수 4Bit로 표현
- **8421 코드**
- **가중치 코드**
  - 2진수 각 자리가 고유한 값을 가지는 코드
- BCD에서 Zone을 생략한 형태
- 10진수 입출력이 간편

## Excess3 코드

- BCD 코드에 3을 더하여 만든 코드
- 모든 비트가 동시에 0이 되는 경우가 없다.
- **3 초과 코드**
- **자기보수 코드**
- **비가중치 코드**
- 10진수를 표현하기 위함이다.
- 보수를 구하기 편해 산술연산에 좋다.

## Gray 코드

- BCD 코드의 인접하는 Bit를 XOR 연산하여 만든 코드
- 코드 변환이 용이
- 입출력장치, A/D변환기, 주변장치 등에서 숫자를 표현할 때 사용
- 1Bit만 변화시켜 다음 수치로 증가시키기 때문에 하드웨어 오류가 적다.
- 2진수를 Gray로 변경시 : n자 모양으로 연산
  - 첫번째 그레이 비트는 2진수 첫번째 비트 그대로
  - 2진수 비트를 앞뒤로 XOR 연산
- Gray를 2진수로 변경시 : h자 모양으로 연산
  - 첫번째 2진수는 그레이 비트 그대로
  - 두번째부턴 왼쪽 변경된 2진수와 변경할 우측 그레이 비트를 XOR 연산

## 패리티 코드

- 전송된 코드의 오류를 검사하기 위해 데이터 비트 외에 1Bit의 패리티 체크 비트를 추가하는 것
- 1Bit의 오류만 검출 가능

### 홀수 패리티

- Odd Parity = 기수 패리티
- 1의 갯수가 홀수가 되도록 0이나 1을 마지막에 추가

### 짝수 패리티

- Even Parity = 우수 패리티
- 1의 갯수가 짝수가 되도록 0이나 1을 마지막에 추가

## 해밍 코드

- 오류를 검출하고 교정이 가능한 코드
- 2Bit의 오류를 검출할 수 있고 1Bit를 교정 가능
- 잉여비트가 많이 필요
- 1, 2, 4, 8, ... **2^n번째 Bit는 오류 검출을 위한 패리티 비트**
- 패리티 비트 결정시
  - 1번 Bit는 1, 3, 5, 7...
  - 2번 Bit는 2, 3, 6, 7, 10, 11... 2Bit씩 건너 뛰면서
  - 4번 Bit는 4, 5, 6, 7, 12, 13, 14, 15... 4Bit씩 건너 뛰면서

## 코드 분류

가중치코드는 일반적으로 숫자로 이루어져 있다.

|   분류   |                        코드종류                        |
| :------: | :----------------------------------------------------: |
|  가중치  | BCD(8421), 2421, 84-2-1, Biquinary, 51111, RingCounter |
| 비가중치 |     3초과(Excess3), Gray, Jonson, 2outof5, 3outof5     |
| 자기보수 |          3초과(Excess3), 2421, 51111, 84-2-1           |
| 오류검출 | 해밍, 패리티, Biquinary, RingCounter, 2outof5, 3outof5 |

# 중앙처리장치

**제어장치, 연산장치, 레지스터, 버스**로 구성

## 제어장치

- 컴퓨터의 모든 장치에 대한 동작을 지시하고 제어
- 명령 레지스터에서 읽어들인 명령어를 해독해 장치에 제어신호를 보내 명령을 수행하도록 지시
- 제어장치에 입력되는 항목
  - 명령어 레지스터
  - 플래그
  - 클록

### 구성요소

- 명령 레지스터 : 현재 실행중인 명령어 내용 기억
- 명령 해독기(디코더) : 명령 레지스터에 있는 명령어를 해독
- 제어 발생기(인코더) : 해독된 명령에 따라 각 장치로 본래 제어 신호 생성
- 제어 주소 레지스터(CAR) : 다음에 실행할 마이크로 명령어의 주소를 저장하는 레지스터
  - 매핑의 결과값, 주소필드, 서브루틴 레지스터의 내용이 기록
- 제어 버퍼 레지스터(CBR) : 제어 기억장치로부터 읽혀진 마이크로명령어를 일시적으로 저장하는 레지스터
- 제어 기억장치 : 마이크로 프로그램을 저장하는 내부 기억장치
- 순서 제어모듈 : 마이크로 명령어의 실행 순서를 결정하는 회로집합
- 순차 카운터 : 디코더에 의해 선택된 번호에 해당하는 타이밍 신호를 생성

## 연산장치

- 제어장치에 명령에 따라 실제로 연산을 수행하는 장치
- 산술연산, 논리연산, 관계연산, Shift 등
- 가산기, 누산기(AC), 보수기(Complementor), 데이터레지스터, 오버플로 검출기, 시프트 레지스터 등

## 레지스터

- CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소
- 플리플롭이나 래치들을 병렬로 연결하여 구성
- 메모리 중에서 속도가 가장 빠르다.
- 레지스터의 크기는 워드를 구성하는 비트 개수만큼의 플립플롭으로 구성
  - 워드의 크기가 16Bit => 레지스터는 16개의 플립플롭이나 래치로 구성
- 저장값을 0으로 하는 것을 설정해제(CLR)

### 자료전송

- 직렬 전송 : 직렬 시프트 마이크로 오퍼레이션, 느림
- 병렬 전송 : 하나의 클록펄스 동안 워드가 동시에 전송
- 버스 전송 : 모든 레지스터가 공통으로 이용하는 경로, 병렬에 비해 결선의 수를 줄일 수 있다.

### 주요 레지스터

- **PC** : 프로그램 카운터, 다음번 실행할 명령어의 번지를 기억하는 레지스터로 분기 명령이 실행되는 경우 그 목적지 주소로 갱신
- **IR** : 명령레지스터, 현재 실행중인 명령의 내용을 기억하는 레지스터
- **AC** : 누산기, 연산된 결과를 일시적으로 저장하는 레지스터
- **PSWR** : **Status Register, Program Status Word Register, Flag Regiester**
  - 시스템 내부의 순간 상태가 기록된 정보를 PSW라 한다.
  - 오버플로, 언더플로, 자리올림, 계산상태, 인터럽트 등의 PSW를 저장하는 레지스터
  - 프로그램 제어와 밀접한 관계
- **MAR** : 메모리 주소 레지스터, 데이터의 번지를 기억하는 레지스터
- **MBR** : 메모리 버퍼 레지스터, 데이터가 잠시 기억되는 레지스터, CPU가 데이터를 처리하기 위해서 반드시 거처야한다.
- Base Register : 명령이 시작되는 시작 번지를 기억하는 레지스터
- Index Register : 주소의 변경, 서브루틴 연결 및 프로그램에서의 반복연산의 횟수를 세는 레지스터로 프로그래머가 내용을 변경할 수 있다.
- Data Register : 연산에 사용될 데이터를 기억하는 레지스터
- Shift Register : 저장된 값을 미는 연산을 하는 레지스터, 2배 길이 레지스터
- Major Status Register : CPU의 현재상태(인출, 간접, 실행, 인터럽트)를 저장하고 있는 레지스터

## 버스

- CPU, 메모리, I/O장치와 상호 필요한 정보를 교환하기 위해 연결하는 전송선
- 내부회로에서 버스를 사용하는 목적은 결선의 수를 줄이기 위해서다.

### 종류

- **제어 버스** : Control Bus, **양방향 전송선**, 제어신호 전송
- **주소 버스** : Address Bus, 번지 버스, **단방향 전송선**, 번지 지정
- **데이터 버스** : Data Bus, 자료 버스, **양방향 전송선**, 데이터 전송
- 내부버스 : CPU 및 메모리에 구성된 버스
- 외부버스 : 주변 I/O장치에 구성된 버스

# 명령어

OP code부, Mode부, Operand부로 구성

## 연산자부

- Operation Code부 = OP Code
- 연산자부의 크기는 표현할 수 있는 명령의 종류를 나타내는 것
- nBit일 때 최대 2^n의 명령어 표현 가능

## 모드부

- Mode부
- 주소부의 유효 주소가 결정되는 방법을 지정
- 0이면 직접, 1이면 간접

## 자료부

- Operand부 = 오퍼랜드부 = 주소필드
- 실제 데이터에 대한 정보를 표시하는 부분
- 주소, 레지스터 번호, 사용할 데이터 등을 표시
- 자료부의 크기는 메모리 용량과 관계가 있다.

## 설계시 고려사항

- 연산자의 종류
- 명령어 형식
- 주소지정방식
- 데이터 구조
- 효율성 제고방안 : 기억공간, 사용빈도, 주소지정방식, 주기억장치의 대역폭 이용

## 기능

함수 연산, 자료전달, 제어, 입출력 기능

### 함수 연산 기능

- 산술연산 : ADD, SUB, MUL, DIV, 산술 Shift
- 논리연산 : NOT, AND, OR, XOR, 논리 Shift, Rotate, Complement, Clear
- 단항연산 : NOT, Complement, Shift, Rotate, Move
- 이항연산 : 사칙, AND, OR, XOR, XNOR
- 연산자 우선순위
  1. 산술연산자 : 거듭제곱 > 곱=나눔 > 덧,뺄
  2. 관계연산자
  3. 논리 연산자 : NOT > AND > OR

### 자료 전달 기능

- Load : 기억장치 => CPU
- Store : CPU => 기억장치 저장
- Move : 레지스터간 자료 전송
- Push : 스택에 자료 저장
- Pop : 스택에서 자료 꺼냄

### 제어 기능

- 무조건 분기 : GOTO, JMP (PC <- X)
- 조건 분기 : IF, SPA, SNA, SZA
  - SPA : Skip if AC is Positive
  - SNA : Skip if AC is Negative
  - SZA : Skip if AC is Zero
- Call : 부 프로그램 호출
- Return : 부 프로그램에서 복귀

### 입출력 기능

- Input
- Output

# 연산

## AND

- 특정 비트를 삭제(Clear)하는 연산
- Masking 연산

## OR

- 특정 비트를 1로 만드는 연산
- Selective Set 연산

## XOR

- 두 개의 데이터를 비교하거나 특정 비트를 반전시킬 때 사용
- 결과에 1Bit라도 1이 있으면 서로 다른 데이터
- 반전시킬 Bit를 1과 XOR

## NOT

- 그냥 반전

## 논리 Shift

- 0을 삽입해 비트를 좌우로 한칸씩 민다.

## Rotate

- Shift에서 밀려나간 비트를 반대편으로 가져와 입력하는 연산
- **문자 위치를 변환할 때** 사용

## 산술 Shift

- 부호를 고려하여 자리를 이동시키는 연산
- 2^n으로 곱하거나 나눌 때 사용
- 왼쪽으로 Shift시 2^n을 곱한 값과 같음
- 오른쪽으로 Shift시 2^n을 나눈 값과 같음
- 홀수를 오른쪽으로 Shift시에 0.5의 오차 발생
- 정수 표현 방식에서만 사용 가능
- 정수 수치 표현 방법에 따라 Padding Bit 및 결과가 다름

### Shift Left

- 부호화 절대치, 2의 보수법은 무조건 0
- 1의 보수법은 부호 비트와 같은 0, 1

### Shift Right

- 부호화 절대치는 0
- 1의 보수법, 2의 보수법은 부호 비트와 같은 0, 1

# 명령어 형식

## 3주소 명령어

- Operand부가 세 개로 구성되는 명령어 형식
- **GPR(범용 레지스터)**를 가진 컴퓨터에서 사용
- 연산의 결과는 Operand 1에 주로 기록 (컴퓨터에 따라 Operand 3에도 기록)

### 장점

- 연산시 원래 자료를 파괴하지 않음
- 다른 형식의 명령어를 이용하는 것보다 프로그램 전체의 길이가 짧음
- 전체 프로그램 실행시 명령인출을 위해 주기억장치를 접근하는 횟수 감소

### 단점

- 명령어 한 개의 길이가 너무 길어짐
- 하나의 명령을 수행하기 위해 최소한 4번 기억장소에 접근해야함
- 수행시간이 길다.

## 2주소 명령어

- Operand가 두 개로 구성되는 일반적인 명령어 형식
- 여러 개의 **GPR(범용 레지스터)**를 가진 컴퓨터에서 사용

### 장점

- 실행 속도가 빠르고 기억장소를 많이 차지하지 않음
- 3주소 명령에 비해 명령어의 길이가 짧음
- 계산결과가 기억장치에 기억되고 CPU에도 남아 있어 계산 결과를 시험할 때 시간이 절약된다.

### 단점

- 연산 결과가 주로 Operand1에 저장되므로 원래 Operand1에 있던 자료는 파괴된다.
- 전체 프로그램의 길이가 길어진다.

## 1주소 명령어

- Operand가 한 개로 구성된 명령어 형식
- **AC**를 이용하여 명령어를 처리하므로 결과도 **누산기**에 저장된다.

## 0주소 명령어

- Operand부 없이 OPCode만으로 구성
- 모든 연산은 Stack 메모리의 Stack Pointer가 가리키는 Operand를 이용하여 수행
- 스택 머신
- 인스트럭션 수행시간이 짧다.
- 기억공간 이용이 효율적
- 수식을 계산하기 위해선 Postfix 형태로 변경해야한다.
- 연산 결과를 다시 스택에 넣기 때문에 원래의 자료가 남지 않는다.

# 주소지정방식

## 고려사항

- 표현의 효율성 : 빠르게 접근가능하고, 주소지정에 적은 비트를 사용해야하며 다양항 Address 모드를 사용할 수 있어야한다.
- 사용의 편리성 : 프로그램 작업을 위해 포인터, 프로그램 리로케이션 등의 편의를 제공해야한다.
- 주소공간과 기억공간의 독립성 : 프로그램에서 사용한 주소를 변경 없이 실제 기억공간 내의 주소로 재배치할 수 있도록 서로 독립적이여야한다.
  - 주소공간 : 보조기억장치 내의 기억공간
  - 기억공간 : 주기억장치 내의 기억공간

## 암시적 주소지정방식

- 명령 실행에 필요한 데이터의 위치를 지정하지 않고 누산기나 스택의 데이터를 묵시적으로 지정하여 사용
- 오퍼랜드가 없는 명령이나 오퍼랜드가 1개인 명령어 형식에 사용

## 즉시적 주소지정방식

- 명령어 자체에 오퍼랜드를 가지고 있는 방식
- 별도의 기억장소를 액세스하지 않기 때문에 실행 속도가 빠르다.
- 데이터 값 범위가 제한적이다.

## 직접 주소지정방식

- 오퍼렌드부에 표현된 주소를 이용해 실제 데이터가 기억된 기억장소에 직접 매핑
- 실제 사용할 데이터의 유효주소를 적기 때문에 주소 길이에 제약을 받음
- nBit 오퍼랜드부 => 2^n 개의 주소 표현 가능
- 오퍼렌드부에 데이터를 가지고 있는 레지스터의 번호를 지정하면 레지스터 모드

## 간접 주소지정방식

- 주기억장치를 두 번 이상 접근하여 데이터가 있는 기억장소에 도달
- 오퍼랜드부에 할당된 비트 수로 주소를 나타낼 수 없을 때 사용하는 방식
- 명령어의 길이가 짧고 제한되어도 긴 주소에 접근이 가능한 방식
- 레지스터 간접모드

## 계산에 의한 주소지정방식

- 오퍼랜드부와 CPU의 특정 레지스터 값이 더해져서 유효주소를 계산하는 방식
- 약식 주소
- 상대주소 : 명령어 주소 + PC
- 베이스 레지스터 : 명령어 주소 + Base Register
  - 명령어의 시작주소를 가지고 있는 레지스터
  - 베이스 레지스터의 값과 명령어에 포함된 변위값을 더해 유효주소를 얻는 것을 재배치라고 한다.
- 인덱스 레지스터 : 명령어 주소 + Index Register

# 마이크로 오퍼레이션

- 인스트럭션을 수행하기 위해 CPU 내의 레지스터와 플래그가 의미있는 상태변환을 하도록하는 동작
- 레지스터에 저장된 데이터에 의해 이루어진다.
- 한 개의 클록펄스 동안 실행되는 기본 동작
- 모든 마이크로 오퍼레이션은 CPU의 클록펄스에 맞춰 실행된다.
- 순서를 결정하기 위해 제어장치가 발생하는 신호를 제어신호
- 제어워드 : 레지스어틔 선택과 산술논리연산장치의 역할을 결정하고 어떤 마이크로 연산을 할 지 결정하는 비트의 모임 = 마이크로 명령어
- 마이크로 프로그램 : 제어워드가 저장되 있을 때 마이크로 프로그램

## 마이크로 사이클 타임

- 한 개의 마이크로 오퍼레이션을 수행하는데 걸리는 시간
- CPU는 클록펄스에 의해 동기화되어 동작하는데 펄스를 CPU 클록이라하며 한 개의 마이크로 오퍼레이션은 CPU 클록 발생 주기의 간격 내에 실행된다.
- CPU Cycle Time = CPU Clock Time
- CPU 속도를 나타내는 척도
- 1us = 10^-6s, 1ns = 10^-9s

### 동기 고정식

- 모든 마이크로 오퍼레이션 동작시간이 같다고 가정해 클록 주기를 마이크로 사이클 타임과 같도록 정의하는 방식
- 동작 시간이 가장 긴 마이크로 오퍼레이션의 동작시간을 마이크로 사이클 타임으로 정한다.
- 모든 마이크로 오퍼레이션 동작시간이 비슷할 때 유리하다.
- CPU 낭비가 심하다.
- 구현이 쉽다.

### 동기 가변식

- 수행시간이 유사한 마이크로 오퍼레이션끼리 그룹을 만들어 그룹별로 서로 다른 마이크로 사이클 타임을 정의하는 방식
- 수행시간이 현저한 차이를 나타낼 때 사용
- CPU 시간 낭비를 줄일 수 있다.
- 구현이 복잡하다.
- 각 그룹(집합) 간 서로 다른 사이클 타임의 동기를 맞추기 위해 그룹간 마이크로 사이클 타임을 정수배가 되게 한다.

### 비동기식

- 모든 마이크로 오퍼레이션이 서로 다른 마이크로 사이클 타임을 가진다.
- 시간 낭비는 없다.
- 구현이 매우 복잡하다.
- 실제로 거의 사용되지 않는다.

# 메이저 스테이트

- 현재 CPU가 무엇을 하고 있는가를 나타내는 상태
- Fetch, Indirect, Execute, Interrupt
- Major Cycle = Machine Cycle
- 메이저 스테이트 레지스터를 통해 알 수 있다.
- F와 R 플립플롭의 상태에 따라 메이저 스테이트 상태가 결정된다.

## Fetch Cycle

- 인출단계
- 중앙처리장치의 명령 레지스터로 명령어를 가져와 해독하는 단계
- 가장 먼저 수행되는 동작
- 1Cycle 명령어면 수행 후 다시 Fetch Cycle로 변경됨
- 1Cycle 명령어가 아니면 모드 비트에 따라 직 간접 주소를 판단
- 모드가 0이면 직접주소 => Execute 단계로
- 모드가 1이면 간접주소 => Indirect 단계로

| Click Pulse |       Micro Operation       |                                    Description                                    |
| :---------: | :-------------------------: | :-------------------------------------------------------------------------------: |
|    C0t0     |          MAR ← PC           |                             PC의 번지를 MAR으로 전송                              |
|    C0t1     | MBR ← M[MAR]<br/>PC ← PC +1 |   MAR의 지정하는 위치의 **값을 MBR에 전송** 후<br/>다음 시행할 명령 위치를 지정   |
|    C0t2     | IR ← MBR[OP]<br/>I ← MBR[I] | 명령어의 OPCode를 명령 레지스터에 전송<br/>명령어의 모드 비트를 플립플롭 I에 전송 |
|    C0t3     |       F ← 1 OR R ← 1        |                              I에 따라 F나 R에 1 전송                              |

> - PC : 다음 실행할 명령의 주소가 들어있음
> - MAR : 저장하거나 읽어올 주기억장치의 주소가 들어있음
> - MBR : 주기억장치에서 읽어오거나 저장할 데이터가 들어있음
> - M[MAR] : 메모리에서 MAR에 해당하는 실제 데이터
> - IR : 현재 실행하는 명령어가 들어있음
> - OP : 명령 코드 부분
> - I : 모드 비트
> - AD : 명령 주소 부분
> - F, R : 다음 상태를 지정하는 플립플롭

## Indirect Cycle

- Fetch 단계에서 해석한 주소를 읽어온 후 간접주소이면 유효주소를 계산하기 위해 다시 Indirect 단계를 수행
- 직접주소인 경우 Execute 단계 또는 Fetch 단계로 이동
  - 분기같은 1Cycle 명령이면 Fetch로
  - 실행이면 Execute로

| Click Pulse | Micro Operation |                   Description                    |
| :---------: | :-------------: | :----------------------------------------------: |
|    C1t0     |  MAR ← MBR[AD]  |      MBR에 있는 명령어의 주소를 MAR에 전송       |
|    C1t1     |  MBR ← M[MAR]   | MAR이 지정하는 메모리의 실제 데이터를 MBR에 전송 |
|    C1t2     |        -        |                     동작없음                     |
|    C1t3     |  F ← 1, R ← 0   |               Execute 단계로 이동                |

## Execute Cycle

- 해석된 명령을 실행하는 단계
- 플래그 레지스터의 상태를 검사하여 Interrupt 단계로 갈지 결정

| Click Pulse | Micro Operation |                   Description                    |
| :---------: | :-------------: | :----------------------------------------------: |
|    C2t0     |  MAR ← MBR[AD]  |      MBR에 있는 명령어의 주소를 MAR에 전송       |
|    C2t1     |  MBR ← M[MAR]   | MAR이 지정하는 메모리의 실제 데이터를 MBR에 전송 |
|    C2t2     |  AC ← AC + MBR  |   누산기에 값과 MBR의 값을 더해 ADD 연산 실행    |
|    C2t3     | F ← 0 OR R ← 1  |     F = 0이면 Fetch로, R = 1이면 Interrupt로     |

## Interrupt Cycle

- 인터럽트 발생시 복귀주소를 저장시키고 인터럽트 처리 프로그램의 첫 번째 명령으로 제어순서를 옮긴다.
- 인터럽트 단계는 항상 Fetch 단계로 이동된다.
- 메모리의 인터럽트 주소는 0번지에 저장되고, 인터럽트 벡터는 인터럽트 처리 프로그램의 주소 번지를 말한다.
- 현재 상태를 저장하고 인터럽트가 처리된다.
- 인터럽트 처리시 다음 실행주소를 PC에 넣고 인터럽트 벡터로 이동한다.

| Click Pulse |     Micro Operation      |                                         Description                                          |
| :---------: | :----------------------: | :------------------------------------------------------------------------------------------: |
|    C3t0     | MBR[AD] ← PC<br/>PC ← 0  |       다음 실행 명령 주소를 MBR의 주소로 전송<br/> 복귀주소를 저장할 0번지를 PC에 전송       |
|    C3t1     | MAR ← PC<br/>PC ← PC + 1 |   PC가 가진 0값 번지를 MAR에 전송<br/>인터럽트 벡터 위치를 지정하기 위해 PC 값을 1로 세팅    |
|    C3t2     | M[MAR] ← MBR<br/>IEN ← 0 | MBR에 있는 다음 실행 명령 주소를 0번지에 저장<br/>다른 인터럽트가 발생하지 않게 IEN에 0 전송 |
|    C3t3     |       F ← 0, R ← 0       |                                         항상 Fetch로                                         |

# 주요 마이크로 오퍼레이션

## AND

- AC와 메모리의 내용을 AND 연산해서 AC에 저장
- 논리곱 연산
- AC ← AC ∧ MBR

## ADD

- AC와 메모리의 내용을 더해서 AC에 저장
- AC ← AC +MBR

## LDA

- 메모리의 내용을 AC로 Load하는 명령
- AC에 0을 전송하여 AC를 초기화하는 부분이 있어야함
- **AC ← 0**
- AC ← AC + MBR

## STA

- AC의 내용을 메모리에 저장
- M[MAR] ← MBR

## BUN

- 실행 명령의 위치를 변경하는 무조건 분기
- Branch UNconditionally
- PC ← MBR[AD]

## BSA

- 복귀주소를 저장하고 부 프로그램을 호출하는 명령
- Branch and Save Return Address

| Click Pulse |                 Micro Operation                 |                                             Description                                              |
| :---------: | :---------------------------------------------: | :--------------------------------------------------------------------------------------------------: |
|    C2t0     | MAR ← MBR[AD]<br/>MBR[AD] ← PC<br/>PC ← MBR[AD] | 복귀주소를 MAR에 전송<br/>PC의 값을 MBR의 주소로 전송<br/>부프로그램 호출직전 MBR의 주소를 PC로 전송 |
|    C2t1     |                M[MAR] ← MBR[AD]                 |                                  부프로그램 호출직전 복귀주소 저장                                   |
|    C2t2     |                   PC ← PC + 1                   |                                           부 프로그램 시작                                           |
|    C2t3     |                 F ← 0 OR R ← 1                  |                                         Fetch 또는 Interrupt                                         |

## ISZ

- 메모리의 값을 읽고 값을 1 증가 시킨 후 그 값이 0이면 현재 명령을 건너 뛰고 다음으로 이동
- IF(MBR=0) THEN ← PC + 1

# 제어기

## 제어데이터

- 제어장치가 제어신호를 발생하기 위한 자료
- CPU가 특정한 메이저 상태와 타이밍 상태에 있을 때 제어 자료에 따른 제어 규칙에 의해 발생한다.

### 종류

- 메이저 스테이트 사이의 변천을 제어하는 데이터
- 중앙처리장치의 제어점을 제어하는 데이터
- 인스트럭션의 수행 순서를 결정하는데 필요한 제어데이터

### 단계

|     구분      |     State간 변이      |    제어점 제어     |   수행 순서제어    |
| :-----------: | :-------------------: | :----------------: | :----------------: |
|   **Fetch**   | 명령어의 주소지정방식 |       명령어       |         PC         |
| **Indirect**  |     주소지정방식      |      유효주소      |         -          |
|  **Execute**  |     인터럽트 요청     |   명령어 연산자    |         PC         |
| **Interrupt** |           -           | Interrupt따라 다름 | Interrupt따라 다름 |

## 구현

- 하드웨어적 고정배선제어장치
- 소프트웨어적 마이크로 프로그래밍 기법

### 고정배선 제어장치

- 독립 제어점에 제어신호를 가해야 할 조건들을 제어 데이터와 제어기의 상태로 표현한 후 이를 만족하는 조합논리회로를 설계하여 해당 제어점에 연결하는 방식
- 하드웨어적 구성방법
- 속도 빠름
- 비싸다.
- RISC구조를 기본으로 하는 컴퓨터에서 주로 사용
- 한 번 만들어진 명령어 세트를 변경할 수 없음
- 회로 구성이 복잡

### 마이크로 프로그래밍

- 내부 제어 신호를 지정하는 여러가지 마이크로 인스트럭션으로 작성하는 것
- 소프트웨어적 구성방법
- 펌웨어를 이용하는 방식
- 마이크로 프로그램된 제어장치를 사용하는 컴퓨터는 주 메모리 외에 마이크로 프로그램이 저장되는 제어메모리(ROM)이 필요하다.
- 명령어 세트를 쉽게 변경할 수 있다.
- 다양한 어드레스 모드를 갖음
- 속도 느림
- 유지보수 및 수정 용이
- 복잡한 명령 세트를 가진 시스템에 적합

## 제어 메모리 번지 결정

- 제어 주소 레지스터(CAR) : 값을 1 증가
  - 매핑의 결과값
  - 주소 필드
  - 서브루틴 레지스터 데이터
- 명령 레지스터(IR) : 지정하는 번지로 무조건 분기, 주소 필드로부터 제어 메모리의 주소로 매핑
- 상태 레지스터(SR) : 조건에 따른 분기
- 서브루틴의 호출(call)과 복귀(return)

## 형식

### 수평 마이크로 명령

- Horizontal Micro Instruction
- 한 비트가 한 개의 마이크로 동작을 관할하는 명령
- 마이크로 오퍼레이션 부가 nBit일 때 n개의 마이크로 동작 표현 가능
- 제어 비트를 디코딩 할 필요가 없다.
- 마이크로 명령 한 개로 여러 개의 하드웨어를 동시에 동작시킬 수 있다.
- 제어 워드의 길이가 길어진다.
- 비트가 충분히 활용되지 못함.
- 비용이 많이 든다.

### 수직 마이크로 명령

- Vertical Micro Instruction
- 제어 메모리 외부에서 디코딩 회로를 필요로 하는 마이크로 명령
- 디코더의 출력을 제어신호로 사용
- 한 개의 마이크로 동작만 제어 가능

### 나노 명령

- Nano Instruction
- 나노메모리(낮은 레벨의 메모리)에 저장된 마이크로 명령
- 수직 마이크로 명령을 수행하는 제어기에서 디코더를 ROM(나노메모리)로 바꿔 두 메모리 레벨로 구성
- 제어 메모리의 각 워드는 나노 메모리의 번지를 저장

## 제어장치 구현방식

- 상태 플리플롭 제어
- PLA (Programmable Logic Array)
- 마이크로 프로그램 제어

# 입출력장치

## 입출력 제어장치

- 입출력장치와 컴퓨터 사이의 자료 전송을 제어하는 장치
- 데이터 버퍼 레지스터를 이용하여 두 장치간의 속도 차를 조절 = 데이터 버퍼링
- 제어 신호의 논리적, 물리적 변환 및 오류를 제어
- DMA, 채널, 입출력 프로세서, 입출력 컴퓨터가 포함된다.

## 입출력 인터페이스

- 동작방식이나 데이터 형식이 다른 컴퓨터 내부의 장치끼리 2진 데이터를 원활하게 전송하기 위함
- CPU와 주변장치의 전송속도, 동작방식, 워드형식의 차이 제어
- 동작방식이 다른 주변장치끼리의 차이 제어

## 입출력 버스

- 주기억장치와 입출력장치 사이의 데이터 전송을 위해 **모든 주변장치의 인터페이스에 공통으로 연결된 버스**
- 구성
  - 데이터 버스
  - 주소 버스
  - 제어 버스

## 기억장치와 입출력장치의 차이

- 기억장치 : 전자적, 빠르다, 타율, 오류 적음, Word단위
- 입출력장치 : 기계적, 느리다, 자타율, 오류 많음, Byte(문자)단위

## 비동기 데이터 전송

- 비동기 데이터 전송을 하기 위해선 데이터 전송시각을 알기 위한 제어신호를 서로 교환하여 송수신 상태를 서로 맞춰야한다.

### 스트로브 펄스

- Strobe Pulse
- 데이터 버스와 한 개의 제어선
- 스트로브 신호 : 두 개의 독립적인 장치 사이의 비동기적인 데이터 전송을 하기 위해 전송 시각을 알리는 제어 신호
- 메모리와 CPU 사이의 정보를 교환할 때 사용
- 수신장치가 데이터를 받았는지는 모름

### 핸드쉐이킹

- 데이터 전송시 송신측과 수신측에서 입출력의 준비나 완료를 나타내는 신호를 사용하여 서로의 동작을 확인하면서 데이터를 전송
- 전송을 시작한 장치에 응답하는 제 2의 제어신호를 전송
- 높은 융통성과 신뢰성
- 병렬 입출력 데이터 전송방식의 기본으로 많이 사용
- 2~3개의 제어선 사용
- RDY, STB 신호 사용

## 스풀링

- 다중 프로그래밍 환경 아래에서 용량이 크고 신속한 액세스가 가능한 디스크를 이용해 각 사용자 프로그램이 입출력할 데이터를 직접 입출력장치로 보내지 않고 디스크에 모았다가 한꺼번에 입출력 시키는 방법
- 입출력장치의 공유 및 느린 처리속도를 보완
- 디스크의 일부를 매우 큰 버퍼로 사용한다.
- 큐 방식의 입출력을 수행
- Simultaneous Peripheral Operation OnLine
- 보조기억장치에 저장
- 다중 작업
- 소프트웨어 구현

## 버퍼링

- 입출력 장치와 CPU의 속도차를 해결하기 위해 사용
- 주기억 장치에 저장
- 단일 작업
- 하드웨어 구현

# 입출력 제어방식

- 입출력 처리 능력 순서 : 프로그램 < 인터럽트 < DMA < 채널

## Programmed I/O

- 폴링
- 원하는 I/O가 완료되었는지 여부를 검사하기 위해 CPU의 Status Flag를 계속 조사해 I/O가 완료되었으면 MDR(MBR)과 AC사이의 자료 전송도 CPU가 직접 처리하는 방식
- 입출력의 대부분을 CPU가 해준다.
- MDR(MBR), Flag(PSW), 장치번호 디코더로 구성
- CPU가 계속 I/O에 관여해야되기 때문에 비효율적

## Interrupt I/O

- 데이터 전송 준비가 되면 입출력 인터페이스가 컴퓨터에게 알려 I/O가 이루어지는 방식
- 입출력 인터페이스가 CPU에게 인터럽트 신호를 전송
- 수행중인 프로그램의 **인스트럭션을 끝내고** I/O 처리후 다시 복귀
- 대량 자료 전송시 CPU에 부담

## DMA I/O

- Direct Memory Access
- 입출력장치가 직접 주기억장치를 접근하여 데이터 블록을 입출력하는 방식
- I/O가 CPU를 경유하지 않음
- CPU는 I/O에 필요한 정보를 DMA 제어기에 전달해 I/O동작만을 개시하고 끝
  - I/O 장치의 주소
  - 데이터 있는 주기억장치의 시작 주소
  - DMA 시작 명령
  - I/O 데이터 양
  - 입력 또는 출력을 결정하는 명령
- 빠른 데이터 전송 가능
- DMA는 인터럽트 신호를 발생해 CPU에게 I/O 종료를 알림
- 블록으로 대용량 데이터 전송 가능
- CPU의 **Cycle Steal** 해 메모리를 접근하여 I/O 데이터를 전송
  - 데이터 채널과 CPU가 주기억장치를 동시에 접근할 때 우선순위를 전자에게 줌
  - CPU는 그동안 메모리 참조가 필요없는 오퍼레이션을 계속 진행
  - CPU의 상태 보존이 필요 없음
- CPU와 DMA 제어기는 메모리와 버스를 공유
- 명령 받고 => 버스 사용 요구 => 버스 사용 허가 => 데이터 전송 => 인터럽트 전송
- 한 개의 인스트럭션에 의해 한 개의 블록을 입출력

### 구성

- 인터페이스 회로
- 주소 레지스터 및 주소 라인
- 워드 카운트 레지스터 = 단어 계수기
- 제어 레지스터
- 데이터 레지스터

## Channel I/O

- I/O 프로세서
- I/O를 위한 특별한 명령어를 I/O 프로세서에게 수행토록 하여 CPU 관여 없이 주기억장치와 입출력장치 사이에서 I/O를 하는 전용 프로세서
- DMA의 한계를 극복하기 위해 고안
- DMA의 방법으로 입출력을 수행하지만 확장된 개념
- 채널 제어기는 채널 명령어로 작성된 채널 프로그램을 해독하고 실행하여 I/O 처리
- CPU로 I/O 명령어를 받으면 CPU와는 독립적으로 동작
- 주기억장치에 저장된 채널 프로그램의 수행과 데이터 전송을 위해 주기억장치에 직접 접근
- I/O 장치는 제어장치를 통해 채널과 연결
- I/O 채널은 CPU의 I/O 명령을 수행하지 않고 I/O 채널 내의 특별한 명령어를 수행
- CPU와는 인터럽트로 통신
- 한 개의 인스트럭션에 의해 여러 개의 블록을 입출력
- 입출력장치와 주기억장치를 연결하는 중개자
- 입출력 전담장치
- 입출력 장치와 CPU사이의 존재하는 현저한 속도차를 극복하기 위한 장치
- CPU의 명령을 받고 입출력을 시작하면 CPU와는 독립적으로 조작하는 장치

### 채널 명령어

- 명령코드
- 데이터 주소
- 플래그
- 워드 카운터

### 종류

- Selector Channel
  - 선택 채널
  - 고속 입출력장치(자기로 시작하는 친구들)와 입출력하기 위해 사용
  - 특정 한 개의 장치를 독점해서 입출력
- MultiPlexer Channel
  - 다중채널
  - 저속 입출력장치(카드리터, 프린터)를 제어하는 채널
  - 동시에 여러 개의 입출력장치 제어
- Block Multiplexer Channel
  - 고속 입출력장치를 제어
  - 동시에 여러 개의 입출력장치 제어

# 인터럽트

- 프로그램 실행 도중 예기치 않은 상황이 발생하는 경우 현재 작업을 즉시 중단하고 발생된 상황을 우선 처리 후 실행 중인 작업으로 복귀
- 내부 인터럽트는 CPU의 하드웨어 신호에 의해 발생
- 소프트웨어 인터럽트는 명령어의 수행에 의해 발생

## 외부 인터럽트

- 입출력장치, 타이밍장치, 전원 등 외부 요인에 의해 발생
- 전원 이상 인터럽트 : 정전이거나 정원이상
- 기게 착오 인터럽트 : CPU의 기능적인 오류 동작 발생
- 외부 신호 인터럽트
  - Time Slice 를 알림
  - 인터럽트 키를 누른 경우 (Ctrl + Alt + Del)
  - 외부 장치로부터 인터럽트 요청이 있는 경우
- 입출력 인터럽트
  - 입출력 데이터의 오류나 이상현상 발생
  - 입출력장치가 데이터 전송을 요구하거나 전송이 끝났을 때

## 내부 인터럽트

- 잘못된 명령이나 데이터를 사용할 때 발생
- **트랩**
- 프로그램 검사 인터럽트
  - 0으로 나누기
  - 오버플로 또는 언더플로
  - 프로그램에서 명령어 잘못 사용
  - 부당한 기억장소의 참조
  - 프로그램상 오류

## 소프트웨어 인터럽트

- 프로그램 처리중 **명령의 요청에 의해 발생**
- **SVC 인터럽트**
  - 제어 프로그램 호출 인터럽트 = SuperVisor Call
  - 사용자가 SVC 명령을 써서 의도적으로 호출한 경우
  - 복잡한 입출력 처리를 해야하는 경우
  - 기억장치 할당 및 오퍼레이터와 대화를 해야하는 경우

## 인터럽트시 CPU확인 요소

- 프로그램 카운터 내용
- 사용한 모든 레지스터의 내용
- 상태 조건의 내용 = PSW = Status Register

## 동작 원리

1. 인터럽트 요청 신호 발생
2. 현재 인스트럭션까지 실행 후 프로그램 실행 중단
3. 현재 프로그램 상태 보존
4. 인터럽트 처리 루틴 실행
5. 인터럽트 서비스(취급) 루틴 실행

- 처리기 상태 복구
- 인터럽트 원인 결정
- 처리기 레지스터의 상태 보존
- 상대적으로 낮은 레벨의 마스크 레지스터 클리어

6. 상태 복구
7. 중단된 프로그램 실행 재개

# 인터럽트 우선순위

1. 전원 이상 = Power Fail
2. 기계 착오 = Machine Check
3. 외부 신호 = External
4. 입출력 = I/O
5. 명령어 잘못
6. 프로그램 = Program Check
7. SVC = Supervisor Call

- Non Maskable Interrupt : 마스크 불가능 인터럽트로 0순위

## 폴링

- 소프트웨어적 인터럽트 우선순위 판별 방식
- 우선순위가 높은 인터럽트 자원의 인터럽트 요청 플래그를 검사해 해당하는 인터럽트 서비스 루틴을 수행
- 우선순위 변경이 쉽다.
- 자기디스크와 같이 속도가 빠른 장치에 높은 등급 부여
- 회로가 간단하고 융통성이 있음
- 별도의 하드웨어가 필요 없어 경제적
- 많은 인터럽트가 있을 때 모두 조사해야하므로 반응시간이 느림

## 벡터 인터럽트

- 하드웨어적인 인터럽트 판별 방식
- CPU와 인터럽트를 요청할 수 있는 장치 사이에 장치 번호에 해당하는 버스를 연결하여 요청 장치의 번호를 CPU에게 알리는 방식
- 인터럽트를 발생한 장치가 프로세서에게 분기할 곳에 대한 정보를 제공
- 인터럽트 벡터 : 인터럽트 처리 루틴으로 분기하는 명령어만을 기억하는 기억장치의 특정 영역으로 분기번지가 저장됨
- 별도의 프로그램 루틴이 없어 응답속도가 빠름
- 회로가 복잡하고 융통성이 없음
- 추가 하드웨어가 필요하므로 비경제적

### 직렬 우선순위

- **데이지 체인 방식**
- 모든 장치를 한 개의 회선에 **직렬**로 연결

### 병렬 우선순위

- 인터럽트가 발생하는 각 장치를 개별적인 회선으로 연결
- 각 비트를 개별적으로 세트할 수 있는 **Mask Register** 사용
- 마스크 레지스터는 인터럽트 요청의 허락이 가능하다.
- 우선순위는 마스크 레지스터의 비트 위치에 의해서 결정
- 우선순위가 높은 것이 서비스 받고 있을 때 우선순위가 낮은 것을 비활성화시킬 수 있다.
- 높은 우선순위의 인터럽트는 낮은 인터럽트가 처리되는 중에도 우선 처리된다.

# 기억장치

- 주기억장치 : 시스템 프로그램영역과 사용자 프로그램영역으로 구성
  - 반도체 : RAM, ROM
  - 자기 : 자기 코어
- 보조기억장치
  - DASD : 자기 디스크, 자기 드럼, 하드 디스크, 광디스크
  - SASD : 자기테이프
- 특수기억장치 : 복수 모듈 기억장치, 연관기억장치, 캐시기억장치, 가상기억장치
- 광디스크의 종류 : 블루레이, DVD, Compact

## 계층구조

- 특수기억장치 : 레지스터, 캐시, 연관
- 주기억장치 : RAM, ROM, 자기코어
- 보조기억장치 : 자기디스크, 자기테이프

## 특성 결정 요소

### 기억 용량

### Access Time

- 기억장치에 읽기 요청이 발생한 시간부터 요구한 정보를 꺼내서 사용 가능할 때까지의 시간
- 한 Word의 단위 정보를 읽거나 기록하는데 걸리는 시간
- Access Time = Seek Time + Latency Time(Search Time) + Transmission Time

### Cycle Time

- 기억장치에 읽기 신호를 보낸 후 다시 읽기 신호를 보낼 수 있을 때까지의 시간 간격
- Cycle Time ≥ Access Time
- DRAM : Cycle Time = Access Time + Refresh Time
- 자기코어 : Cycle Time = Access Time + Restoration Time
- **기타 모든 장치** : Cycle Time = Access Time

### Bandwitdh

- 대역폭 = 전송률 = 밴드폭
- 메모리에서 또는 메모리까지 1초동안 전송되는 최대한의 정보량
- 기억장치의 자료 처리 속도를 나타내는 단위
- 하드웨어 특성상 주기억장치가 제공할 수 있는 정보 전달능력의 한계를 의미
- 메모리 워드의 길이가 작을수록 대역폭이 좋음
- 전송단위 : bps = Baud = 보

## 구분

|          구분방식           | 내용                                                                                                        |
| :-------------------------: | ----------------------------------------------------------------------------------------------------------- |
|        내용보존여부         | 파괴성 메모리 : 읽으면 내용이 파괴되므로 재저장시간이 필요<br/> 비파괴성 메모리                             |
| 전원차단시<br/>내용소멸여부 | 휘발성메모리 : RAM<br/> 비휘발성 메모리 : ROM, 자기코어, 보조기억장치                                       |
|         재충전 여부         | 정적메모리(SRAM) : 전원이 공급되면 내용이 계속 유지<br/> 전원이 공급되도 일정시간 후 내용 지워져 재충전필요 |
|          접근 방식          | 순차접근 : 자기테이프<br/> 직접접근 : 자기테이프 제외 모든장치                                              |

# 주기억장치

## ROM

- Read Only Memory
- 읽기전용
- 비휘발성 메모리
- BIOS, 자가진단프로그램 등 변경 가능성이 거의 없는 시스템 소프트웨어 탑재

### 종류

- Mask ROM : 제조 공장에서 프로그램되어 나옴, 내용 변경 불가
- PROM : Programmable ROM, 한 번만 쓰기 가능
- EPROM : Erasable PROM, 자외선을 사용해 내용을 지울 수 있음
- EAROM : Erasable Alterable ROM, 전기적 특성을 이용하여 기록된 정보 일부를 바꿀 수 있는 ROM
- EEPROM : Electonic EPROM, 전기를 이용해 내용 수정 가능

## RAM

- Random Access Memory, Read Write Memory
- 현재 사용중인 프로그램이나 데이터가 저장
- 휘발성 메모리 = Volatile Memory
- 정보가 저장된 위치는 주소로 구분

|   구분   |          동적 램          |         정적 램         |
| :------: | :-----------------------: | :---------------------: |
|   구성   |          콘덴서           |        플리플롭         |
|   특징   | 방전되므로주기적인 재충전 | 전원 공급시에 계속 유지 |
| 소모전력 |           적음            |          많음           |
|   속도   |           느림            |          빠름           |
|  집적도  |           높음            |          낮음           |
|   가격   |           저가            |          고가           |
|   용도   |          일반적           |       캐시메모리        |

## 자기 코어

- 전류 일치 기술에 의하여 기억장소를 선별
- 데이터를 읽으면 내용이 지워지는 **파괴 메모리**
- Dectructive Read Out Memory
- 내용을 읽은 후 지워진 내용을 기록하기 위한 재저장 시간 필요
- 현재 거의 사용되지 않음

### 구성

- 구동선 : X,Y축 번지 선택선 2개
- 센스선 : 자기 코어의 상태를 검출하는 선 1개
- 금지선 : 불필요하게 자화되었을 때 금지 전류를 흘려 자화를 소진시키는 선 1개

## 반도체 기억소자 구성

### RAM

- CS1, CS2 : 칩 선택선
- RD : 입력 신호선
- WR : 출력 신호선
- **AD** : 주소선
  - MAR과 PC의 수와 같음
  - 주소선이 n개이면 2^n개의 워드 지정 가능
- Data Bus : 워드의 크기
  - MBR = IR = 단어의 크기
  - 버스가 10Bit이면 워드의 크기가 10Bit

### ROM

- CS1, CS2 : 칩 선택선
- **AD** : 주소선
- Data Bus : 워드의 크기

# 보조기억장치

- 주기억 장치의 단점 보완
- 속도는 느리지만 전원이 차단되도 내용 유지
- 저장용량이 큼
- CPU와 직접 자료교환이 불가능
- 주기억장치에 데이터를 저장할 때 DMA를 사용

## 자기 테이프

- 순차처리 = SASD
- 블록단위로 데이터를 전송
- 블록 사이에는 데이터를 기록할 수 없는 공간인 **갭**이 있다.
- BOT : Beginning Of Tape
- EOT : End Of Tape
- BPI : Byte Per Inch, 1인치에 기억할 수 있는 바이트 수
- IRG : Inter Record Gap, 레코드와 레코드 사이의 갭
- IBG : Inter Block Gap, 블록과 블록 사이의 갭
- Block : 한 개 이상의 논리 레코드의 집합 = 물리 레코드
- 블로킹 : 한 개 이상의 논리적 레코드를 묶어서 테이프에 기록하는 방식
  - IRG가 줄어든다.
  - 기억공간 낭비 감소
  - Access Time 감소
  - 입출력 횟수 감소
- Blocking Factor : 하나의 블록을 구성하는 논리 레코드의 갯수

## 자기 디스크

- DASD
- 회전축에 여러장의 디스크를 연결하고, 디스크 상하면마다 R/W Head를 액세스암에 연결하여 구성
- 가장 윗면과 가장 아랫면은 사용하지 않는다.
- 트랙 : 디스크 표면에서 회전푹을 중심으로 데이터가 기록되는 동심원
- 섹터 : 트랙들을 일정한 크기로 구분한 부분이며 정보 기록의 기본 단위
- 실린더 : 서로 다른 면들에 있는 동일 위치의 트랙들의 모임
- Random Access와 Sequential Access 방식을 모두 사용

### 디스크의 3요소

- 디스크
- 액세스암
- 헤드

### Access Time

- Access Time = Seek Time + Latency Time + Transmission Time
- Seek Time : 탐색시간으로 R/W Head가 특정 트랙까지 이동하는데 걸리는 시간
- Latency Time : R/W Head가 특정 트랙까지 이동한 후 디스크가 회전하여 트랙에 포함되어 있는 특정 섹터가 R/W Head까지 도달하는데 걸리는 시간
  - Search Time = Rotational Delay Time
- Transmission Time : 전송시간으로 R/W Head가 액세스한 섹터와 주기억장치 간의 자료전송에 걸리는 시간

## 자기 드럼

- 각 트랙마다 고정된 R/W Head를 두고 있다.
- DASD
- Access Time = Latency Time + Transmission Time

# 연관기억장치

- 기억장치에서 기억된 내용의 일부를 이용하여 액세스하는 자료를 찾는 기억장치
- CAM = Content Addressable Memory = 연상기억장치
- 정보 검색 빠름
- 캐시 메모리나 가상 메모리 관리기법에서 사용하는 **매핑 테이블에 사용**
- 외부 인자와 내용을 비교하기 위한 병렬 판독 논리회로를 가지고 있음
- 하드웨어 비용 증가

## 구조

- 데이터 레지스터 : 인수 레지스터, 찾고자 하는 내용의 일부를 기억하는 레지스터
- 키 레지스터 : 마스크 레지스터, 검색에 사용할 비트를 결정하는 레지스터
- 매치 레지스터 : 일치 지시기, 데이터를 찾은 경우 찾았다고 표시하기 위해 사용

# 복수모듈기억장치

- 독자적으로 데이터를 저장할 수 있는 기억장치 모듈을 여러 개 가진 기억장치
- 주기억장치와 CPU의 속도 차이 문제점을 개선
- 기억장치의 버스를 시분할하여 사용
- 각각의 기억장치는 자체 어드레스 레지스터와 버퍼 레지스터를 가지고 독자적으로 데이터를 저장
- 인터리빙 기법에 의해 기억장치를 구성하는 모듈 수만큼 단어(워드)들에 동시 접근 가능
- 버스가 많으면 모든 모듈 동시 병렬 접근 가능

## 메모리 인터리빙

- Memory Interleaving = 디스크 인터리빙
- 여러 개의 독립 모듈로 이루어진 복수 모듈 메모리와 CPU 간의 주소 버스가 한 개로만 구성되어 있으면 같은 시각에 CPU로부터 여러 모듈로 동시에 주소를 전달할 수 없다.
- CPU가 각 모듈로 전송할 주소를 교대로 배치한 후 차례대로 전송하여 여러 모듈을 병행 접근하는 기법
- 중앙처리장치와 기억장치 사이의 실질적인 대역폭 효율을 높일 수 있다.
- 캐시 기억장치, 고속 DMA에서 사용
- CPU 유휴시간 감소

# 캐시 메모리

- CPU와 주기억장치의 속도차를 줄이기 위해 사용
- 고속 Buffer Memory
- 자주 사용하는 프로그램과 데이터를 기억
- 메모리 계층에서 가장 빠른 소자
- 캐시 주소표는 검색 시간을 단축시키기 위해 연관기억장치(CAM)을 사용

## 설계 고려사항

- 캐시 크기
- 전송 블록 크기
- 교체 알고리즘

## 매핑 프로세스

주기억장치로부터 캐시 메모리로 데이터를 전송하는 방법

### 직접 매핑

- Direct Mapping
- 주기억장치의 블록들이 지정된 한 개의 캐시 라인으로만 매핑되는 방법
- 간단하고 구현 비용이 적다
- 적중률이 낮다

### 어소시에이티브 매핑

- Assciative Mapping = 연관 매핑
- 직접 매핑의 단점 보완
- 모든 태그를 병렬로 검사하기 때문에 복잡하고 비용이 높음
- 거의 사용안함

### 세트-어소시에이티브 매핑

- 직접 매핑과 연관 매핑의 장점만 취함

## 쓰기 정책

저장되어 있는 데이터 수정이 발생할 때 수정된 내용을 주기억장치에 갱신하기 위해 시기와 방법을 결정하는 것

- Wirte-Through : 캐시에 쓰기 동작이 이루어질 때마다 캐시 메모리와 주기억장치의 내용을 동시 갱신
- Write-Back : 캐시에 쓰기 동작이 이루어지는 동안은 캐시의 내용만이 갱신, 캐시의 내용이 캐시로부터 제거될 때 주기억장치에 복사
- Write-Once : 캐시에 쓰기 동작이 이루어질 때 한 번만 기록하고 이후의 기록은 모두 무시

## 적중률

- 캐시메모리에 접근하는 경우 원하는 정보가 캐시 메모리에 기억되어 있을 때 적중되었다고 함
- 캐시 기억장치가 있는 컴퓨터의 성능을 나타네내는 척도
- 적중률 = 적중횟수 / 총 접근 횟수
- 미스율 = 1 - 적중률

# 가상기억장치

- **기억 용량이 작은 주기억장치를 큰 용량을 가진 것**처럼 사용할 수 있는 기법
- 보조기억장치를 이용한 주기억장치의 용량 확보
- 소프트웨어적 방법으로 구현
- 프로그램을 여러 블록으로 나눠서 보조기억장치에 보관하고 프로그램 실행시 필요 부분만 주기억장치에 적재
- **오버레이 문제가 자동적으로 해결**
- 보조기억장치 접근이 빈번하면 시스템 처리 효율이 저하
- DASD에만 가능

## 주소

- 가상주소 : 논리주소로 보조기억장치 상의 주소
- 실기억주소 : 물리적주소로 주기억장치 상의 주소

## 관리

- 페이징 기법 : OS가 보조기억장치에 있는 프로그램을 동일한 크기의 블록으로 나눠서 관리
- 세그먼트 기법 : 사용자가 보조기억장치에 있는 프로그램을 가변적인 크기의 블록으로 나눠서 관리

## 관리전략

### 반입 전략

- Fetch
- 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인가?

### 배치 전략

- Placement
- 새로 반입되는 포르개림이나 데이터를 주기억장치 어디에 위치시킬 것인가를 결정
- 최초, 최적, 최악접합이 있음

### 교체 전략

- Replacement
- 주기억장치의 영역이 이미 사용중인 상태에서 새로운 프로그램을 주기억장치에 배치할 때 어떤 방식을 사용할지 결정하는 전략
- FIFO, OPT, LRU, NUR, LFU, MFU 등
- Page Fault 발생시 교체할 페이지를 결정해서 보조기억장치의 이전 위치에 기억시키고 새 페이지를 교체한 페이지의 위치에 놓는 것을 스테이징이라 한다
- 스테이징 : 느린 장치에서 바른 장치로 옮겨가는 것

## 주소 매핑

- 가상주소를 실 기억주소로 변환하는 작업
- 가상주소 형식 : 페이지 번호와 변위값
- 실기억주소 형식 : 페이지 프레임과 변위값
- 페이지 맵 테이블 : 디스크 페이지 번호와 페이지 프레임 번호, 상태 비트

### 변환 순서

- 페이지 번호에 해당하는 페이지 프레임 번호와 가상주소의 변위 주소값을 이용해 실 기억주소를 만듦
- 실기억주소를 이용하여 주기억장치를 액세스

# 병렬 컴퓨터

- I/O 채널 또는 프로세서와 같은 다수의 프로세서에서 동시에 여러 프로세스를 처리하는 것
- 일부 하드웨어 오류가 발생해도 전체 시스템은 동작
- 처리 속도가 빠름
- 프로그램 작성이 어려움
- 기억장치 공유
- 특수한 업무에 적용 : 예보, 인공지능, 역학계산, 모의실험, 유도탄 등

## Flynn의 분류

플린의 분류, 명령 흐름과 자료 흐름을 고려하여 분류

### SISD

- Single Instruction stream Single Data stream
- 현재 보통 컴퓨터 구조
- 명령 하나가 자료 하나를 처리
- 파이프라인에 의한 시간적 병렬 처리 가능

### SIMD

- Single Instruction stream Multi Data Stream
- 한 개의 명령으로 여러 데이터를 동시에 처리하는 구조
- 배열 처리기에 의한 동기적 병렬처리가 가능
- 다수의 처리기가 한 개의 제어장치에 의해 제어

### MISD

- Multi Instruction stream Single Data stream
- 다수의 처리기에 의해 각각의 명령들이 하나의 데이터를 처리하는 구조
- **실제로 사용되지 않음**
- 파이프라인에 의한 비동기적 병렬처리 가능

### MIMD

- Multi Instruction stream Multi Data stream
- 다수의 처리기가 각각 다른 명령 흐름과 자료 흐름을 가지고 여러 개의 자료를 처리하는 구조
- 각 처리기 사이에에서 상호작용(Interaction)이 일어남
- 멀티 프로세서에 의한 비동기적 병렬처리 가능
- Tightly Coupled System = 다중 처리기
- Loosely Coupled System = 분산 처리 시스템

## Feng의 분류

팽은 병렬 수행 정도에 따라 분류

### WSBS

- Word-Serial, Bit-Serial
- 한 번에 한 비트씩 처리하는 방식 (초기 컴퓨터)

### WPBS

- Word-Parallel, Bit-Serial
- 단어를 묶어서 그 중 한 개의 비트 슬라이스 단위를 순차적으로 처리

### WSBP

- Word-Sreial, Bit-Parallel
- 한 번에 한 단어씩 병렬로 처리
- 현재의 컴퓨터

### WPBP

- Word-Parallel, Bit-Parellel
- 단어별 병렬, 비트별 병렬 처리

# 병렬 처리 기법

## 파이프라인 프로세서

- CPU 처리속도를 높이기 위해 여러개의 인스트럭션을 동시에 병렬처리하는 장치
- 시간적 병렬처리
- 명령인출 => 명령 해독 => 오퍼랜드 인출 => 명령 실행
- 스칼라 프로세서를 이용하는 기법
- 파이프라인이 차고 나면 연산속도가 빠르다.
- 같은 연산이 반복되면 효율적이지만 아니면 구조가 복잡하고 시간이 오래 걸린다.

## 벡터 프로세서

산술 및 논리연산, 비교, 내적연산, 최대, 최소값 구하기 등 벡터 연산 명령을 효율적으로 수행하도록 구성된 처리기

### 시스톨릭 프로세서

- 데이터 흐름과 제어 흐름이 규칙적인 특징을 갖는 시스톨릭 알고리즘을 이용하여 수행하는 처리기
- 파이프라인화 된 벡터 프로세서와 배열 프로세서의 특징을 결합한 것
- 초고밀도 직접회로(VLSI) 기법을 이용하여 구현
- 응용의 한계성과 프로그래밍의 어려움이 있음

## 배열 프로세서

- 배열처리기는 PE(Processing Element)라 불리는 다수의 연산기를 갖는 **동기적 병렬 처리기**
- 명령 해독 및 제어는 제어장치가 하고, PE들는 명령 해독 능력이 결여된 수동적 장치로 명령처리만 한다.
- PE를 중복 이용해서 공간적 병렬성을 얻는다.
- 벡터 계산이나 행렬 계산에 적합

## 데이터 플로우 컴퓨터

- 데이터 흐름 컴퓨터는 PC(Program Counter)가 필요 없다.
- 제어 흐름 컴퓨터와는 반대되는 개념
- 인스트럭션의 필요한 피연산자가 모두 준비되었을 때 인스트럭션을 수행하고 결과를 필요로하는 인스트럭션에 보내주는 방식
