---
title: 운영체제 정리
password: 1012
authors: me
tags: [정보처리]
date: 2017-02-08 12:40:58
---

# 시스템 소프트웨어

- 시스템 전체를 작동시키는 프로그램
- 프로그램을 주기억 장치에 적재시키거나 인터럽트 관리, 장치 관리, 언어번역 등의 기능 담당
- 대표적으로 운영체제가 있음
- 번역프로그램, 매크로 프로세서, 링커, 라이브러리, 정렬/합병프로그램, 로더 등

## 구성

- 제어프로그램
- 감시프로그램
- 작업 제어 프로그램 : Jbo Scheduler, Master Scheduler
- 자료 관리 프로그램
- 처리프로그램
- 언어 번역기 : 어셈블러, 컴파일러, 인터프리터
- 서비스 프로그램 : 연결 편집기, 정렬/합병 프로그램, 라이브러리안, 유틸리티
- 문제 프로그램

## 제어 프로그램

- Control Program
- 시스템 전체의 작동 상태 감시, 작업의 순서 지정, 작업에 사용되는 데이터의 관리 등의 역할 수행
- **깜짝데이트**(감시, 작업, 데이터)

### 감시 프로그램

- Supervisor Program
- 제어 프로그램 중 가장 중요함
- 각종 프로그램 실행과 시스템 전체의 작동 상태를 감시 감독

### 작업 제어 프로그램

- Job Control Program
- 다른 업무의 이행을 자동으로 수행하기 위해 준비
- 처리에 대한 완료를 담당하는 프로그램
- 작업의 연속 처리를 위한 스케쥴 및 시스템 자원 할당
- Job Scheduler : 다음 작업을 준비시키는 역할
- Master Scheduler : 시스템과 운영자 사이에서 정보를 주고 받을 수 있도록 중개자 역할 (CMD)

### 자료 관리 프로그램

- Data Management Program
- 주기억장치와 보조기억장치 사이의 데이터 전송과 보조기억장치의 자료 갱신 및 유지보수 기능을 수행

## 처리 프로그램

- Processing Program

### 언어 번역 프로그램

- 원시 프로그램을 기계어 형태의 목적 프로그램으로 번역하는 프로그램
- 어셈블러, 컴파일러, 인터프리터

### 서비스 프로그램

- 연결 편집기 : 프로그램을 연결하여 실행 가능한 프로그램을 만드는 프로그램 (링커)
- 정렬/합병 프로그램 : 데이터를 일정한 기준으로 정렬하거나 정렬된 파일을 합치는 프로그램
- 라이브러리안 : 프로그램의 라이브러리를 유지 관리
- 유틸리티 프로그램 : 사용자의 편의를 도모하기 위한 프로그램 (텍스트에디터, 디버거)
- 문제 프로그램 : 특정 업무 및 문제 해결을 위해 사용자가 작성

# 운영체제

- 컴퓨터 시스템의 자원들을 효율적으로 관리
- 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 프로그램의 집합
- 유틸리티와 하드웨어 사이의 인터페이스 제공

## 목적

- 처리능력 : Throughput 일정 시간 내에 시스템이 처리하는 양
- 반환시간 : Turn Around Time 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
- 사용가능도 : Availability 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
- 신뢰도 : Reliability 시스템이 주어진 문제를 정확하게 해결하는 정도

## 기능

- 프로세서, 기억장치, 입출력장치, 파일 및 자원 관리
- 자원 스케쥴링
- 사용자와 시스템 간의 인터페이스 제공
- 하드웨어와 네트워크 관리 제어
- 데이터 관리하고 데이터 및 자원 공유 기능 제공
- 시스템 오류 검사 및 복구
- 자원 보호 기능 제공
- 입 출력에 대한 보조 기능을 제공
- 가상 계산기 기능을 제공

## 자원관리

- 프로세스 관리 : 프레세스 스케쥴링, 동기화, 생성 제거, 시작 정지, 메시지 전달
- 기억장치 관리 : 프로세스 메모리 할당 및 회수
- 주변장치 관리 : 입출력 장치 스케쥴링 및 관리
- 파일 관리

## 종류

- 단일 작업 처리 시스템
- Single Tasking System
- 시스템을 한 개의 작업이 독점하여 사용하는 방식
- DOS
- 다중 작업 처리 시스템
- Multi Tasking System
- 여러 개의 프로그램을 열어 두고 다양한 작업을 동시에 진행하는 방식
- Windows

# 운영체제 운용 기법

## 일괄 처리 시스템

- 초기의 컴퓨터 시스템
- 일정량 또는 일정 기간 동안 데이터를 모아서 한꺼번에 처리하는 방식
- 일괄 처리를 위해 작업제어언어(JCL)을 제공
- 시스템 효율적 사용 가능
- 반환 시간이 늦지만 하나의 작업이 모든 자원을 독점하므로 CPU Idle Time이 줄어듦
- 급여 계산, 지불 계산, 연말 결산 등

## 다중 프로그래밍 시스템

- 하나의 CPU와 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식
- CPU 사용률과 처리량이 증가

## 시분할 시스템

- Time Sharing System = Round Robin
- 여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리
- 여러 사용자가 각자의 컴퓨터로 동시에 운영체제와 대화하면서 프로그램 실행
- 하나의 CPU는 같은 시점에서 여러 개의 작업을 동시 수행이 안되기 때문에 CPU를 같은 작업 시간량으로 나눠서 그 시간량 동안 번갈아가면서 CPU를 사용
- 작업시간량 : Time Slice = Quantum
- 다중 프로그래밍 방식과 결합하여 모든 작업이 동시에 진행되는 것처럼 대화식 처리 가능
- 시스템 전체 효율은 좋으나 사용자는 반응 속도가 느려질 수 있음

## 다중 처리 시스템

- 여러 개의 CPU와 하나의 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식
- 여러 CPU는 하나의 메모리를 공유하며 단일 운영체제에 의해 관리
- 프로그램의 처리 속도는 빠르지만 기억장치, 입출력장치 등의 자원 공유에 대한 문제점을 해결해야함

## 실시간 처리 시스템

- 데이터 발생 즉시 처리하여 결과를 산출
- 처리시간이 단축되고 처리비용이 절감
- 우주선, 교통제어, 레이더, 핵실험, 데이터수집, 전화교환장치, 인터넷뱅킹 등 시간에 제한을 두고 수행되어야하는 작업

## 다중 모드 처리

- 일괄처리, 시분할, 다중처리, 실시간처리를 한 시스템에서 모두 제공하는 방식

## 분산 처리 시스템

- Distributed Processing System
- 여러 개의 컴퓨터를 통신 회선으로 연결하여 하나의 작업을 처리하는 방식
- 각 단말은 고유의 운영체제와 CPU, 메모리를 가진다.

## 발달과정

- 1세데 : 일괄처리
- 2세대 : 다중프로그래밍, 다중처리, 시분할, 실시간
- 3세대 : 다중모드
- 4세대 : 분산처리

# 컴파일러와 인터프리터

고급언어로 작성된 원시프로그램을 목적프로그램으로 번역하는 번역프로그램

## 저급 언어

### 기계어

- 컴퓨터가 직접 이해할 수 있는 언어
- 기종마다 기계어가 다르므로 언어의 호환성이 없음

### 어셈블리어

- 기계어와 1:1 대응되는 기호로 이루어진 언어
- 니모닉 언어 = Mnemonic = 상징어
- 하드웨어 제어에 주로 사용
- 언어의 호환성이 없음
- 어셈블러를 사용하여 기계어로 번역해야 됨

## 고급 언어

- 컴파일러 언어
- 자연어와 비슷한 형태 및 구조
- 하드웨어 지식이 없어도 작성 가능
- 기계어로 번역하기 위해 컴파일러나 인터프리터가 사용
- C, BASIC, COBOL, ALGOL 등

## 컴파일러

- 고급언어로 작성된 프로그램 전체를 목적 프로그램으로 번역한 후 링킹 작업을 통해 실행 프로그램을 생헝
- 번역과 실행과정을 거쳐야하기 때문에 번역 과정이 번거로움
- 번역 시간이 오래걸림
- 한번 번역 후에는 다시 번역하지 않아 실행속도는 빠름
- C, C++, FORTRAN, COBOL, PL/1
- 대부분의 언어는 컴파일러로 변환된다.

## 인터프리터

- 고급 언어로 작성된 프로그램을 한 줄 단위로 받아들여 번역
- 번역과 동시에 프로그램을 한 줄 단위로 즉시 실행
- 프로그램이 직접 실행되므로 **목적프로그램이 생성되지 않음**
- 시분할 시스템에 유용
- 원시 프로그램에 변화에 대한 반응이 빠름
- 번역 속도는 빠르지만 실행속도는 느림
- BASIC, SNOBOL, LISP, APL
- CPU의 시간낭비가 크다.

# 어셈블리어

- 사용자가 이해하기 어려운 기계어 대신에 명령 기능을 쉽게 연상할 수 있는 기호를 기계어와 1:1 대응시켜 코드화한 기호 언어
- 어셈블리어로 작성한 원이프로그램은 어셈블러를 통해 목적 프로그램으로 어셈블하는 과정을 거쳐야한다.
- 사용자가 프로그램을 쉽게 읽고 이해할 수 있다.
- 프로그램에 기호화된 명령 및 주소를 사용한다.
- CPU마다 사용되는 어셈블리어가 다르다.
- 의사명령과 실행명령으로 구분

## 형식

Label, OP, Operand

- Label : 데이터를 기억할 장소 또는 분기할 위치, 기호 상수에 대한 Symbol을 기술하는 부분으로 생략할 수 있다.
- OP : OPCode를 기술하는 부분
- Operand : OPCode가 연산을 수행하기 위한 대상인 상수, 데이터나 주소, 레지스터 번호를 기술하는 부분

## 어셈블러

- 어셈블리어로 작성된 걸 기계어로 번역하는 프로그램
- 이중 패스 어셈블러르 사용하면 정의되지 않은 기호를 사용할 수 있다.
- 현재 대부분 이중 패스 어셈블러를 사용한다.
- **두 개의 패스를 사용하면 기호를 정의하기 전에 사용할 수 있는 프로그램 작업이 용이**하다.
- 단일 패스 어셈블러 : 원시 프로그램을 하나의 명령문씩 읽는 즉시 기계어로 번역하여 목적 프로그램을 만듦
- 이중 패스 어셈블러 : 원시 프로그램을 끝까지 읽어서 1단계 작업을 수행한 후 다시 처음부터 읽어나가면서 1단계에서 수행한 결과를 이용해 완전한 목적프로그램을 만듦
- 크로스 어셈블러 : 현재 사용하는 컴퓨터와 다른 명령 형태로 동작하는 컴퓨터에서 사용할 프로그램을 어셈블 할 때 사용하므로 실행시킬 컴퓨터에 맞게 목적 프로그램을 생성

### 구성

- 기계 명령어 테이블
  - Machin Operation Table = MOT
  - 어셈블리어의 실행 명령에 대응하는 기계어에 대한 정보를 가지고 있는 테이블
  - 어셈블러에 기본적으로 포함
- 의사 명령어 테이블
  - Pseudo Operation Table = POT
  - 의사 명령과 그 명령을 처리하는 실행 루틴의 주소를 가지고 있는 테이블
  - 어셈블러에 기본적으로 포함
- 기호 테이블
  - Symbol Table = ST
  - 원시 프로그램의 Label 부분에 있는 기호들을 모두 차례대로 저장하는 테이블
- 리터럴 테이블
  - Literal Table = LT
  - 원시 프로그램의 Operand 부분에 있는 리터럴을 차례로 저장하는 테이블

### Pass-1 Pass-2

- Pass-1
  - 기호와 리터럴을 정의
  - 기계 명령어의 길이 정의
  - 위치 계수기(PC, LC) 관리
  - 기호들의 값을 심볼 테이블에 기억
  - 사용된 리터럴을 리터럴 테이블에 기억
  - 해당하는 의사 명령어 처리
  - 사용 관련 DB : 원시 프로그램, Program Counter, MOT, POT, ST, LT
- Pass-2
  - 기호 번지에 대한 상대 번지를 생성
  - 목적 프로그램 생성
  - 기계 명령어 생성
  - 심볼 테이블에서 기호의 값을 찾음
  - 의사 명령어 처리
  - 리터럴 발생
  - 사용 관련 DB : 원시 프로그램의 사본, Program Counter, Pass-1에서 만든 ST, LT, MOT, POT, 베이스 레지스터 테이블, PRINT LINE, 목적 프로그램

# 매크로

- 일종의 부 프로그램 = 개방 서브루틴
- 프로그램 작성시 한 프로그램에서 동일한 코드가 반복될 경우 반복되는 코드를 한 번만 작성하여 이름을 정의하고 피료시에 정의된 이름을 호출하여 사용
- 호출된 횟수만큼 정의된 매크로 코드가 해당 위치에 삽입되어 실행
- 매크로 내에 매크로 사용 가능
- 사용자의 반복적인 코드 입력을 줄여준다.
- 프로그램 내에서 매크로 코드를 확인할 수 있음

## 부프로그램과 비교

|   구분   | 매크로                                                                                                | 부 프로그램                                                                           |
| :------: | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
|   별칭   | 개방 서트루틴                                                                                         | 폐쇄 서브루틴                                                                         |
| 처리방식 | 매크로 호출 명령이 있는 위치마다 매크로 내용을 삽입하여 확장된 프로그램을 만들어 놓고 연속적으로 실행 | 부 프로그램 호출될 때마다 제어가 부 프로그램으로 넘어갔다가 다시 주 프로그램으로 복귀 |
|   특징   | 부 프로그램은 매크로에 비해 프로그램 크기가 작아지고 기억장소가 절약되지만 실행 시간은 약간 느림      |

## 매크로 프로세서

- 원시프로그램에 존재하는 매크로 호출 부분에 매크로를 삽입하여 확장된 원시 프로그램을 생성하는 시스템 소프트웨어
- 처리과정
  - 매크로 **정의 인식**
  - 매크로 **정의 저장**
  - 매크로 **호출 인식**
  - 매크로 **확장과 매개변수 치환**

# 링커

- 연결 편집기
- 언어 번역 프로그램이 생성한 목적 프로그램과 라이브러리, 또 다른 실행 프로그램 등을 연결하여 실행 가능한 로드 모듈을 만드는 시스템 소프트웨어
- 연결 기능만 수행하는 로더의 한 형태

# 로더

- 컴퓨터 내부로 정보를 들여오거나 로드 모듈을 보조기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어

## 기능

- 할당 : Allocation 실행 프로그램을 실행시키기 위해 기억장치 내에 옮길 공간을 확보하는 기능
- 연결 : Linking 부 프로그램 호출 시 그 부 프로그램이 할당된 기억장소의 시작주소를 호출한 부분에 등록하여 연결하는 기능
- 재배치 : Relocation 기억장소의 실제 주소로 배치시키는 기능
- 적재 : Loading 실행 프로그램을 할당된 기억공간에 실제로 옮기는 기능

## 종류

### Compile And Go 로더

- 별도의 로더 없이 언어 번역 프로그램이 로더의 기능까지 수행
- 연결 기능은 수행하지 않는다.
- 할당, 재배치, 적재 작업을 모두 언어 번역 프로그램이 담당

### 절대 로더

- Absolute Loader
- 절대적으로 로딩(적재)만 하는 로더
- 목적 프로그램을 기억장소에 적지시키는 기능만 수행하는 로더
- 로더 중 가장 간단한 프로그램으로 구성
- 기억장소 할당이나 연결을 프로그래머가 직접 지정
- 한번 지정한 주기억장소의 위치는 변경이 어려움

- 절대로더의 기능별 행위 주체
  - 할당 : 프로그래머
  - 연결 : 프로그래머
  - 재배치 : 언어 번역 프로그램
  - 적재 : 로더

### 직접 연결 로더

- Direct Linking Loader = Relocation Loader = Relative Loader = 재배치로더 = 상대로더
- 일반적인 기능의 로더로 로더의 기본 네 가지 기능을 모두 수행

### 동적 적대 로더

- Dynamic Loading Loader = 호출 시 적재 로더
- 프로그램을 실행시 필요한 부분만을 적재하고 나머지는 보조기억장치에 저장
- 프로그램 크기가 주기억장치의 크기보다 큰 경우에 사용

# 프로세스

- 프로세서에 의해 처리되는 실행중인 프로그램
- 작업 = 태스크
- PCB를 가진 프로그램
- 실기억장치에 저장된 프로그램
- 프로세서가 할다오디는 실체로 디스패치가 가능한 단위
- 프로시저가 활동중인 것
- **비동기적 행위**를 일으키는 주체
- 지정된 결과를 얻기 위한 일련의 계통적 동작
- 목적 또는 결과에 따라 발생되는 사건들의 과정
- 운영체제가 관리하는 실행 단위

## PCB

- Process Control Block = 프로세스 제어 블록 = Task Control Block = Job Control Block
- 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳
- 각 프로세스가 생성될 때마다 고유의 PCB가 생성
- 프로세스가 완료되면 PCB는 제거됨
- PCB에 저장된 정보
  - 프로세스의 현재 상태
  - 포인터
    - 부모 프로세스에 대한 포인터
    - 자식 프로세스에 대한 포인터
    - 프로세스가 위치한 메모리에 대한 포인터
    - 할당된 자원에 대한 포인터
  - 프로세스 고유 식별자
  - 스케쥴링 및 프로세스의 우선순위
  - CPU 레지스터 정보 : AC, IR, PC, 범용 레지스터
  - 주기억 장치 관리 정보 : Base Register, Page Table
  - 입출력 상태 정보
  - 계정 정보 : CPU 사용시간, 실제 사용시간, 한정된 시간

## 프로세스 상태

- **제출** : Submit 사용자가 작업을 시스템에 제출한 상태
- **접수** : Hold 작업이 스풀공간인 디스크의 할당 위치에 저장된 상태
- **준비** : Ready
  - 프로세스가 프로세서를 할당 받기 위해 기다리고 있는 상태
  - 프로세스는 준비상태 큐(스케쥴링 큐)에서 실행을 준비
  - 접수 상태에서 준비상태로의 전이는 Job Scheduler에 의해 수행
- **실행** : Run
  - 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
  - 할당 시간이 종료되면 프로세스는 준비상태로 전이
  - 실행중인 프로세스에 I/O처리가 필요하면 실행중인 프로세스는 대기상태로 전이
  - 준비 상태에서 실행상태로의 전이는 CPU Scheduler에 의해 수행
- **대기, 보류, 블록**: 프로세스에 I/O처리가 필요하면 현재 실행 중인 프로세스가 중단되고 I/O처리가 완료될 때까지 대기하는 상태
- **종료** : Terminated, Exit 프로세스 실행이 끝나고 프로세스 할당이 해제된 상태
- 실행중지 : Suspend
- 하나의 프로세스가 입출력 이외의 다른 이유에 의해 실행되지 못하는 상태
- 실행중지된 프로세스는 다른 프로세스로 다시 시작하기 전에는 실행될 수 없다.
- 시스템에 이상이 있거나 부하가 많을 경우 운영체제 필요에 의해 중지
- 프로세스의 이상유무를 확인하기 위해 해당 프로세스를 완전히 종료하지 않고 중지

### 상태 용어

- Dispatch : 준비상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정
- Wake Up : 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비상태로 전이되는 과정
- Traffic Controller : 프로세스의 상태에 대한 조사와 통보 담당

## 스레드

- 프로세스의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위
- 프로세스의 일부 특성을 가지고 있지 때문에 경량 프로세스라고 한다.
- 독립적인 스케쥴링의 최소 단위
- 동일 프로세스 환경에서 서로 독립적인 다중 수행 가능
- 병행성 증진
- 처리율 향상
- 응답시간 단축
- 기억장소 낭비 줄어듦
- 프로세스 간 통신 향상
- 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신

### 사용자 수준의 스레드

- 사용자가 만든 라이브러리를 사용하여 스레드 운용
- 속도는 빠르지만 구현이 어려움

### 커널 수준의 스레드

- 운영체제 커널에 의해 스레드 운용
- 구현 쉽지만 속도가 느림

# 스케쥴링

- 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업
- 장기 스케쥴링 : 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업
- 중기 스케쥴링 : 어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 작업
- 단기 스케쥴링 : 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업
- **문맥교환** : 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것으로 새로운 프로세스에 CPU를 할당하기 위해 현재 할당된 프로세스의 상태를 저장하고 새로운 프로세스의 상태정보를 설정한 후 CPU를 할당하여 실행되도록 하는 작업

## 목적

스케쥴링은 PCU나 자원을 효율적으로 사용하기 위한 정책

- 공정성
- 처리율 증가
- CPU 이용률 증가
- 우선순위 제도 : 우선순위가 높은 프로세스 먼저 실행
- 오버헤드 최소화
- 응답시간 최소화
- 반환시간 최소화
- 대시시간 최소화
- 균형 있는 자원의 사용
- 무한 연기 회피

## 성능 평가 기준

- CPU 이용률
- 처리율
- 반환시간
- 대기시간
- 응답시간

## 비선점 스케쥴링

- Non-preemptive
- 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케쥴링 기법
- 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용
- 모든 프로세스에 대한 요구를 공정하게 처리 가능
- 응답 시간 예측이 용이
- 일괄 처리 방식에 적합
- 짧은 작업이 긴 작업을 기다리는 경우가 발생
- FCFS, SJF, 우선순위, HRN, 기한부 알고리즘

## 선점 스케쥴링

- Preemptive
- 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 빼앗아 사용할 수 있는 스케쥴링 기법
- 우선순위가 높은 프로세스를 빠르게 처리 가능
- 시분할 시스템에 사용
- 많은 오버헤드 초래
- 인터럽트용 타이머 클록이 필요
- RR, SRT, 선점우선순위, 다단계 큐, 다단계 피드백 큐 알고리즘

# 비선점 스케쥴링

## FCFS

- FIFO
- 짧은 작업이 긴 작업을 기다리는 경우가 생김
- 가장 간단한 알고리즘

## SJF

- Shortest Job First = 단기 작업 우선
- 프로세스들 중에서 실행시간이 가장 짧은 프로세스에게 먼저 CPU를 할당
- 가장 적은 평균 대기시간을 제공하는 최적 알고리즘
- 실행시간이 긴 프로세스는 실행시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태가 발생할 수 있음

## HRN

- 긴 프로세스에 불리한 SJF를 보완하기 위한 것
- 대기 시간과 서비스 실행 시간을 이용하는 기법
- 서비스 실행 시간이 짧거나 **대기 시간이 긴 프로세스일 경우** 우선순위가 높아진다.
- 우선순위 = (대기시간 + 서비스시간) / 서비스 시간

## 기한부

- Deadline
- 일정한 시간을 주고 그 시간안에 프로세스를 완료하도록 하는 기법
- 프로세스가 제한시간 안에 완료되지 않을 경우 제거되거나 처음부터 다시 실행해야함
- 프로세스 실행 시 집중적으로 요구되는 자원관리에 오버헤드가 발생

## 우선순위

- Priority
- 준비상태 큐에서 기다리는 각 프로세스마다 우선순위를 부여하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법
- 우선순위가 동일할 경우 FCFS 기법으로 CPU 할당
- 가장 낮은 순위를 부여받은 프로세스는 무한연기 또는 기아상태가 발생

## 에이징

- Aging
- 특정 프로세스의 우선순위가 낮아 무한정 기다리게 되는 경우 기다린 시간에 비례하여 일정 시간이 지나면 우선순위를 한 단계씩 높여 가까운 시간에 자원을 할당받도록하는 기법
- SJF나 우선순위 기법에서 발생하는 무한연기, 기아상태를 예방

# 선점 스케쥴링

## 선점 우선순위

- 준비상태 큐의 프로세스 중에서 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법
- 준비상태 큐에 새로 들어온 프로세스의 우선순위가 높을 경우 현재 프로세스를 보류하고 새로운 프로세스를 실행

## SRT

- Shortest Remaining Time = 선점 SJF 기법
- 비선점 스케쥴링인 SJF기법을 선점으로 변경
- 시분할 시스템에 유용
- 오버헤드 증가

## RR

- Round Robin
- 시분할 시스템을 위해 고안
- FCFS를 선점형태로 변경
- 시간할당량 동안만 실행 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치
- 할당시간이 큰 경우 FCFS와 같음
- 할당시간이 작을 경우 문맥교환 및 오버헤드가 자주 발생되 요청 작업을 신속히 처리 불가
- 할당되는 시간의 크기가 작으면 작은 프로세스에 유리
- 대기시간 : 구하고자하는 프로세스의 가장 마지막 실행이 시작되기 전까지의 진행시간을 구하고 해당 프로세스가 앞에서 실행되었을 경우 그 시간을 뺀다.

## 다단계 큐

- MQ = Multi-level Queue
- 프로세스를 특정 그룹으로 분류할 수 있을경우 그룹에 따라 각기 다른 준비상태 큐를 사용하는 기법
- 우선순위에 따라 시스템 프로세스, 대화형 프로세스, 편집 프로세스, 일괄 처리 프로세스 등으로 나누어 큐를 배치
- 각 큐는 독자적인 스케쥴링을 가지고 있어 그룹의 특성에 따라 다른 스케쥴링 기법 사용 가능
- 각 큐가 준비상태로 들어간 경우 달느 준비상태 큐로 이동할 수 없음
- 하위 단계 큐를 실행 중이라도 상위 단계 큐에 프로세스가 들어오면 상위단계에게 CPU를 할당

## 다단계 피드백 큐

- MFQ = Multi-level Feedback Queue
- 다단계 큐 기법에서 준비상태 큐 사이를 이동할 수 있게 개선
- 적응 기법(Adaptive Mechanism)의 개념을 적용
- 각 준비상태 큐마다 시간할당량을 부여해서 완료하지 못한 프로세스는 다음 단계의 준비상태 큐로 이동
- 상위 단계 큐일수록 우선순위가 높고 시간할당량이 적다.
- 요구 시간이 적은 프로세스, I/O 프로세스, 오래 기다린 프로세스를 기준으로 높은 우선순위를 할당
- 하위 단계 큐를 실행 중이라도 상위 단계 큐에 프로세스가 들어오면 상위단계에게 CPU를 할당, 마지막 단계 큐에선 작업이 완료될 때까지 RR 사용

# 병행 프로세스

두 개 이상의 프로세스들이 동시에 존재하며 실행상태에 있는 것

## 임계구역

- 다중 프로그래밍 운영체제에서 여러 개의 프로세스가 공유한 데이터 및 자원에 대해 어느 한 시점에는 하나의 프로세스만 데이터 또는 자원을 사용하도록 지정된 공유 자원영역
- 하나의 프로세스만 접근할 수 있고 해당 프로세스가 자원을 반납한 후 에만 다른 프로세스가 자원이나 데이터를 사용할 수 있다.
- 특정 프로세스가 독점할 수 없다.
- 수행 중인 프로세스는 인터럽트가 불가능하다.
- 임계 구역 내의 작업은 신속하게 이루어져야 한다.
- 프로세스가 임계 구역에 대한 진입을 요청하면 일정 시간 내에 진입을 허락해야한다.
- Critical Section
- 임계구역은 화장실에 비유해 기억하자

## 상호 배제 기법

- 특정 프로세스가 공유 자원을 사용하고 있을 경우 다른 프로세스가 해당 공유 자원을 사용하지 못하게 제어하는 기법
- 임계 구역을 유지하는 기법

- 소프트웨어적 구현
  - 두 개 프로세스 기준 : Dekker, Peterson 알고리즘
  - 여러 개의 프로세스 기준 : Lamport의 빵집 알고리즘
- 하드웨어적 구현 : Test & Set 기법, Swap 명령어 기법

## 동기화 기법

두 개 이상의 프로세스를 한 시점에서는 동시에 처리할 수 없으므로 각 프로세스에 대한 처리 순서를 결정하는 것으로 상호 배제의 한 형태

### 세마포어

- Semaphore = 신호기 = 깃발
- 각 프로세스에 제어 신호를 전달하여 순서대로 작업을 수행하도록 하는 기법
- E.J.Dijkstra가 제안
- P와 V라는 두 개의 연산에 의해서 동기화를 유지시키고 상호 배제의 원리를 보장
- S는 P와 V 연산으로만 접근 가능한 세마포어 변수로 공유 자원의 개수를 나타내며 0과 1혹은 0과 양의 값을 가질 수 있다.
- 다른 프로세스가 이미 자원을 점유한 상태라면 자원을 사용할 수 있을 때까지 기다린다.
- 순서
  - P : While S <= 0 Do skip;
  - S = S - 1;
  - V : S = S + 1;

### 모니터

- Monitor
- 동기화를 구현하기 위한 특수 프로그램 기법
- 특정 공유 자원을 프로세스에게 할당하는데 필요한 데이터와 이 데이터를 처리하는 프로시저로 구성
- 자료 추상화와 정보 은폐 개념을 기초
- 공유 자원을 할당하기 위한 병행성 구조
- 모니터 내의 공유자원을 사용하려면 프로세스는 반드시 모니터 진입부를 호출해야함
- 외부 프로시저는 직접 액세스할 수 없음
- 모니터 경계에서 상호배제가 시행
- **한 순간에 하나의 프로세스만 진입하여 자원을 사용**
- Wait와 Signal 연산 사용

# 교착상태

- Dead Lock
- 상호 배제에 의해 나타나는 문제점
- 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상

## 필요 충분 조건

교착상태가 되려면 이 조건들이 모두 충족되어야함

- **상호 배제** : Mutual Exclusion 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 한다.
- **점유와 대기** : Hold & Wait 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.
- **비선점** : Non-preemption 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
- **환형 대기** : Circular Wait 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 한다.

## 예방기법

- 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법
- 교착상태 발생의 네 가지 조건 중에서 어느 하나를 제거함으로 수행
- 자원의 낭비가 가장 심한 기법
- 상호 배제 부정 : 한 번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다, 실제로는 구현하지 않음
- 점유 대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구하도록 한다.
- 비선점 부정 : 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고 요구한 자원을 사용하기 위해 기다리게 한다.
- 환형 대기 부정 : 자원을 선형 순서로 분류하여 고유 번호를 할당하고 각 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 **어느 한 방향으로만 자원을 요구**하도록 한다.

## 회피기법

교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법

### 은행원 알고리즘

- E.J.Dijkstra가 제안한 것
- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래
- 각 프로세스에게 자원을 할당하여 교착상태가 발생하지 않음
- 모든 프로세스가 완료될 수 있는 상태를 안전 상태
- 교착상태가 발생할 수 있는 상태를 불안전 상태 (**불안전 상태라고해서 모두 교착상태는 아님**)
- 적용하기 위해선 자원의 양과 프로세스 수가 일정해야 한다.
- 프로세스의 모든 요구를 유한한 시간 안에 할당하는 것을 보장

## 발견기법

- 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것
- 교착상태 발견 알고리즘과 자원할당 그래프 등을 사용

## 회복기법

- 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것
- 프로세스 종료 : 교착상태에 있는 프로세스 종료
- 자원 선점 : 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하며 해당 프로세스를 일시 정지시키는 방법

# 기억장치 관리

상위 계층구조일 수록 접근 속도와 접근 시간이 빠르지만 기억용량이 적고 비싸다.

## 반입 전략

- Fetch
- 보조기억장치에 보관중인 프로그램이나 데이터를 **언제** 주기억장치로 적재할 것인지를 결정하는 전략
- 요구 반입 : Demand Fetch 실행 중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재
- 예상 반입 : Anticipatory Fetch 실행 중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재

## 배치 전략

- Placement
- 새로 반입되는 프로그램이나 데이터를 주기억장치의 **어디에** 위치시킬 것인지를 결정하는 전략
- 최초 적합 : First Fit 프로그램에 데이터가 들어갈 수 있는 크기의 빈 영역 중에 첫 번째 분할 영역에 배치
- 최적 적합 : Best Fit 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치
- 최악 적합 : Worst Fit 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치

## 교체 전략

- 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략
- FIFO, OPT, LRU, LFU, NUR, SCR

# 주기억장치 할당 기법

- 연속 할당 기법 : 프로그램을 주기억장치에 연속으로 할당하는 기법 (로딩)
  - 단일 분할 할당 기법 : 오버레이, 스와핑
  - 다중 분할 할당 기법 : 고정 분할 할당 기법, 동적 분할 할당 기법
- 분산 할당 기법 : 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법
  - 페이징 기법
  - 세그먼테이션 기법

## 단일 분할 할당 기법

- 주기억장치를 운영체제 영역과 사용자 영역으로 나누어 오직 한 명의 사용자만 주기억장치의 사용자 영역을 사용하는 기법
- **경계 레지스터**가 사용된다.
- 오버레이 기법을 사용하면서 주기억장치보다 큰 사용자 프로그램을 실행할 수 있게 되었다.

## 오버레이 기법

- 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법
- 보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행한다.
- 불필요한 조각이 위치한 장소에 새로운 프로그램 조각을 중첩하여 적재
- 프로그램을 여러 개의 조각으로 분할하는 작업은 프로그래머가 수행하므로 시스템 구조나 프로그램 구조를 알아야함

## 스와핑 기법

- 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법
- 하나의 사용자 프로그램이 완료될 때까지 교체 과정을 여러 번 수행할 수 있다.
- 주기억장치 => 보조기억장치 이동을 Swap Out
- 보조기억장치 => 주기억장치 이동을 Swap In

## 다중 분할 할당 기법

### 고정 분할 할당

- Multiple contiguous Fixed partTition allocation = MFT = 정적 할당 = Static Allocation
- 프로그램을 할당하기 전에 운영체제가 주기억장치 사용자 영역을 여러 개의 고정된 크기로 분할하고 준비상태 큐에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법
- 프로그램을 실행하려면 **프로그램 전체가 주기억장치에 위치**해야 한다.
- 프로그램이 분할된 영역보다 커서 영역 안에 못 들어가는 경우가 있다.
- 내부 단편화 및 외부 단편화 발생
- 다중 프로그래밍을 위해 사용되었으나 현재는 사용되지 않음

## 가변 분할 할당

- Multiple contiguous Variable parTition allocation = MVT = 동적 할당 = Dynamic Allocation
- 고정 분할 할당 기법의 단편화를 줄이기 위한 것으로 **프로그램을 주기억 장치에 적재하면서 필요한 만큼의 크기로 영역을 분할**하는 기법
- 주기억장치를 효율적으로 사용 가능
- 다중 프로그래밍의 정도를 높일 수 있음
- 실행될 프로세스 크기에 대한 제약이 적음
- 단편화를 해결할 수 있으나 영역과 영역사이에 단편화가 발생할 수 있음

# 단편화

- 분할된 주기억 장치에 프로그램을 할당하고 반납하는 과정을 반복하면서 사용되지 않고 남는 기억장치의 빈 공간 조각
- 내부 단편화 : Internal Fragmentation 분할된 영역이 할당될 프로그램 크기보다 크기 때문에 남는 공간
- 외부 단편화 : External Fragmentation 분할된 영역이 할당될 프로그램 크기보다 작아 들어갈 수 없어 남는 공간

## 해결방법

### 통합 기법

- Coalescing
- 빈 공간이 다른 빈 공간과 인접되어 있는지 점검한 후 결합하여 사용

### 압축 기법

- Compaction
- 분산되어 있는 단편화된 빈 공간을 결합하여 하나의 큰 공간을 만드는 작업
- 집약 = 가비지 컬렉션
- 분산된 단편화된 공간을 주기억 장치의 한 쪽 끝으로 옮긴 후 합침
- 압축이 실행되는 동안 시스템은 모든 일을 일시 중지
- 기억장소의 재배치
  - 압축기법을 수행시에 각 프로그램에 주어진 분할영역의 주소를 새롭게 지정해줘야한다.
  - Base Register와 Boundary Register를 사용한다.

# 가상기억장치

- 보조기억장치의 일부를 주기억장치처럼 사용하는 것
- 프로그램을 여러 개의 작은 블록으로 나눠서 가상기억장치에 보관하고 프로그램 실행시 요구되는 블록만 주기억장치에 불연속적으로 할당
- **주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용**
- 주기억장치의 이용률과 다중 프로그래밍 효율 증대
- 단편화 해결
- 가상기억장치에 저장된 프로그램 실행시 주소변환 작업 필요
- 주소변환
  - 가상기억장이체 있는 프로그램이 주기억장치에 적재되어 실행될 때 논리적인 가상주소를 실기억주소로 변환하는 것
  - 주소 사상 = 주소 매핑
  - 인위적 연속성 : Artificial Contiguity 연속적인 가상주소가 반드시 연속적인 실기억주소로 변환되지 않아도 된다.
  - 가상주소는 보조기억장치에 있는 프로그램 상의 주소 = 논리 주소
  - 실기억주소는 주기억장치에 있는 기억공간의 주소 = 실주소

## 페이징 기법

- 가상 기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법
- 페이지 : 프로그램을 일정한 크기로 나눈 단위
- 페이지 프레임 : 페이지 크기로 일정하게 나눠진 주기억장치의 단위
- **외부 단편화는 발생하지 않으나 내부 단편화는 발생**
- 주소 변환을 위해 페이지 위치정보를 가지고 있는 **페이지 맵 테이블 필요**
- 페이지 맵 테이블 사용으로 비용 증가, 처리속도 감소
- 일반적인 페이지 크기는 1~4KB
- 가상 주소는 페이지 번호와 실제 내용이 위치하고 있는 곳까지의 거리를 나타내는 변위값으로 구성
- 실기억주소는 페이지 프레임 번호와 프레임 내에서 실제 참조하는 위치까지의 거리를 나타내는 변위값으로 구성
- 페이지 맵 테이블은 주기억장치에 존재하는지의 여부를 나타내는 상태 비트와 보조기억장치 주소를 나타내는 디스크주소, 페이지가 주기억장치에 있을 때의 페이지 프레임 번호로 구성

### Page Fault

- 프로그램 실행시 참조한 페이지가 주기억장치에 없는 현상
- 처리 순서
  - 운영체제에서 트랩요청
  - 사용자 레지스트리와 프로그램 상태 저장
  - 현재 교체 가능한 페이지를 페이지 맵 테이블에서 검색
  - 가상기억장치에 있는 페이지를 주기억장치로 전달
  - 페이지 맵 테이블 갱신
  - 프로그램 상태를 불러와 이전 작업 진행

# 세그먼테이션 기법

- Segmentation
- 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
- 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 기억장치의 사용자 관점을 보존하는 기억장치 관리 기법이다.
- **기억공간을 절약하기 위해 사용**한다.
- 주소변환을 위해서 세그먼트 맵 테이블이 필요
- 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며 이를 위해 기억장치 보호키가 필요
- **내부 단편화는 발생하지 않으나 외부 단편화는 발생**
- 가상 주소는 세그먼트 번호와 세그먼트 내에 실제 내용이 위치하고 있는 곳까지의 거리를 나타내는 변위값으로 구성
- 실기억주소는 완전주소 형태이면 세그먼트 기분번지와 변위값을 더해서 구함
- 세그먼트 맵 테이블은 세그먼트 번호와 세그먼트 크기, 주기억장치 상의 기준번지로 구성

# 페이지 교체 알고리즘

- 페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법
- OPT ,FIFO, LRU, LFU, NUR, SCR

## OPT

- OPTimal replacement = 최적 교체
- 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
- Belady가 제안
- 페이지 부재가 가장 적게 발생하는 효율적인 알고리즘
- 각 페이지의 호출 순서와 참조 상황을 예측해야하므로 실현 가능성이 없음

## FIFO

- 가장 오래 있었던 페이지를 교체하는 기법
- 이해하기 쉽고 프로그램이 및 설계가 간단
- 벨레이디의 모순 현상 발생 : 페이지 프레임 수를 증가시켰는데도 페이지 부재가 더 많이 일어나는 현상

## LRU

- Least Recently Used
- 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
- 각 페이지마다 Counter나 Stack을 두어 체크한다.
- 별도의 하드웨어가 필요하며 시간적인 오버헤드가 발생한다.
- 실제로 구현하기가 매우 어렵다.

## LFU

- Least Frequently Used
- 사용 빈도가 가장 적은 페이지를 교체하는 기법
- 프로그램 실행 초기에 많이 사용된 페이지가 후에 사용되지 않을 경우에도 프레임을 계속 차지할 수 있다.

## NUR

- Not Used Recently
- LRU와 비슷한 알고리즘으로 최근에 사용하지 않은 페이지를 교체하는 기법
- 최근에 사용하지 않은 페이지는 나중에도 사용되지 않을 가능성이 높다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.
- 각 페이지마다 **참조 비트와 변형비트**가 사용된다.
  - 참조비트 : 페이지가 호출되지 않았을 때는 0, 호출되었을 때는 1
  - 변형비트 : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1
- 참조비트와 변형비트 값에 따라 교체될 페이지의 순서가 결정된다.

| 순서 | 참조비트 | 변형비트 |
| :--: | :------: | :------: |
|  1   |    0     |    0     |
|  2   |    0     |    1     |
|  3   |    1     |    0     |
|  4   |    1     |    1     |

## SCR

- Second Chance Replacement = 2차 기회 교체
- 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것
- FIFO의 단점을 보완한다.
- 각 페이지마다 참조 비트를 두고 0일경우 교체하고 1일 경우 참조 비트를 0으로 변경 후 FIFO 큐의 맨 마지막으로 이동시킨다.
- LRU처럼 참조 비트를 둔다.

# 가상기억장치 관리

## 페이지 크기

**페이지 크기가 작을 경우**

- 페이지 단편화 감소
- 효율적인 워킹 셋 유지
- Locality에 더 일치하기 때문에 기억장치 효율이 높아짐
- 맵 테이블의 크기가 커지고 매핑 속도가 늦어짐
- 디스크 접근 횟수가 많아져서 전체적인 I/O 효율성 감소

**페이지 크기가 클 경우**

- 맵 테이블 크기가 작아지고 매핑 속도가 빨라짐
- 디스크 접근 횟수가 줄어들어 I/O 효율성이 증가
- 페이지 단편화가 증가
- 불필요한 내용까지 주기억장치에 적재될 수 있음

## Locality

- 국부성 = 지역성 = 구역성 = 국소성
- 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론
- 스레싱 방지를 위한 워킹 셋 이론의 기반
- 가상기억장치 관리의 이론적인 근거
- Denning 교수에 의해 구역성의 개념이 증명
- 캐시 메모리 시스템의 이론적 근거

### 시간 구역성

- Temporal Locality
- 프로세스가 실행되면서 하나의 페이지를 일정 시간동안 집중적으로 액세스
- 한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음
- Loop, Stack, Sub Routine, Counting, 집계(Totaling)

### 공간 구역성

- Spatial Locality
- 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상
- 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음을 의미
- 배열 순회, 순차적 코드 실행, 프로그래머가 변수를 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수 참조할 때 사용

## 워킹 셋

- 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
- Denning이 제안한 프로그램의 움직임에 대한 모델로 프로그램의 Locality 특징을 이용
- 워킹 셋을 주기억장치에 상주시킴으로 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정
- 시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹셋은 시간에 따라 변경

## 페이지 부재 빈도 방식

- 페이지 부재율에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식

## 프리페이징

- 필요할 것 같은 모든 페이지를 한꺼번에 페이지 프레임에 적재하는 방식

## 스래싱

- Thrashing
- 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
- 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중 자주 페이지 부재가 발생함으로써 나타나는 현상
- 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 시점까지는 높아지지만, 더 높아질 경우 스래싱이 나타나고 CPU 이용률은 급격히 감소한다.

### 스래싱 방지

- 다중 프로그래밍의 정도를 적정 수준으로 유지
- 페이지 부재 빈도를 조절하여 사용
- 워킹 셋을 유지
- 부족한 자원을 증설하고 일부 프로세스를 중단
- CPU 성능에 대한 자료의 지속적 관리 및 분석해 임계치를 예상하고 운영

# 디스크 스케쥴링

- 사용할 데이터가 디스크 상에 여러 곳에 저장되어 있을 경우 데이터를 액세스하기 위해 디스크 헤드가 움직이는 경로를 결정하는 기법
- 탐색시간을 최적화하기 위해 수행된다.
- **처리량 최대화**
- **응답 시간 최소화**
- **응답 시간 편차의 최소화**

## FCFS

- FIFO
- 가장 간단한 스케쥴링으로 디스크 대기 큐에 먼저 들어온 순서로 실행
- 디스크 오버헤드가 적을 때 효율적
- 프로그래밍이 쉬움
- 헤드 이동거리가 상당히 길어질 수 있다.
- 디스크 오버헤드가 커지면 응답시간이 길어진다.
- 탐색 시간을 최적화하려는 시도가 없는 기법

## SSTF

- Short Seek Time First
- 탐색거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스
- 현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동
- FCFS보다 처리량이 많고 평균 탐색 시간이 짧다.
- 일괄 처리 시스템에 유용
- 먼 거리의 트랙은 무한정 기다릴 수도 있음
- 응답 시간 편차가 크기 때문에 대화형 시스템에 부적합

## SCAN

- SSTF가 갖는 탐색 시간의 편차를 해소하기 위한 기법
- Denning이 개발, 대부분의 디스크 스케쥴링에서 기본 전략으로 이용
- 현재 헤드의 위치에서 진행방향이 결정되면 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스하고, 끝까지 이동하면 역방향으로 요청 사항을 서비스
- 헤드가 이동하면서 새로운 요청이 서비스됨
- 현재 진행방향에 더 이상의 요청이 없을 때만 방향을 바꿈
- SSTF에서 발생하는 응답 시간의 편차 감소
- 오버헤드가 적을 경우 가장 효율적인 기법

## C-SCAN

- Cicular SCAN
- 항상 바깥쪽에서 안쪽으로 움직이면서 가장 짧은 탐색 거리를 갖는 요청을 서비스
- 헤드는 트랙 바깥쪽에서 안쪽으로 한 방향만 움직이며 서비스하여 끝까지 이동한 후 안쪽에 더 이상의 요청이 없으면 헤드는 가장 바깥쪽의 끝으로 이동한 후 다시 안쪽으로 이동하면서 요청을 서비스
- 처음과 마지막 트랙을 인접시킨 것과 같은 원형 형태로 디스크를 처리
- **새로운 요청이 도착하면 다음 헤드가 진행할 때 서비스**
- 트랙 안쪽과 바깥쪽 요청에 대한 서비스가 공평

## LOCK

- SCAN 기법을 기초로 사용하되 마지막 요청을 서비스한 후 그 방향의 끝으로 이동하는 것이 아니라 바로 역방향으로 진행하는 기법

## C-LOCK

- C-SCAN 기법을 기초로 사용하되 바깥쪽에서 안쪽 방향의 모든 요청을 처리한 후 가장 바깥쪽 요청 트랙으로 이동한 후 안쪽 방향으로 요청을 서비스

## N-SCAN

- N-step SCAN
- SCAN 기법의 무한 대기 발생 가능성을 제거한 것
- 어떤 방향의 진행이 시작될 시에 대기 중이던 요청들만 서비스하고 진행 도중 들어온 요청은 한데 모아서 다음 반대 방향 진행 때 서비스하는 기법
- SSTF나 SCAN보다 응답시간의 편차가 적다.
- 특정 방향에 많은 수의 요청이 도착할 경우 반대 방향에서의 무한 지연 발생을 방지
- 진행도중 도착한 요청은 반대 방향 진행시 서비스하기 위해 디스크 대기 큐에 저장

## Eschenbach

- 에션바흐는 부하가 매우 큰 항공 예약 시스템을 위해 개발
- 탐색 시간과 회전 지연 시간을 최적화하기 위한 최초의 기법
- 헤드는 C-SCAN처럼 움직이며 모든 실린더는 그 실린더에 요청이 있던 없던 전체 트랙이 한 바퀴를 회전할 동안에 서비스를 받음

## SLTF

- Shortest Latency Time First = Sector Queuing
- 회전 지연 시간의 최적화를 위해 구현된 기법
- 드럼에서 사용

# 파일

- 사용자가 작성한 서로 관련 잇는 레코드의 집합체
- 프로그램 구성의 기본 단위며 보조기억장치에 저장
- 소멸성 : 파일을 추가하거나 제거하는 작업의 빈도수
- 활성률 : 프로그램이 한번 수행되는 동안 처리되는 레코드 수의 백분율
- 크기 : 파일에 저장되어 있는 정보량

## 파일 시스템

- 파일의 저장, 액세스, 공유, 보호 등 보조기억장치에서의 파일을 총괄하는 파일 관리 기술
- 사용자와 보조기억장치 사이에서 인터페이스를 제공
- 사용자가 파일을 생성, 수정, 제거할 수 있도록 한다.
- 파일을 공동으로 사용할 수 있게 한다.
- 여러 종류의 액세스 제어방법 제공
- 사용자가 적합한 구조로 파일을 구성
- 파일의 예비와 복구 등의 기능 제공
- 사용자가 물리적 장치 이름 대신에 기호화된 이름을 사용할 수 있게 함
- 사용자가 파일을 편리하게 사용할 수 있도록 파일의 논리적 상태를 보여줘야함
- 파일을 안전하게 사용할 수 있도록하고 파일이 보호되어야함
- 파일 정보가 손실되지 않도록 데이터 무결성을 유지
- 파일 단위 작업 : Open Close Create Copy Destory Rename List
- 파일 내 레코드 단위 작업 : Read Write Update Insert Delete Search

## 파일 디스크립터

- File Descriptor = 파일 서술자 = FCB = File Control Block = 파일 제어 블록
- 시스템이 필요로하는 파일에 대한 정보를 갖고 있는 제어블록
- 파일마다 독립적으로 존재
- 시스템에 따라 다른 구조를 가짐
- 보조기억장치 내에 저장되어 있다가 해당 파일이 열릴 때 주기억장치로 옮겨짐
- 파일 시스템이 관리하므로 사용자가 참조 불가
- **파일 디스크립터의 정보**
  - 파일 이름 및 파일 크기
  - 보조기억장치에서의 파일 위치
  - 파일 구조 : 순차, 색인 순차, 색인 파일..
  - 보조기억장치의 유형
  - 액세스 제어 정보
  - 파일 유형 : 텍스트, 목적 프로그램...
  - 생성 날짜와 시간
  - 제거 날짜와 시간
  - 최종 수정 날짜와 시간
  - 액세스한 횟수

# 파일 구조

파일 접근 방법이라고도 한다.

## 순차 파일

- Sequential File = 순서 파일 = 순차 접근 방식 = SAM = Sequential Access Method
- 레코드를 논리적인 처리 순서에 따라 연속된 물리적 저장공간에 기록하는 것
- 레코드들이 순차적으로 기록되어 판독할 때도 순차적으로 접근
- 자기 테이프를 모형화한 구조
- 일괄 처리에 적합한 구조
- 레코드를 삽입하거나 삭제하는 경우 **파일 전체를 복사한 후 수행**하므로 시간이 오래 걸림
  - 파일 전체를 복사
  - 복사된 파일을 대상으로 레코드를 특정 위치에 삽입하거나 삭제
  - 모든 레코드의 위치를 순차적으로 재배치
  - 재비치된 복사파일을 원래 파일로 저장

## 직접 파일

- Direct File = 직접 접근 방식 = DAM = Direct Access Method
- 파일을 구성하는 레코드를 임의의 물리적 저장공간에 기록하는 것
- 레코드에 특정 기준으로 키가 할당
- **해싱 함수(사상함수)**를 이용하여 이 키에 대한 보조기억장치의 물리적 상대 레코드 주소를 계산한 후 해당하는 주소에 레코드를 저장
- 레코드는 해싱 함수에 의해 계산된 물리적 주소를 통해 접근
- 임의 접근이 가능한 자기 디스크나 드럼을 사용
- 접근 시간이 빠르고 레코드의 삽입, 삭제, 갱신이 용이
- 레코드의 주소 변환 과정이 필요해 시간 소요
- 기억공간의 효율 저하
- 기억장치의 물리적 구조에 대한 지식 필요
- 프로그래밍이 복잡

## 색인 순차 파일

- Indexed Sequential File = 색인 순차 접근 방식 = ISAM = Index Sequential Access Method
- 순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 형태
- 각 레코드를 키 값 순으로 논리적으로 저장하고 시스템은 각 레코드의 실제 주소가 저장된 색인을 관리
- 레코드 참조시 색인을 탐색한 후 색인이 가리키는 포인터를 사용하여 참조
- 자기디스크에서 많이 사용
- 자기테이프에서 사용 불가
- 순차처리나 임의처리가 모두 가능
- 효율적인 검색 가능하고 삽입 삭제 갱신이 용이
- 색인영역이나 오버플로 영역을 설정해야하므로 기억공간이 필요
- 색인을 이용하여 참조하기 때문에 접근 시간이 직접파일보다 느리다.

### 구성

- 기본 영역 : Prime Area 실제 레코드가 기록되는 데이터 영역
- 색인 영역 : Index Area 레코드들의 위치를 찾아가는 색인이 기록되는 영역
- 오버플로 영역 : Overflow Area 예비로 확보해 둔 영역

## 분할파일

- 하나의 파일을 여러 개로 분할하여 저장하는 형태
- 여러 개의 순차 서브파일로 구성된 파일
- 백업과 같이 하드디스크에 있는 내용을 테이프와 같은 보조기억장치에 저장할 때 사용
- 파일의 크기가 클 경우 사용

# 디렉터리 구조

## 1단계 디렉터리 구조

- 단일 디렉터리 구조
- 모든 파일이 하나의 디렉터리 내에 위치하여 관리되는 구조
- 모든 파일들이 유일한 이름을 갖고 있어야함
- 모든 파일이 같은 디렉터리 내에 유지되므로 이해가 쉬움
- 파일이나 사용자의 수가 증가하면 파일 관리가 복잡
- 파일명은 일반적으로 내용과 관련된 이름을 사용
- 파일명의 길이는 시스템에 따라 제한을 받음

## 2단계 디렉터리 구조

- 중앙에 마스터 파일 디렉터리(MFD)가 있고, 그 아래 사용자별 파일 디렉터리(UFD)가 있는 2계층 구조
- 마스터 파일 디렉터리는 각 사용자의 정보와 사용자 파일 디렉터리를 가리키는 포인터를 갖고 있으며 사용자 파일 디렉터리를 관리
- 사용자 파일 디렉터리는 오직 한 사용자가 갖고 있는 파일들에 대한 정보를 가짐
- 각 사용자는 다른 사용자의 파일 디렉터리를 검색할 수 없음
- 한 사용자 파일 디렉터리에서는 유일한 파일이름을 사용해야되나 서로 다른 사용자라면 동일한 파일이름을 사용할 수 있다.

## 트리 디렉터리 구조

- 하나의 루트 디렉터리와 여러 개의 서브 디렉터리로 구성된 구조
- DOS, UNIX, Windows의 **운영체제에서 사용되는 디렉터리 구조**
- 디렉터리 탐색은 포인터를 사용

## 비순환 그래프 디렉터리 구조

- 비주기 그래프 디렉터리 = Acyclic Graph Directory
- 하위 파일이나 하위 디렉터리를 공동으로 사용할 수 있는 것
- **사이클이 허용되지 않는 구조** = 하위 디렉터리가 상위 디렉터리나 상위 파일을 공유할 수 없다.
- 하나의 파일이나 디렉터리가 여러 개의 경로로 접근이 가능
- 디렉터리 구조가 복잡하고 시스템 성능이 저하됨
- 공유된 파일을 삭제할 경우 고아포인터(Dangling Pointer)가 발생

## 일반적인 그래프 디렉터리 구조

- 트리 구조에 링크를 첨가시켜 사이클을 허용하는 그래프 구조
- 디렉터리와 파일 공유에 완전한 융통성
- 탐색 알고리즘이 간단하여 파일과 디렉터리를 액세스하기 쉬움
- 사용되지 않은 디스크 공간을 되찾기 위해 가비지 컬렉션이 필요
- 가비지 컬렉팅을 해야되기에 참조 계수기가 필요

# 디스크 공간 할당 방법

## 연속 할당

- Contiguous Allocation
- 연속된 공간에 할당하는 방법으로 생성되는 파일의 크기만큼 공간이 있어야함
- 논리적으로 연속된 레코드가 물리적인 저장공간에도 연속적으로 저장됨
- 파일의 생성과 삭제가 반복되면 단편화 발생
- 단편화를 줄이기 위해 재배치에 의한 주기적인 압축이 필요
- 파일의 크기가 시간에 따라 변경될 경우 구현하기 어려움

## 불연속 할당

- Non-Contiguous Allocation
- 디스크 공간을 일정 단위로 나누어 할당하는 기법

### 섹터 단위 할당

- 하나의 파일이 디스크 섹터 단위로 분산되어 할당되는 방법
- 하나의 파일에 속하는 섹터들이 연결 리스트로 구성
- 디렉터리는 파일의 시작과 마지막 주소에 대한 정보만 가지고 있음
- 섹터 단위로 저장되므로 디스크 단편화가 발생되지 않음
- 파일의 크기만큼 연속된 공간이 없어도 저장 가능
- 레코드 검색시 파일이 속한 레코드를 순차적으로 검색해야 하므로 탐색시간이 오래 걸린다.
- 직접 접근이 불가능

### 블록 단위 할당

- 하나의 파일이 연속된 여러 개의 섹터를 묶은 블록 단위로 할당되는 방법

#### 블록 체인 기법

- 할당 단위를 블록으로 구성하는 방법
- 하나의 블록은 러 개의 섹터로 구성
- 디렉터리는 파일의 첫 번째 블록을 가리키는 포인터를 가지고 있음
- 하나의 블록은 데이터와 다음 블록을 가리키는 포인터로 구성
- 삽입 삭제시 포인터만 수정하면 되므로 간단
- 순차적으로 탐색해야 되므로 속도가 느림

#### 색인 블록 체인 기법

- 인덱스 블록 체인 기법
- 파일이 할당된 블록의 모든 포인터를 색인 블록에 모아 **직접 접근이 가능**
- 디렉터리는 파일의 색인 블록에 대한 포인터를 갖고 있음
- 색인 블록의 포인터를 사용하여 직접 접근이 가능해 탐색 시간이 빠름
- 삽입시 색인 블록을 재구성

#### 블록 지향 파일 사상 기법

- 포인터 대신 파일 할당 테이블(File Allocation Table)에 있는 블록번호를 사용하는 기법
- 파일 할당 테이블에는 각 블록에 해당하는 항목이 있고 각 항목은 블록번호에 의해 색인된다.
- 블록 번호에 의해 색인된 테이블의 각 항목은 다음 블록의 블록번호를 가짐
- 디스크 구조의 특성상 블록번호는 실제 기억공간의 주소로 쉽게 변환 가능
- 데이터의 삽입 삭제가 용이
- 디렉터리는 파일 할당 테이블의 시작위치를 가지고 있음

# 자원 보호

- 불법적으로 접근하는 것을 제어
- 자원의 물리적인 손상을 예방하는 기법
- 접근 제어 행렬, 전역 테이블, 접근 제어 리스트, 권한(자격) 리스트

## 접근 제어 행렬 기법

- Access Control Matrix
- 자원보호의 일반적인 모델
- 객체에 대한 접근 권한을 행렬로써 표시한 기법

## 전역 테이블 기법

- Global Table
- 가장 단순한 구현 방법
- 세 개의 순서쌍인 영역, 개체, 접근 권한의 집합을 목록 형태로 구성
- 테이블이 매우 커서 주기억장치에 저장할 수 없으므로 가상기억장치 기법을 사용해야한다.
- 주기억장치에 저장될 경우 공간 낭비

## 접근 제어 리스트

- Access Control List
- 접근 제어 행렬에 있는 각 열, 즉 객체를 중심으로 접근 리스트를 구성
- 각 객체에 대한 리스트는 영역, 접근권한의 순서쌍으로 구성되며 객체에 대한 접근 권한을 갖는 모든 영역을 정의

## 권한 리스트 기법

- Capability List = 자격 리스트
- 접근 제어 행렬에 있는 각 행, 즉 영역을 중심으로 권한 리스트를 구성
- 권한 리스트는 영역과 결합되어 있지만 그 영역에서 수행중인 프로세스가 직접 접근할 수는 없다.
- 권한 리스트는 운영체제에 의해 유지되며 사용자에 의해 간접적으로만 접근이 되는 보호된 객체이기 때문

## Lock-Key 기법

- 접근 제어 리스트와 권한 리스트를 절충한 기법
- 객체는 Lock 영역은 Key라 불리는 유일 값을 가지고 있어 영역과 객체가 일치하는 경우만 해당 객체를 접근 가능

## 파일 보호 기법

- 자원 보호 기법과 마찬가지로 파일에 대한 일방적인 접근과 손상 및 파괴를 방지하기 위함
- Naming, Password, Access Control
- 파일의 명명 : 접근하고자 하는 파일 이름을 모르는 사용자를 접근 대상에서 제외
- 비밀번호
- 접근 제어 : 공유 데이터에 접근할 수 있는 권한을 제어, 각 파일마다 접근 목록을 둔다.

# 보안

- 컴퓨터 시스템 내에 있는 프로그램과 데이터에 대해 통제된 접근 방식을 어떻게 제공할 것인가를 다루는 것
- 컴퓨터 시스템 내의 자원을 보호하고 대응하기 위한 일련의 정책과 행위
- 프로그램, 프로세스 또는 사용자의 허용된 권한 외의 접근을 제한

## 보안 요건

- 기밀성 : Confidentiality 자원은 인가된 사용자에게만 접근이 허용, 노출되어도 데이터를 읽을 수 없음
- 무결성 : Integrity 오직 인가된 사용자만 수정 가능
- 가용성 : Availability 인가받은 사용자는 언제든 사용 가능
- 인증 : Authentication
- 부인 방지 : NonRepudiation 데이터를 송수신한 자가 송수신 사실을 부인할 수 없도록 송수신 증거 제공

## 보안 유지 기법

- 외부 보안
  - 시설보안
  - 운용보안 : 사용자마다 인가된 등급 부여
- 사용자 인터페이스 보안 : 사용자의 신원 확인
- 내부 보안
  - 하드웨어나 운영체제에 내장된 보안 기능 사용
  - 하드웨어나 운영체제 내에 접근 제어 코드를 내장

## 보안 위험 감소 방법

- 사용자 감시 : User Surveillance
- 위험 탐지 : Threat Monitoring
- 확충 : Amplification
- 패스워드 보호

# 정보 보안 기법

## 비밀키 시스템

- Private Key System
- 동일한 키로 데이터를 암호화하고 복호화하는 대칭 암호화 기법
- 암/복호화의 속도가 빠르며 알고리즘이 단순
- 파일 크기가 작음
- 사용자가 많아지면 관리할 키의 수가 상대적으로 많아지고 키의 분배가 어려워짐
- DES (Data Encryption Standard)

## 공용키 시스템

- Public Key System
- 서로 다른 키로 데이터를 암호화하고, 복호화하는 비대칭 암호화 기법
- 키의 분배가 용이하고 관리해야할 키의 개수가 적음
- 암/복호화 속도가 느리며 알고리즘이 복잡
- 파일의 크기가 큼
- RSA (Rivest Shamir Adleman)

## 디지털 서명 기법

- Digital Signature Mechanism
- 고유의 전자 서명으로 송신자가 전자 문서 송신 사실을 부인할 수 없도록 함
- 작성 내용이 송수신 과정에서 변조된 사실이 없다는 것을 증명
- 공개키 암호화 기법을 사용

## 여분 정보 삽입 기법

- Traffic Padding Mechanism
- 정상 데이터에 여분의 거짓 데이터를 삽입하여 불법적으로 데이터를 분석하는 공격을 방어하는 기법
- 삽입한 거짓 데이터가 정상 데이터와 구별이 되지 않아야함

## 인증 교환 기법

- Authentication Exchange Mechanism
- 수신자가 메세지 전송 도중 변경되지 않았음을 확인할 수 있다.
- 메세지가 정당한 상대방으로부터 전달된 것을 확인할 수 있다.

## 접근 제어 기법

- Access Control Mechanism
- 데이터에 접근이 허가된 사용자에게만 데이터 사용을 허용하는 정책을 강화하기 위해 사용

## Fault Tolerant System

- 고장 방지 시스템 = 결함 허용 시스템
- 시스템 부품 고장이나 프로그램에 버그가 있더라도 시스템 전체에 장애가 발생하지 않도록 시스템을 구성하는 방법
- Dual System : 같은 장치를 두 개로 구성하여 하나가 고장나면 다른 하나를 작동시켜 작업을 처리하는 시스템

# 다중 처리기

- Multi Processor
- 하나의 시스템에 여러 개의 처리기를 두어 하나의 작업을 각 처리기에게 할당하여 수행하도록 하는 것을 의미
- 강결합 시스템
- 실행시간이 감소되고 전체 효율을 향상
- **하나의 운영체제에 의해 전체 시스템이 제어**
- 하나의 공통된 기억장소를 가짐
- 프로세서 중 하나가 고장 나도 다른 프로세서들에 의해 작업이 처리되므로 장애극복 가능
- 각 프로세서는 자체 계산능력을 가짐
- 프로세서나 주변장치 등을 공동으로 사용
- 주변장치가 기억장치에 연결되는 방식에 따라 시분할 및 공유버스, 크로스바 교환행렬, 하이퍼 큐브 방식으로 나뉨

## 시분할 및 공유 버스 연결 방식

- 각종 장치들을 버스 하나로 연결한 방식
- 장치 연결이 단순하고 경제적이며 융통성이 있음
- 장치 추가 용이
- **한 시점에 하나의 전송만 가능**
- 버스가 고장나면 시스템이 먹통
- 시스템 전체 전송량이 버스의 전송률에 의해 제한
- 장치들의 경쟁 상태가 발생하면 시스템 효율이 저하

## 크로스바 교환 행렬 연결 방식

- 시분할 및 공유 버스 방식에서 버스의 수를 기억장치의 수만큼 증가시켜 연결한 방식
- 각 기억장치마다 다른 경로를 사용 가능
- 두 개의 서로 다른 기억장치를 동시에 참조
- 장치의 연결이 복잡

## 하이퍼 큐브 연결 방식

- 다수의 프로세서들을 연결하는 방식으로 비교적 경제적
- 네 개의 프로세서를 두 개 씩 서로 이웃하게 연결한 사각형 모양의 2차원 하이퍼 큐브를 만들고, 여기에 대응점을 각각 연결하여 3차원 하이퍼 큐브를 형성하고.. 계속 늘린다.
- 다수의 프로세서를 연결할 수 있으며 확장성이 좋음
- 많은 프로세서를 연결시에 비용이 급속도로 증가
- 하나의 프로세서에 연결되는 다른 프로세서의 수가 (연결점) n개일 경우 프로세서는 총 2^n개가 필요

## 다중 포트 기억장치 연결 방식

- 시분할 및 공유 버스방식과 크로스바 교환 행렬 방식을 혼합한 형태의 방식
- 많은 수의 프로세서를 쉽게 연결 가능
- 다양한 연결이 가능하다.
- 전송 시간이 비교적 느림

# 다중 처리기의 운영체제 구조

## 주종 처리기

- Master / Slave 처리기
- 하나의 프로세서를 Master로 지정하고 나머지는 Slave로 지정하는 구조
- 주 프로세서가 고장나면 전체 시스템 먹통
- **주 프로세서만 입출력을 수행하므로 비대칭 구조**
- 주 프로세서
  - 입출력과 연산 담당
  - 운영체제 수행
- 종 프로세서
  - 연산만 담당
  - 입출력발생시 주프로세서에 요청
  - 사용자 프로그램만 담당

## 분리 실행 처리기

- 주/종처리기의 비대칭성을 보완하여 각 프로세서가 독자적인 운영체제를 가지고 있도록 구성
- 각 프로세서에서 발생하는 인터럽트는 해당 프로세서에서 해결
- 한 프로세서에 일이 밀려있어도 다른 프로세서는 유휴상태가 될 수 있다.

## 대칭적 처리기

- 분리 실행 처리기를 보완하여 여러 프로세서들이 완전한 기능을 갖춘 하나의 운영체제를 공유하여 수행하는 구조
- 가장 복잡하지만 가장 강력함
- 여러 개의 프로세서가 동시에 수행 가능
- 모든 프로세서가 동등한 권한을 가짐
- 메모리와 입출력장치를 공유
- 프로세서간의 통신은 공유 메모리를 통해 이루어짐
- 공유된 장치를 사용할 때 대립문제가 발생하므로 대비책 필요
- 프로세서의 수를 늘려도 시스템 효율은 향상되지 않음

## 약결합 시스템

- Loosely Coupled System = 분산 처리 시스템
- 각 **프로세서마다 독립된 메모리**를 가진 시스템
- 둘 이상의 독립된 컴퓨터 시스템을 통신망을 통해 연결한 시스템
- 각 **시스템마다 독자적인 운영체제**를 가짐
- 각 시스템마다 독자적인 운영이 가능하므로 프로세서간 결합력이 약함
- 프로세서 간 통신은 메세지 전달이나 원격 프로시져 호출을 통해 이뤄짐

## 강결합 시스템

- Tightly Coupled System = 다중 처리 시스템 = 병렬 처리 시스템
- 동일 운영체제 하에서 여러 개의 프로세서가 하나의 메모리를 공유하여 사용하는 시스템
- **하나의 운영체제**가 모든 프로세서와 시스템 하드웨어를 제어
- 프로세서 간의 통신은 공유 메모리를 통해 이뤄짐
- **하나의 메모리**를 사용하므로 프로세서 간의 결합력이 강함
- 공유 메모리를 차지하는 프로세서 간의 경쟁을 최소화 해야함

# 분산 처리 시스템

- Distributed Processing System
- 약결합 시스템으로 독립적인 처리능력을 가진 컴퓨터 시스템을 통신망으로 연결한 시스템
- 사용자는 각 컴퓨터 위치를 몰라도 자원을 사용 가능
- 중앙 집중형 시스템에 비해 개발이 어려움
- **보안 문제 발생**
- 시스템 유지상 통일성을 잃기 쉬움
- 시스템 설계가 복잡하고 데이터 처리 서비스의 질이 떨어짐

## 설계 목적

- 자원 공유
- 연산 속도 향상
- 신뢰도 향상 : 여러 시스템 중 하나의 시스템에 오류가 발생해도 다른 시스템에서 처리 가능
- 컴퓨터 통신 : 지리적으로 멀어도 정보 교환 가능

## 투명성

- Transparence
- 분산 처리 운영체제에서 구체적인 시스템 환경을 사용자가 알 수 없도록 함
- 환경을 알지 못해도 원하는 작업을 수행할 수 있도록 지원
- 자원의 위치나 정보가 변경되더라도 사용자가 이를 인식하지 못하게 함

### 종류

- 위치 투명성 : 물리적 위치를 몰라도 자원에 접근 가능
- 이주 투명성 : 사용자나 응용 프로그램의 동작에 영향을 받지 않고 시스템 내에 있는 자원을 이동 가능
- 복제 투명성 : 자원의 복제를 사용자에게 통지할 필요 없이 자유로이 복제
- 병행 투명성 : 자원을 병행 처리하고 공유 가능
- 접근 투명성
- 성능 투명성 : 성능을 증가시키기 위해 시스템 재구성 가능
- 규모 투명성 : 시스템 구조나 알고리즘의 변경 없이 확장 가능
- 고장 투명성 : 고장이 나도 작업 가능

## 계층구조

- 하드웨어 계층
- 기억장치 계층
- 프로세스 계층
- 파일시스템 계층
- 사용자 프로그램 계층

## 분산 파일 시스템

- 여러 사이트에 분산되어 있는 서버, 장치, 사용자들에 대한 파일 서비스를 제공하는 시스템
- 분산 시스템이 통신망으로 연결되어 있으므로 파일 서비스는 여러 개의 기억장치에서 네트워크를 통해 이뤄짐
- 서로 다른 컴퓨터 사용자 간에 정보를 쉽게 공유 가능
- NFS : 선 마이크로 시스템에서 개발
- LoCUS : 캘리포니아 대에서 개발
- Andrew : 카네기 멜론 대학에서 개발

# 분산 처리 시스템 분류

## 위상에 따른 분류

### 망형 - 완전 연결

- Full Connection
- 각 사이트들이 시스템 내의 다른 모든 사이트와 직접 연결된 구조
- 사이트 수가 n개이면 링크 수는 n(n - 1) / 2
- 모든 사이트를 연결해야 하므로 기본비용은 많이 들지만 통신비용은 적다.
- 하나의 링크가 고장나도 다른 링크를 이요하므로 신뢰성이 높다.

### 망형 - 부분 연결

- Partially Connection
- 시스템 내의 일부 사이트들 간에만 직접 연결하는 구조
- ㅈ기접 연결되지 않은 사이트는 연결된 타 사이트를 통해 통신

### 트리 또는 계층형

- Tree, Hierarchy
- 분산 처리 시스템의 가장 대표적인 형태
- 각 사이트들이 트리 형태로 연결된 구조
- 부모 사이트의 자식 사이트는 그 부모 사이트를 통해 통신이 이뤄짐
- 부모 사이트가 고장나면 자식 사이트는 통신이 불가능

### 성형

- 스타형
- 모든 사이트가 하나의 중앙 사이트에 직접 연결되어 있고 다른 사이트와는 연결되어 있지 않은 구조
- 기본 비용은 사이트 수에 비례하며 통신비용이 적다.
- 구조가 간단하고 보수 및 관리가 용이하다.
- 중앙 사이트가 고장나면 다 먹통
- 데이터 전송이 없는 사이트가 접속된 통신회선은 휴지 상태가 된다.

### 환형

- 링형
- 시스템 내의 각 사이트가 인접하는 달느 두 사이트와만 직접 연결된 구조
- 정보는 **단방향 또는 양방향으로 전달 가능**
- 특정 사이트가 고장나면 통신이 불가능해짐

### 다중 접근 버스 연결

- Multi Access Bus Connection
- 시스템 내의 모든 사이트들이 공유 버스에 연결된 구조
- 기본 비용은 사이트 수에 비례하고 통신 비용은 일반적으로 저렴

## 범위에 따른 분류

### LAN

- 근거리 통신망
- 버스형이나 링형 사용

### WAN

- 광대역 통신망
- 국가-국가간 대륙-대륙간
- 일정 지역 사이트를 근거리 통신망으로 연결 후 각 근거리 통신망을 연결하는 방식

## 프로세서 모델에 따른 분류

### 클라이언트/서버 모델

- 클라이언트와 서버가 하나의 작업을 분산 협동 처리 하는 방식
- 프로그램의 모듈성과 융통성을 증대

### 프로세서 풀 모델

- 하나 이상의 프로세서 풀과 여러 서버가 연결된 형태

### 혼합 모델

- Hybrid Model
- 클라이언트/서버 모델과 프로세서 풀 모델을 혼합한 형태의 방식
- 사용자는 워크스테이션이나 단말기를 통해 시스템에 접근

## 운영체제에 따른 분류

### 네트워크 운영체제

- 독자적인 운영체제를 가지고 있는 시스템을 네트워크로 구성한 것
- 사용자가 원격 시스템으로 로그인하거나 원격 시스템으로부터 필요한 자원을 전달 받는 방식
- 사용자는 시스템의 각 장치에 대해 알고 있어야 함
- 지역적으로 멀리 떨어진 대규모 시스템에 사용
- 설계와 구현이 쉽다.
- 자원 공유가 번거로움

### 분산 운영체제

- 하나의 운영체제가 모든 시스템 내의 자원을 관리하는 것
- 원격에 있는 자원을 마치 지역 자원인 것과 같이 쉽게 접근하여 사용하는 방식
- 사용이 편리하고 시스템 간 자원 공유가 용이
- 하나의 운영체제가 시스템 전체를 관리해야 하므로 설계와 구현이 어려움
- 요청한 컴퓨터에 요청된 컴퓨터의 자원이 이주됨으로 자원 사용 가능
- 데이터 이주
  - 데이터를 요청한 사용자의 컴퓨터로 해당 데이터의 복사본을 전송 시키는 방식
  - 사용자가 데이터가 필요하지 않을 경우 데이터의 복사본을 원래 컴퓨터로 돌려보냄
- 연산 이주
  - 요청한 데이터가 있는 컴퓨터에서 데이터를 처리하여 해당 결과를 요청한 컴퓨터에게 보내는 방식
  - 결과를 전송시키는 것
- 프로세스 이주 : 프로세스의 전체 또는 일부를 다른 컴퓨터에서 실행되도록 하는 방식

# UNIX

- 서버 컴퓨터에서 사용되는 운영체제
- 시분할 시스템을 위해 설계된 대화식 운영체제
- 소스가 공개된 개방형 시스템
- 크기가 작고 이해하기 쉬움
- 이식성이 높고 프로세스 간 호환성이 높음
- Multi User, Multi Tasking
- 트리 구조의 파일 시스템
- 하나 이상의 작업을 백그라운드에서 수행하므로 여러 작업을 동시 처리 가능

## 구성

- 하드웨어
- 커널
- 쉘
- 유틸리티
- 사용자

### 커널

- UNIX의 핵심 부분
- 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행
- 하드웨어를 보호하고 **프로그램과 하드웨어 간의 인터페이스 역할**
- 프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환

### 쉘

- 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 **명령어 해석기**
- **시스템과 사용자 간의 인터페이스 역할**
- DOS의 COMMAND.COM과 같은 기능
- **보조기억장치에 명령어가 포함된 파일로 존재**하며 교체처리가 가능
- 주기억장치에 상주하지 않는다.

### 유틸리티

- 일반 사용자가 작성한 응용 프로그램을 처리하는데 사용
- 에디터, 컴파일러, 인터프리터, 디버거
- DOS의 외부명령어

## 프로세스간 통신

- 각 프로세스는 시스템 호출을 통해 커널의 기능을 사용
- 프로세스 간 통신은 시그널, 파이프, 소켓 등을 사용
- 시그널 : 간단한 메세지를 이용하여 통신, 초기 UNIX
- 파이프 : 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신
- 소켓 : 프로세스 간의 대화를 가능하게 하는 쌍방향 통신

# UNIX 파일 시스템

## 파일 시스템

- 트리 구조
- 디렉터리나 주변장치를 파일과 동일하게 취급
- 파일 생성 및 삭제, 보호 기능을 가짐
- 일반파일, 디렉터리파일, 특수파일 형식 제공

## 파일 시스템 구조

- 디스크를 블록으로 분류하여 배치한 구조
- 부트 블록, 슈퍼블록, 아이노드 블록, 데이터 블록으로 구성
- 부트 블록 : 부팅 시 필요한 코드를 저장
- 슈퍼 블록 : 전체 파일 시스템에 대한 정보를 저장
- Index-Node 블록 : 각 파일이나 디렉터리에 대한 모든 정보를 저장하고 있는 블록
  - 파일 소유자의 사용자 번호 및 그룹 번호
  - 파일 크기
  - 파일 타입
  - 생성 시기
  - 최종 변경 시기
  - 최근 사용 시기
  - 파일 보호 권한
  - 파일 링크 수
  - 데이터가 저장된 블록의 시작 주소
- 데이터 블록 : 디렉터립려로 디렉터리 엔트리와 실제 파일에 대한 데이터가 저장된 블록

## 프로세스 관련 명령어

- fork : 프로세스 생성, 하위 프로세서 호출, 프로세스 복제
- exec : 프로세스 수행
- exit : 프로세스 종료
- wait : fort 후 exec에 의해 실행되는 프로세스의 상위 프로세스가 하위 프로세스 종료 등의 event를 기다림
- kill : 프로세스 제거
- getpid : 자신의 프로세스 아이디
- getppid : 부모 프로세스 아이디
- & : 백그라운드 처리를 위해 명령의 끝에 입력
- signal : 신호를 받았을 때 프로세스가 취할 동작 지정
- pipe : 프로세스 간 통신을 위한 경로 설정

## 파일 및 디렉터리 명령어

- creat : 파일 생성
- open : 파일을 사용할 수 있는 상태로 준비
- close : 파일 닫기
- cp : 복사
- mv : 파일 이동 또는 이름 변경
- rm : 파일 삭제
- cat : 파일 내용 표시
- chmod : 파일 사용 허가 지정
- chown : 소유자 변경
- find : 파일 찾기
- mknod : 특수 파일 생성
- mount : 파일 시스템 마운팅
- mkfs : 파일 시스템 생성
- fsck : 파일 시스템 검사
- mkdir : 디렉터리 생성
- chdir : 디렉터리 위치 변경
- rmdir : 디렉터리 삭제
- ls : 디렉터리 파일 목록 확인
- finger : 사용자 정보 표시

# Windows

- GUI
- 선점형 멀티태스킹 : 동시에 여러 개의 프로그램을 실행하는 멀티 프로그래밍을 하면서 운영체제가 각 작업의 CPU 이용시간을 제어하여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식
- FAT 32 파일 시스템 사용
- Plug and Play
- OLE 사용 : 다른 여러 프로그램에서 작성된 문자가 르미 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입하여 편집할 수 있는 기능
- 255자의 긴 파일명
- Single User 시스템

# MS-DOS

- CUI
- Single User
- Single Tasking
- 시스템 파일 : 도스의 핵심파일로 주변장치의 입출력과 시스템 전체를 통제, MSDOS.SYS와 IO.SYS가 있다.
- 명령어 처리기 : COMMAND.COM
- 자동 일괄 처리 파일 : AUTOEXEC.BAT
- 환경 설정 파일 : CONFIG.SYS

## 명령어

### 내부 명령어

- COMMAND.COM에 포함되어 있고 메모리에 항상 상주되어 있다.
- DIR : 파일 목록 표시
- COPY : 복사
- TYPE : 파일 내용 표시 (like cat)
- REN : 파일 이름 변경
- DEL : 파일 삭제
- MD : 디렉터리 생성
- CD : 디렉터리 위치 변경
- RD : 디렉터리 삭제
- CLS : 화면 내용을 지움
- VER : 버전 표시 (like uname)
- PATH : 파일 탐색 경로 지정

### 외부 명령어

- 실행과정이 복잡하거나 자주 사요하지 않는 것
- 디스크에 파일로 저장
- 처리속도가 느림
- UNDELETE : 삭제한 파일 복원
- SYS : 시스템 파일 복사
- ATTRIB : 파일 속성 변경 (like chmod)
- MOVE : 파일 이동
- FIND : 파일 찾기
- FORMAT : 포맷
- UNFORMAT : 포맷한 디스크를 복원
- CHKDSK : 디스크 상태 점검 (like df)
- DISKCOPY : 디스크 단위 복사
- DISKCOMP : 디스크 비교
