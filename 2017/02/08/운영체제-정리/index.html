<!doctype html><html lang=ko dir=ltr class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.8.1"><title data-rh=true>운영체제 정리 | gracefullight.dev</title><meta data-rh=true name=viewport content="width=device-width, initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://gracefullight.dev/2017/02/08/운영체제-정리/><meta data-rh=true property=og:locale content=ko><meta data-rh=true property=og:locale:alternate content=en><meta data-rh=true name=docusaurus_locale content=ko><meta data-rh=true name=docusaurus_tag content=default><meta data-rh=true name=docsearch:language content=ko><meta data-rh=true name=docsearch:docusaurus_tag content=default><meta data-rh=true content=gcY9SiftHgQoJjBZ7IgwNNN5_atLPAX6kWb1nFVfa6E name=google-site-verification><meta data-rh=true content=65AD1E28C0D057CEB3C68FBC0293E55B name=msvalidate.01><meta data-rh=true content=d024c2837887f72dc7b3792b958be74d69ba9593 name=naver-site-verification><meta data-rh=true content=6672f93d837354fb name=yandex-verification><meta data-rh=true content=yZEdU1ABcR name=baidu-site-verification><meta data-rh=true content=uelupjqqsm5egzlhy1aev2rfxow5yt name=facebook-domain-verification><meta data-rh=true property=og:title content="운영체제 정리 | gracefullight.dev"><meta data-rh=true name=description content="시스템 소프트웨어"><meta data-rh=true property=og:description content="시스템 소프트웨어"><meta data-rh=true property=og:type content=article><meta data-rh=true property=article:published_time content=2017-02-08T12:40:58.000Z><meta data-rh=true property=article:author content=https://github.com/gracefullight><meta data-rh=true property=article:tag content=정보처리><link data-rh=true rel=icon href=/img/favicon.ico><link data-rh=true rel=canonical href=https://gracefullight.dev/2017/02/08/운영체제-정리/><link data-rh=true rel=alternate href=https://gracefullight.dev/2017/02/08/운영체제-정리/ hreflang=ko><link data-rh=true rel=alternate href=https://gracefullight.dev/en/2017/02/08/운영체제-정리/ hreflang=en><link data-rh=true rel=alternate href=https://gracefullight.dev/2017/02/08/운영체제-정리/ hreflang=x-default><link data-rh=true rel=preconnect href=https://RFS69RSYOJ-dsn.algolia.net crossorigin=anonymous><script data-rh=true type=application/ld+json>{"@context":"https://schema.org","@id":"https://gracefullight.dev/2017/02/08/운영체제-정리","@type":"BlogPosting","author":{"@type":"Person","description":"Owner","image":"https://avatars.githubusercontent.com/u/11773683?v=4","name":"Eunkwang Shin","url":"https://github.com/gracefullight"},"datePublished":"2017-02-08T12:40:58.000Z","description":"시스템 소프트웨어","headline":"운영체제 정리","isPartOf":{"@id":"https://gracefullight.dev/","@type":"Blog","name":"Blog"},"keywords":[],"mainEntityOfPage":"https://gracefullight.dev/2017/02/08/운영체제-정리","name":"운영체제 정리","url":"https://gracefullight.dev/2017/02/08/운영체제-정리"}</script><link rel=alternate type=application/rss+xml href=/rss.xml title="gracefullight.dev RSS Feed"><link rel=alternate type=application/atom+xml href=/atom.xml title="gracefullight.dev Atom Feed"><link rel=alternate type=application/json href=/feed.json title="gracefullight.dev JSON Feed"><link rel=preconnect href=https://www.google-analytics.com><link rel=preconnect href=https://www.googletagmanager.com><script async src="https://www.googletagmanager.com/gtag/js?id=G-E99DNE7S05"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-E99DNE7S05",{})</script><link rel=search type=application/opensearchdescription+xml title=gracefullight.dev href=/opensearch.xml><link href=/img/favicon-32x32.png rel=icon><link href=/manifest.json rel=manifest><meta content=#f28913 name=theme-color><meta content=yes name=apple-mobile-web-app-capable><meta content=#f28913 name=apple-mobile-web-app-status-bar-style><link href=/img/apple-touch-icon.png rel=apple-touch-icon><link rel=preconnect href=https://pagead2.googlesyndication.com><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3004788392777865" async crossorigin=anonymous></script><link rel=preconnect href=https://www.clarity.ms><script>!function(t,e,n,a,c,i,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(i=e.createElement(a)).async=1,i.src="https://www.clarity.ms/tag/"+c,(r=e.getElementsByTagName(a)[0]).parentNode.insertBefore(i,r)}(window,document,"clarity","script","aongv9xgi6")</script><link rel=preconnect href=https://wcs.naver.net><script src=https://wcs.naver.net/wcslog.js async></script><script>if(!wcs_add)var wcs_add={};wcs_add.wa="156bc73a81e3bd0",window.wcs&&wcs_do()</script><link rel=preconnect href=https://cdn.channel.io><script>!function(){var n=window;if(n.ChannelIO)return(window.console.error||window.console.log||function(){})("ChannelIO script included twice.");var e=function(){e.c(arguments)};function t(){if(!n.ChannelIOInitialized){n.ChannelIOInitialized=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://cdn.channel.io/plugin/ch-plugin-web.js",e.charset="UTF-8";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}}e.q=[],e.c=function(n){e.q.push(n)},n.ChannelIO=e,"complete"===document.readyState?t():window.attachEvent?window.attachEvent("onload",t):(window.addEventListener("DOMContentLoaded",t,!1),window.addEventListener("load",t,!1))}(),ChannelIO("boot",{pluginKey:"0fd130ba-a1a6-4b7e-802a-e82a885a7fd8"})</script><link rel=preconnect href=https://static.cloudflareinsights.com><script src=https://static.cloudflareinsights.com/beacon.min.js defer data-cf-beacon='{"token":"c0899829e72b45e98dff77241127252c"}'></script><link href=https://cdn.jsdelivr.net rel=preconnect><script type=application/ld+json>{"@context":"http://schema.org","@type":"Person","email":"mailto:gracefullight.dev@gmail.com","image":"https://avatars.githubusercontent.com/u/11773683?v=4","jobTitle":"FullStack JavaScript Developer","logo":"https://gracefullight.dev/img/apple-touch-icon.png","name":"Eunkwang Shin","nationality":"Korean","sameAs":["https://github.com/gracefullight","https://linkedin.com/in/gracefullight"],"url":"https://gracefullight.dev"}</script><link rel=stylesheet crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css type=text/css><link rel=stylesheet href=/assets/css/styles.5dca47c9.css><script src=/assets/js/runtime~main.3560cb30.js defer></script><script src=/assets/js/main.1295a4fe.js defer></script><body class=navigation-with-keyboard><svg xmlns=http://www.w3.org/2000/svg style="display: none;"><defs>
<symbol id=theme-svg-external-link viewBox="0 0 24 24"><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light",e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><link rel=preload as=image href=/img/favicon-32x32.png><link rel=preload as=image href="https://avatars.githubusercontent.com/u/11773683?v=4"><div role=region aria-label="본문으로 건너뛰기"><a class=skipToContent_n8wj href=#__docusaurus_skipToContent_fallback>본문으로 건너뛰기</a></div><nav aria-label=Main class="theme-layout-navbar navbar navbar--fixed-top"><div class=navbar__inner><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/><div class=navbar__logo><img src=/img/favicon-32x32.png alt="gracefullight.dev blog logo" class="themedComponent_HPxh themedComponent--light__08w"><img src=/img/favicon-32x32.png alt="gracefullight.dev blog logo" class="themedComponent_HPxh themedComponent--dark_ZtVK"></div><b class="navbar__title text--truncate">gracefullight.dev</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href=# aria-haspopup=true aria-expanded=false role=button class=navbar__link><svg viewBox="0 0 24 24" width=20 height=20 aria-hidden=true class=iconLanguage_YARx><path fill=currentColor d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/></svg>한국어</a><ul class=dropdown__menu><li><a href=/2017/02/08/운영체제-정리/ target=_self rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang=ko>한국어</a><li><a href=/en/2017/02/08/운영체제-정리/ target=_self rel="noopener noreferrer" class=dropdown__link lang=en>English</a></ul></div><a class="navbar__item navbar__link" href=/archive/>Archives</a><a class="navbar__item navbar__link" href=/tags/>Tags</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href=https://github.com/gracefullight target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_u4jp colorModeToggle_j7hn"><button class="clean-btn toggleButton_kJUB toggleButtonDisabled_F1D9" type=button disabled title="system mode" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 system mode)"><svg viewBox="0 0 24 24" width=24 height=24 aria-hidden=true class="toggleIcon_Eqj9 lightToggleIcon_R7co"><path fill=currentColor d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/></svg><svg viewBox="0 0 24 24" width=24 height=24 aria-hidden=true class="toggleIcon_Eqj9 darkToggleIcon_nqlJ"><path fill=currentColor d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/></svg><svg viewBox="0 0 24 24" width=24 height=24 aria-hidden=true class="toggleIcon_Eqj9 systemToggleIcon_jTW_"><path fill=currentColor d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"/></svg></button></div><div class=navbarSearchContainer_zg67><button type=button class="DocSearch DocSearch-Button" aria-label="검색 (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>검색</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="theme-layout-main main-wrapper mainWrapper_I8f8"><div class="container margin-vert--lg"><div class=row><aside class="col col--3"><nav class="sidebar_IJu6 thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_xlej margin-bottom--md">최근 포스트</div><div role=group><h3 class=yearGroupHeading_v6R1>2025</h3><ul class="sidebarItemList_pWcJ clean-list"><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/2025/07/02/study-in-australia-marriage/>호주 결혼 준비</a><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/2025/06/28/study-in-australia-insurance-pension-health/>호주 학생 보험 및 한국 건강보험, 국민연금 연기</a><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/2025/06/24/computer-generated-imagery/>CGI와 그래픽</a><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/2025/06/23/syntax-analysis/>구문 분석</a><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/2025/06/22/study-in-australia-visa-conditions/>호주 학생 비자 주의사항</a><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/2025/04/25/ielts-speaking-tests-flaws/>IELTS Speaking 기출 오답노트 2025</a><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/pe/conv/model-context-protocol/>MCP, Model Context Protocol</a><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/pe/conv/test-time-compute/>테스트 타임 컴퓨트</a><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/pe/nw/internal-gateway-protocol/>내부 게이트웨이 프로토콜</a><li class=sidebarItem_hcV1><a class=sidebarItemLink_bP8a href=/pe/sec/이동형-영상정보처리기기를-위한-개인영상정보-보호-활용-안내서/>이동형 영상정보처리기기를 위한 개인영상정보 보호 활용 안내서</a></ul></div></nav></aside><main class="col col--7"><article class=""><header><h1 class=title_h3tV>운영체제 정리</h1><div class="container_adKE margin-vert--md"><time datetime=2017-02-08T12:40:58.000Z>2017년 2월 8일</time> · <!-- -->약 43분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_UpJz"><div class="avatar margin-bottom--sm"><a class=avatar__photo-link href=/authors/me/><img class="avatar__photo authorImage_PgbM" src="https://avatars.githubusercontent.com/u/11773683?v=4" alt="Eunkwang Shin"></a><div class="avatar__intro authorDetails_b4iq"><div class=avatar__name><a href=/authors/me/><span class=authorName_S0GU>Eunkwang Shin</span></a></div><small class=authorTitle_yXj7 title=Owner>Owner</small><div class=authorSocials_PQyK><a href=https://www.linkedin.com/in/gracefullight/ target=_blank rel="noopener noreferrer" class=authorSocialLink__pKK title=LinkedIn><svg xmlns=http://www.w3.org/2000/svg width=1em height=1em preserveAspectRatio=xMidYMid viewBox="0 0 256 256" class=authorSocialLink__pKK><path d="M218.123 218.127h-37.931v-59.403c0-14.165-.253-32.4-19.728-32.4-19.756 0-22.779 15.434-22.779 31.369v60.43h-37.93V95.967h36.413v16.694h.51a39.907 39.907 0 0 1 35.928-19.733c38.445 0 45.533 25.288 45.533 58.186l-.016 67.013ZM56.955 79.27c-12.157.002-22.014-9.852-22.016-22.009-.002-12.157 9.851-22.014 22.008-22.016 12.157-.003 22.014 9.851 22.016 22.008A22.013 22.013 0 0 1 56.955 79.27m18.966 138.858H37.95V95.967h37.97v122.16ZM237.033.018H18.89C8.58-.098.125 8.161-.001 18.471v219.053c.122 10.315 8.576 18.582 18.89 18.474h218.144c10.336.128 18.823-8.139 18.966-18.474V18.454c-.147-10.33-8.635-18.588-18.966-18.453" fill=#0A66C2 /></svg></a><a href=https://github.com/gracefullight target=_blank rel="noopener noreferrer" class=authorSocialLink__pKK title=GitHub><svg xmlns=http://www.w3.org/2000/svg width=1em height=1em viewBox="0 0 256 250" preserveAspectRatio=xMidYMid style=--dark:#000;--light:#fff class="authorSocialLink__pKK githubSvg_rQyt"><path d="M128.001 0C57.317 0 0 57.307 0 128.001c0 56.554 36.676 104.535 87.535 121.46 6.397 1.185 8.746-2.777 8.746-6.158 0-3.052-.12-13.135-.174-23.83-35.61 7.742-43.124-15.103-43.124-15.103-5.823-14.795-14.213-18.73-14.213-18.73-11.613-7.944.876-7.78.876-7.78 12.853.902 19.621 13.19 19.621 13.19 11.417 19.568 29.945 13.911 37.249 10.64 1.149-8.272 4.466-13.92 8.127-17.116-28.431-3.236-58.318-14.212-58.318-63.258 0-13.975 5-25.394 13.188-34.358-1.329-3.224-5.71-16.242 1.24-33.874 0 0 10.749-3.44 35.21 13.121 10.21-2.836 21.16-4.258 32.038-4.307 10.878.049 21.837 1.47 32.066 4.307 24.431-16.56 35.165-13.12 35.165-13.12 6.967 17.63 2.584 30.65 1.255 33.873 8.207 8.964 13.173 20.383 13.173 34.358 0 49.163-29.944 59.988-58.447 63.157 4.591 3.972 8.682 11.762 8.682 23.704 0 17.126-.148 30.91-.148 35.126 0 3.407 2.304 7.398 8.792 6.14C219.37 232.5 256 184.537 256 128.002 256 57.307 198.691 0 128.001 0Zm-80.06 182.34c-.282.636-1.283.827-2.194.39-.929-.417-1.45-1.284-1.15-1.922.276-.655 1.279-.838 2.205-.399.93.418 1.46 1.293 1.139 1.931Zm6.296 5.618c-.61.566-1.804.303-2.614-.591-.837-.892-.994-2.086-.375-2.66.63-.566 1.787-.301 2.626.591.838.903 1 2.088.363 2.66Zm4.32 7.188c-.785.545-2.067.034-2.86-1.104-.784-1.138-.784-2.503.017-3.05.795-.547 2.058-.055 2.861 1.075.782 1.157.782 2.522-.019 3.08Zm7.304 8.325c-.701.774-2.196.566-3.29-.49-1.119-1.032-1.43-2.496-.726-3.27.71-.776 2.213-.558 3.315.49 1.11 1.03 1.45 2.505.701 3.27Zm9.442 2.81c-.31 1.003-1.75 1.459-3.199 1.033-1.448-.439-2.395-1.613-2.103-2.626.301-1.01 1.747-1.484 3.207-1.028 1.446.436 2.396 1.602 2.095 2.622Zm10.744 1.193c.036 1.055-1.193 1.93-2.715 1.95-1.53.034-2.769-.82-2.786-1.86 0-1.065 1.202-1.932 2.733-1.958 1.522-.03 2.768.818 2.768 1.868Zm10.555-.405c.182 1.03-.875 2.088-2.387 2.37-1.485.271-2.861-.365-3.05-1.386-.184-1.056.893-2.114 2.376-2.387 1.514-.263 2.868.356 3.061 1.403Z"/></svg></a></div></div></div></div></div></header><div id=__blog-post-container class=markdown><h2 class="anchor anchorWithStickyNavbar_B5Wd" id=시스템-소프트웨어>시스템 소프트웨어<a href=#시스템-소프트웨어 class=hash-link aria-label="시스템 소프트웨어에 대한 직접 링크" title="시스템 소프트웨어에 대한 직접 링크">​</a></h2>
<ul>
<li>시스템 전체를 작동시키는 프로그램</li>
<li>프로그램을 주기억 장치에 적재시키거나 인터럽트 관리, 장치 관리, 언어번역 등의 기능 담당</li>
<li>대표적으로 운영체제가 있음</li>
<li>번역프로그램, 매크로 프로세서, 링커, 라이브러리, 정렬/합병프로그램, 로더 등</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=구성>구성<a href=#구성 class=hash-link aria-label="구성에 대한 직접 링크" title="구성에 대한 직접 링크">​</a></h3>
<ul>
<li>제어프로그램</li>
<li>감시프로그램</li>
<li>작업 제어 프로그램 : Jbo Scheduler, Master Scheduler</li>
<li>자료 관리 프로그램</li>
<li>처리프로그램</li>
<li>언어 번역기 : 어셈블러, 컴파일러, 인터프리터</li>
<li>서비스 프로그램 : 연결 편집기, 정렬/합병 프로그램, 라이브러리안, 유틸리티</li>
<li>문제 프로그램</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=제어-프로그램>제어 프로그램<a href=#제어-프로그램 class=hash-link aria-label="제어 프로그램에 대한 직접 링크" title="제어 프로그램에 대한 직접 링크">​</a></h3>
<ul>
<li>Control Program</li>
<li>시스템 전체의 작동 상태 감시, 작업의 순서 지정, 작업에 사용되는 데이터의 관리 등의 역할 수행</li>
<li><strong>깜짝데이트</strong>(감시, 작업, 데이터)</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=감시-프로그램>감시 프로그램<a href=#감시-프로그램 class=hash-link aria-label="감시 프로그램에 대한 직접 링크" title="감시 프로그램에 대한 직접 링크">​</a></h4>
<ul>
<li>Supervisor Program</li>
<li>제어 프로그램 중 가장 중요함</li>
<li>각종 프로그램 실행과 시스템 전체의 작동 상태를 감시 감독</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=작업-제어-프로그램>작업 제어 프로그램<a href=#작업-제어-프로그램 class=hash-link aria-label="작업 제어 프로그램에 대한 직접 링크" title="작업 제어 프로그램에 대한 직접 링크">​</a></h4>
<ul>
<li>Job Control Program</li>
<li>다른 업무의 이행을 자동으로 수행하기 위해 준비</li>
<li>처리에 대한 완료를 담당하는 프로그램</li>
<li>작업의 연속 처리를 위한 스케쥴 및 시스템 자원 할당</li>
<li>Job Scheduler : 다음 작업을 준비시키는 역할</li>
<li>Master Scheduler : 시스템과 운영자 사이에서 정보를 주고 받을 수 있도록 중개자 역할 (CMD)</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=자료-관리-프로그램>자료 관리 프로그램<a href=#자료-관리-프로그램 class=hash-link aria-label="자료 관리 프로그램에 대한 직접 링크" title="자료 관리 프로그램에 대한 직접 링크">​</a></h4>
<ul>
<li>Data Management Program</li>
<li>주기억장치와 보조기억장치 사이의 데이터 전송과 보조기억장치의 자료 갱신 및 유지보수 기능을 수행</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=처리-프로그램>처리 프로그램<a href=#처리-프로그램 class=hash-link aria-label="처리 프로그램에 대한 직접 링크" title="처리 프로그램에 대한 직접 링크">​</a></h3>
<ul>
<li>Processing Program</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=언어-번역-프로그램>언어 번역 프로그램<a href=#언어-번역-프로그램 class=hash-link aria-label="언어 번역 프로그램에 대한 직접 링크" title="언어 번역 프로그램에 대한 직접 링크">​</a></h4>
<ul>
<li>원시 프로그램을 기계어 형태의 목적 프로그램으로 번역하는 프로그램</li>
<li>어셈블러, 컴파일러, 인터프리터</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=서비스-프로그램>서비스 프로그램<a href=#서비스-프로그램 class=hash-link aria-label="서비스 프로그램에 대한 직접 링크" title="서비스 프로그램에 대한 직접 링크">​</a></h4>
<ul>
<li>연결 편집기 : 프로그램을 연결하여 실행 가능한 프로그램을 만드는 프로그램 (링커)</li>
<li>정렬/합병 프로그램 : 데이터를 일정한 기준으로 정렬하거나 정렬된 파일을 합치는 프로그램</li>
<li>라이브러리안 : 프로그램의 라이브러리를 유지 관리</li>
<li>유틸리티 프로그램 : 사용자의 편의를 도모하기 위한 프로그램 (텍스트에디터, 디버거)</li>
<li>문제 프로그램 : 특정 업무 및 문제 해결을 위해 사용자가 작성</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=운영체제>운영체제<a href=#운영체제 class=hash-link aria-label="운영체제에 대한 직접 링크" title="운영체제에 대한 직접 링크">​</a></h2>
<ul>
<li>컴퓨터 시스템의 자원들을 효율적으로 관리</li>
<li>사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 프로그램의 집합</li>
<li>유틸리티와 하드웨어 사이의 인터페이스 제공</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=목적>목적<a href=#목적 class=hash-link aria-label="목적에 대한 직접 링크" title="목적에 대한 직접 링크">​</a></h3>
<ul>
<li>처리능력 : Throughput 일정 시간 내에 시스템이 처리하는 양</li>
<li>반환시간 : Turn Around Time 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간</li>
<li>사용가능도 : Availability 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도</li>
<li>신뢰도 : Reliability 시스템이 주어진 문제를 정확하게 해결하는 정도</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=기능>기능<a href=#기능 class=hash-link aria-label="기능에 대한 직접 링크" title="기능에 대한 직접 링크">​</a></h3>
<ul>
<li>프로세서, 기억장치, 입출력장치, 파일 및 자원 관리</li>
<li>자원 스케쥴링</li>
<li>사용자와 시스템 간의 인터페이스 제공</li>
<li>하드웨어와 네트워크 관리 제어</li>
<li>데이터 관리하고 데이터 및 자원 공유 기능 제공</li>
<li>시스템 오류 검사 및 복구</li>
<li>자원 보호 기능 제공</li>
<li>입 출력에 대한 보조 기능을 제공</li>
<li>가상 계산기 기능을 제공</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=자원관리>자원관리<a href=#자원관리 class=hash-link aria-label="자원관리에 대한 직접 링크" title="자원관리에 대한 직접 링크">​</a></h3>
<ul>
<li>프로세스 관리 : 프레세스 스케쥴링, 동기화, 생성 제거, 시작 정지, 메시지 전달</li>
<li>기억장치 관리 : 프로세스 메모리 할당 및 회수</li>
<li>주변장치 관리 : 입출력 장치 스케쥴링 및 관리</li>
<li>파일 관리</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=종류>종류<a href=#종류 class=hash-link aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크">​</a></h3>
<ul>
<li>단일 작업 처리 시스템</li>
<li>Single Tasking System</li>
<li>시스템을 한 개의 작업이 독점하여 사용하는 방식</li>
<li>DOS</li>
<li>다중 작업 처리 시스템</li>
<li>Multi Tasking System</li>
<li>여러 개의 프로그램을 열어 두고 다양한 작업을 동시에 진행하는 방식</li>
<li>Windows</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=운영체제-운용-기법>운영체제 운용 기법<a href=#운영체제-운용-기법 class=hash-link aria-label="운영체제 운용 기법에 대한 직접 링크" title="운영체제 운용 기법에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=일괄-처리-시스템>일괄 처리 시스템<a href=#일괄-처리-시스템 class=hash-link aria-label="일괄 처리 시스템에 대한 직접 링크" title="일괄 처리 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>초기의 컴퓨터 시스템</li>
<li>일정량 또는 일정 기간 동안 데이터를 모아서 한꺼번에 처리하는 방식</li>
<li>일괄 처리를 위해 작업제어언어(JCL)을 제공</li>
<li>시스템 효율적 사용 가능</li>
<li>반환 시간이 늦지만 하나의 작업이 모든 자원을 독점하므로 CPU Idle Time이 줄어듦</li>
<li>급여 계산, 지불 계산, 연말 결산 등</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=다중-프로그래밍-시스템>다중 프로그래밍 시스템<a href=#다중-프로그래밍-시스템 class=hash-link aria-label="다중 프로그래밍 시스템에 대한 직접 링크" title="다중 프로그래밍 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>하나의 CPU와 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식</li>
<li>CPU 사용률과 처리량이 증가</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=시분할-시스템>시분할 시스템<a href=#시분할-시스템 class=hash-link aria-label="시분할 시스템에 대한 직접 링크" title="시분할 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>Time Sharing System = Round Robin</li>
<li>여러 명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리</li>
<li>여러 사용자가 각자의 컴퓨터로 동시에 운영체제와 대화하면서 프로그램 실행</li>
<li>하나의 CPU는 같은 시점에서 여러 개의 작업을 동시 수행이 안되기 때문에 CPU를 같은 작업 시간량으로 나눠서 그 시간량 동안 번갈아가면서 CPU를 사용</li>
<li>작업시간량 : Time Slice = Quantum</li>
<li>다중 프로그래밍 방식과 결합하여 모든 작업이 동시에 진행되는 것처럼 대화식 처리 가능</li>
<li>시스템 전체 효율은 좋으나 사용자는 반응 속도가 느려질 수 있음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=다중-처리-시스템>다중 처리 시스템<a href=#다중-처리-시스템 class=hash-link aria-label="다중 처리 시스템에 대한 직접 링크" title="다중 처리 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>여러 개의 CPU와 하나의 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리하는 방식</li>
<li>여러 CPU는 하나의 메모리를 공유하며 단일 운영체제에 의해 관리</li>
<li>프로그램의 처리 속도는 빠르지만 기억장치, 입출력장치 등의 자원 공유에 대한 문제점을 해결해야함</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=실시간-처리-시스템>실시간 처리 시스템<a href=#실시간-처리-시스템 class=hash-link aria-label="실시간 처리 시스템에 대한 직접 링크" title="실시간 처리 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>데이터 발생 즉시 처리하여 결과를 산출</li>
<li>처리시간이 단축되고 처리비용이 절감</li>
<li>우주선, 교통제어, 레이더, 핵실험, 데이터수집, 전화교환장치, 인터넷뱅킹 등 시간에 제한을 두고 수행되어야하는 작업</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=다중-모드-처리>다중 모드 처리<a href=#다중-모드-처리 class=hash-link aria-label="다중 모드 처리에 대한 직접 링크" title="다중 모드 처리에 대한 직접 링크">​</a></h3>
<ul>
<li>일괄처리, 시분할, 다중처리, 실시간처리를 한 시스템에서 모두 제공하는 방식</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=분산-처리-시스템>분산 처리 시스템<a href=#분산-처리-시스템 class=hash-link aria-label="분산 처리 시스템에 대한 직접 링크" title="분산 처리 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>Distributed Processing System</li>
<li>여러 개의 컴퓨터를 통신 회선으로 연결하여 하나의 작업을 처리하는 방식</li>
<li>각 단말은 고유의 운영체제와 CPU, 메모리를 가진다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=발달과정>발달과정<a href=#발달과정 class=hash-link aria-label="발달과정에 대한 직접 링크" title="발달과정에 대한 직접 링크">​</a></h3>
<ul>
<li>1세데 : 일괄처리</li>
<li>2세대 : 다중프로그래밍, 다중처리, 시분할, 실시간</li>
<li>3세대 : 다중모드</li>
<li>4세대 : 분산처리</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=컴파일러와-인터프리터>컴파일러와 인터프리터<a href=#컴파일러와-인터프리터 class=hash-link aria-label="컴파일러와 인터프리터에 대한 직접 링크" title="컴파일러와 인터프리터에 대한 직접 링크">​</a></h2>
<p>고급언어로 작성된 원시프로그램을 목적프로그램으로 번역하는 번역프로그램</p>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=저급-언어>저급 언어<a href=#저급-언어 class=hash-link aria-label="저급 언어에 대한 직접 링크" title="저급 언어에 대한 직접 링크">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=기계어>기계어<a href=#기계어 class=hash-link aria-label="기계어에 대한 직접 링크" title="기계어에 대한 직접 링크">​</a></h4>
<ul>
<li>컴퓨터가 직접 이해할 수 있는 언어</li>
<li>기종마다 기계어가 다르므로 언어의 호환성이 없음</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=어셈블리어>어셈블리어<a href=#어셈블리어 class=hash-link aria-label="어셈블리어에 대한 직접 링크" title="어셈블리어에 대한 직접 링크">​</a></h4>
<ul>
<li>기계어와 1:1 대응되는 기호로 이루어진 언어</li>
<li>니모닉 언어 = Mnemonic = 상징어</li>
<li>하드웨어 제어에 주로 사용</li>
<li>언어의 호환성이 없음</li>
<li>어셈블러를 사용하여 기계어로 번역해야 됨</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=고급-언어>고급 언어<a href=#고급-언어 class=hash-link aria-label="고급 언어에 대한 직접 링크" title="고급 언어에 대한 직접 링크">​</a></h3>
<ul>
<li>컴파일러 언어</li>
<li>자연어와 비슷한 형태 및 구조</li>
<li>하드웨어 지식이 없어도 작성 가능</li>
<li>기계어로 번역하기 위해 컴파일러나 인터프리터가 사용</li>
<li>C, BASIC, COBOL, ALGOL 등</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=컴파일러>컴파일러<a href=#컴파일러 class=hash-link aria-label="컴파일러에 대한 직접 링크" title="컴파일러에 대한 직접 링크">​</a></h3>
<ul>
<li>고급언어로 작성된 프로그램 전체를 목적 프로그램으로 번역한 후 링킹 작업을 통해 실행 프로그램을 생헝</li>
<li>번역과 실행과정을 거쳐야하기 때문에 번역 과정이 번거로움</li>
<li>번역 시간이 오래걸림</li>
<li>한번 번역 후에는 다시 번역하지 않아 실행속도는 빠름</li>
<li>C, C++, FORTRAN, COBOL, PL/1</li>
<li>대부분의 언어는 컴파일러로 변환된다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=인터프리터>인터프리터<a href=#인터프리터 class=hash-link aria-label="인터프리터에 대한 직접 링크" title="인터프리터에 대한 직접 링크">​</a></h3>
<ul>
<li>고급 언어로 작성된 프로그램을 한 줄 단위로 받아들여 번역</li>
<li>번역과 동시에 프로그램을 한 줄 단위로 즉시 실행</li>
<li>프로그램이 직접 실행되므로 <strong>목적프로그램이 생성되지 않음</strong></li>
<li>시분할 시스템에 유용</li>
<li>원시 프로그램에 변화에 대한 반응이 빠름</li>
<li>번역 속도는 빠르지만 실행속도는 느림</li>
<li>BASIC, SNOBOL, LISP, APL</li>
<li>CPU의 시간낭비가 크다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=어셈블리어-1>어셈블리어<a href=#어셈블리어-1 class=hash-link aria-label="어셈블리어에 대한 직접 링크" title="어셈블리어에 대한 직접 링크">​</a></h2>
<ul>
<li>사용자가 이해하기 어려운 기계어 대신에 명령 기능을 쉽게 연상할 수 있는 기호를 기계어와 1:1 대응시켜 코드화한 기호 언어</li>
<li>어셈블리어로 작성한 원이프로그램은 어셈블러를 통해 목적 프로그램으로 어셈블하는 과정을 거쳐야한다.</li>
<li>사용자가 프로그램을 쉽게 읽고 이해할 수 있다.</li>
<li>프로그램에 기호화된 명령 및 주소를 사용한다.</li>
<li>CPU마다 사용되는 어셈블리어가 다르다.</li>
<li>의사명령과 실행명령으로 구분</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=형식>형식<a href=#형식 class=hash-link aria-label="형식에 대한 직접 링크" title="형식에 대한 직접 링크">​</a></h3>
<p>Label, OP, Operand</p>
<ul>
<li>Label : 데이터를 기억할 장소 또는 분기할 위치, 기호 상수에 대한 Symbol을 기술하는 부분으로 생략할 수 있다.</li>
<li>OP : OPCode를 기술하는 부분</li>
<li>Operand : OPCode가 연산을 수행하기 위한 대상인 상수, 데이터나 주소, 레지스터 번호를 기술하는 부분</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=어셈블러>어셈블러<a href=#어셈블러 class=hash-link aria-label="어셈블러에 대한 직접 링크" title="어셈블러에 대한 직접 링크">​</a></h3>
<ul>
<li>어셈블리어로 작성된 걸 기계어로 번역하는 프로그램</li>
<li>이중 패스 어셈블러르 사용하면 정의되지 않은 기호를 사용할 수 있다.</li>
<li>현재 대부분 이중 패스 어셈블러를 사용한다.</li>
<li><strong>두 개의 패스를 사용하면 기호를 정의하기 전에 사용할 수 있는 프로그램 작업이 용이</strong>하다.</li>
<li>단일 패스 어셈블러 : 원시 프로그램을 하나의 명령문씩 읽는 즉시 기계어로 번역하여 목적 프로그램을 만듦</li>
<li>이중 패스 어셈블러 : 원시 프로그램을 끝까지 읽어서 1단계 작업을 수행한 후 다시 처음부터 읽어나가면서 1단계에서 수행한 결과를 이용해 완전한 목적프로그램을 만듦</li>
<li>크로스 어셈블러 : 현재 사용하는 컴퓨터와 다른 명령 형태로 동작하는 컴퓨터에서 사용할 프로그램을 어셈블 할 때 사용하므로 실행시킬 컴퓨터에 맞게 목적 프로그램을 생성</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=구성-1>구성<a href=#구성-1 class=hash-link aria-label="구성에 대한 직접 링크" title="구성에 대한 직접 링크">​</a></h4>
<ul>
<li>기계 명령어 테이블<!-- -->
<ul>
<li>Machin Operation Table = MOT</li>
<li>어셈블리어의 실행 명령에 대응하는 기계어에 대한 정보를 가지고 있는 테이블</li>
<li>어셈블러에 기본적으로 포함</li>
</ul>
</li>
<li>의사 명령어 테이블<!-- -->
<ul>
<li>Pseudo Operation Table = POT</li>
<li>의사 명령과 그 명령을 처리하는 실행 루틴의 주소를 가지고 있는 테이블</li>
<li>어셈블러에 기본적으로 포함</li>
</ul>
</li>
<li>기호 테이블<!-- -->
<ul>
<li>Symbol Table = ST</li>
<li>원시 프로그램의 Label 부분에 있는 기호들을 모두 차례대로 저장하는 테이블</li>
</ul>
</li>
<li>리터럴 테이블<!-- -->
<ul>
<li>Literal Table = LT</li>
<li>원시 프로그램의 Operand 부분에 있는 리터럴을 차례로 저장하는 테이블</li>
</ul>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=pass-1-pass-2>Pass-1 Pass-2<a href=#pass-1-pass-2 class=hash-link aria-label="Pass-1 Pass-2에 대한 직접 링크" title="Pass-1 Pass-2에 대한 직접 링크">​</a></h4>
<ul>
<li>Pass-1<!-- -->
<ul>
<li>기호와 리터럴을 정의</li>
<li>기계 명령어의 길이 정의</li>
<li>위치 계수기(PC, LC) 관리</li>
<li>기호들의 값을 심볼 테이블에 기억</li>
<li>사용된 리터럴을 리터럴 테이블에 기억</li>
<li>해당하는 의사 명령어 처리</li>
<li>사용 관련 DB : 원시 프로그램, Program Counter, MOT, POT, ST, LT</li>
</ul>
</li>
<li>Pass-2<!-- -->
<ul>
<li>기호 번지에 대한 상대 번지를 생성</li>
<li>목적 프로그램 생성</li>
<li>기계 명령어 생성</li>
<li>심볼 테이블에서 기호의 값을 찾음</li>
<li>의사 명령어 처리</li>
<li>리터럴 발생</li>
<li>사용 관련 DB : 원시 프로그램의 사본, Program Counter, Pass-1에서 만든 ST, LT, MOT, POT, 베이스 레지스터 테이블, PRINT LINE, 목적 프로그램</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=매크로>매크로<a href=#매크로 class=hash-link aria-label="매크로에 대한 직접 링크" title="매크로에 대한 직접 링크">​</a></h2>
<ul>
<li>일종의 부 프로그램 = 개방 서브루틴</li>
<li>프로그램 작성시 한 프로그램에서 동일한 코드가 반복될 경우 반복되는 코드를 한 번만 작성하여 이름을 정의하고 피료시에 정의된 이름을 호출하여 사용</li>
<li>호출된 횟수만큼 정의된 매크로 코드가 해당 위치에 삽입되어 실행</li>
<li>매크로 내에 매크로 사용 가능</li>
<li>사용자의 반복적인 코드 입력을 줄여준다.</li>
<li>프로그램 내에서 매크로 코드를 확인할 수 있음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=부프로그램과-비교>부프로그램과 비교<a href=#부프로그램과-비교 class=hash-link aria-label="부프로그램과 비교에 대한 직접 링크" title="부프로그램과 비교에 대한 직접 링크">​</a></h3>
<table><thead><tr><th style=text-align:center>구분<th>매크로<th>부 프로그램<tbody><tr><td style=text-align:center>별칭<td>개방 서트루틴<td>폐쇄 서브루틴<tr><td style=text-align:center>처리방식<td>매크로 호출 명령이 있는 위치마다 매크로 내용을 삽입하여 확장된 프로그램을 만들어 놓고 연속적으로 실행<td>부 프로그램 호출될 때마다 제어가 부 프로그램으로 넘어갔다가 다시 주 프로그램으로 복귀<tr><td style=text-align:center>특징<td>부 프로그램은 매크로에 비해 프로그램 크기가 작아지고 기억장소가 절약되지만 실행 시간은 약간 느림<td></table>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=매크로-프로세서>매크로 프로세서<a href=#매크로-프로세서 class=hash-link aria-label="매크로 프로세서에 대한 직접 링크" title="매크로 프로세서에 대한 직접 링크">​</a></h3>
<ul>
<li>원시프로그램에 존재하는 매크로 호출 부분에 매크로를 삽입하여 확장된 원시 프로그램을 생성하는 시스템 소프트웨어</li>
<li>처리과정<!-- -->
<ul>
<li>매크로 <strong>정의 인식</strong></li>
<li>매크로 <strong>정의 저장</strong></li>
<li>매크로 <strong>호출 인식</strong></li>
<li>매크로 <strong>확장과 매개변수 치환</strong></li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=링커>링커<a href=#링커 class=hash-link aria-label="링커에 대한 직접 링크" title="링커에 대한 직접 링크">​</a></h2>
<ul>
<li>연결 편집기</li>
<li>언어 번역 프로그램이 생성한 목적 프로그램과 라이브러리, 또 다른 실행 프로그램 등을 연결하여 실행 가능한 로드 모듈을 만드는 시스템 소프트웨어</li>
<li>연결 기능만 수행하는 로더의 한 형태</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=로더>로더<a href=#로더 class=hash-link aria-label="로더에 대한 직접 링크" title="로더에 대한 직접 링크">​</a></h2>
<ul>
<li>컴퓨터 내부로 정보를 들여오거나 로드 모듈을 보조기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=기능-1>기능<a href=#기능-1 class=hash-link aria-label="기능에 대한 직접 링크" title="기능에 대한 직접 링크">​</a></h3>
<ul>
<li>할당 : Allocation 실행 프로그램을 실행시키기 위해 기억장치 내에 옮길 공간을 확보하는 기능</li>
<li>연결 : Linking 부 프로그램 호출 시 그 부 프로그램이 할당된 기억장소의 시작주소를 호출한 부분에 등록하여 연결하는 기능</li>
<li>재배치 : Relocation 기억장소의 실제 주소로 배치시키는 기능</li>
<li>적재 : Loading 실행 프로그램을 할당된 기억공간에 실제로 옮기는 기능</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=종류-1>종류<a href=#종류-1 class=hash-link aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=compile-and-go-로더>Compile And Go 로더<a href=#compile-and-go-로더 class=hash-link aria-label="Compile And Go 로더에 대한 직접 링크" title="Compile And Go 로더에 대한 직접 링크">​</a></h4>
<ul>
<li>별도의 로더 없이 언어 번역 프로그램이 로더의 기능까지 수행</li>
<li>연결 기능은 수행하지 않는다.</li>
<li>할당, 재배치, 적재 작업을 모두 언어 번역 프로그램이 담당</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=절대-로더>절대 로더<a href=#절대-로더 class=hash-link aria-label="절대 로더에 대한 직접 링크" title="절대 로더에 대한 직접 링크">​</a></h4>
<ul>
<li>
<p>Absolute Loader</p>
</li>
<li>
<p>절대적으로 로딩(적재)만 하는 로더</p>
</li>
<li>
<p>목적 프로그램을 기억장소에 적지시키는 기능만 수행하는 로더</p>
</li>
<li>
<p>로더 중 가장 간단한 프로그램으로 구성</p>
</li>
<li>
<p>기억장소 할당이나 연결을 프로그래머가 직접 지정</p>
</li>
<li>
<p>한번 지정한 주기억장소의 위치는 변경이 어려움</p>
</li>
<li>
<p>절대로더의 기능별 행위 주체</p>
<ul>
<li>할당 : 프로그래머</li>
<li>연결 : 프로그래머</li>
<li>재배치 : 언어 번역 프로그램</li>
<li>적재 : 로더</li>
</ul>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=직접-연결-로더>직접 연결 로더<a href=#직접-연결-로더 class=hash-link aria-label="직접 연결 로더에 대한 직접 링크" title="직접 연결 로더에 대한 직접 링크">​</a></h4>
<ul>
<li>Direct Linking Loader = Relocation Loader = Relative Loader = 재배치로더 = 상대로더</li>
<li>일반적인 기능의 로더로 로더의 기본 네 가지 기능을 모두 수행</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=동적-적대-로더>동적 적대 로더<a href=#동적-적대-로더 class=hash-link aria-label="동적 적대 로더에 대한 직접 링크" title="동적 적대 로더에 대한 직접 링크">​</a></h4>
<ul>
<li>Dynamic Loading Loader = 호출 시 적재 로더</li>
<li>프로그램을 실행시 필요한 부분만을 적재하고 나머지는 보조기억장치에 저장</li>
<li>프로그램 크기가 주기억장치의 크기보다 큰 경우에 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=프로세스>프로세스<a href=#프로세스 class=hash-link aria-label="프로세스에 대한 직접 링크" title="프로세스에 대한 직접 링크">​</a></h2>
<ul>
<li>프로세서에 의해 처리되는 실행중인 프로그램</li>
<li>작업 = 태스크</li>
<li>PCB를 가진 프로그램</li>
<li>실기억장치에 저장된 프로그램</li>
<li>프로세서가 할다오디는 실체로 디스패치가 가능한 단위</li>
<li>프로시저가 활동중인 것</li>
<li><strong>비동기적 행위</strong>를 일으키는 주체</li>
<li>지정된 결과를 얻기 위한 일련의 계통적 동작</li>
<li>목적 또는 결과에 따라 발생되는 사건들의 과정</li>
<li>운영체제가 관리하는 실행 단위</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=pcb>PCB<a href=#pcb class=hash-link aria-label="PCB에 대한 직접 링크" title="PCB에 대한 직접 링크">​</a></h3>
<ul>
<li>Process Control Block = 프로세스 제어 블록 = Task Control Block = Job Control Block</li>
<li>운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳</li>
<li>각 프로세스가 생성될 때마다 고유의 PCB가 생성</li>
<li>프로세스가 완료되면 PCB는 제거됨</li>
<li>PCB에 저장된 정보<!-- -->
<ul>
<li>프로세스의 현재 상태</li>
<li>포인터<!-- -->
<ul>
<li>부모 프로세스에 대한 포인터</li>
<li>자식 프로세스에 대한 포인터</li>
<li>프로세스가 위치한 메모리에 대한 포인터</li>
<li>할당된 자원에 대한 포인터</li>
</ul>
</li>
<li>프로세스 고유 식별자</li>
<li>스케쥴링 및 프로세스의 우선순위</li>
<li>CPU 레지스터 정보 : AC, IR, PC, 범용 레지스터</li>
<li>주기억 장치 관리 정보 : Base Register, Page Table</li>
<li>입출력 상태 정보</li>
<li>계정 정보 : CPU 사용시간, 실제 사용시간, 한정된 시간</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=프로세스-상태>프로세스 상태<a href=#프로세스-상태 class=hash-link aria-label="프로세스 상태에 대한 직접 링크" title="프로세스 상태에 대한 직접 링크">​</a></h3>
<ul>
<li><strong>제출</strong> : Submit 사용자가 작업을 시스템에 제출한 상태</li>
<li><strong>접수</strong> : Hold 작업이 스풀공간인 디스크의 할당 위치에 저장된 상태</li>
<li><strong>준비</strong> : Ready<!-- -->
<ul>
<li>프로세스가 프로세서를 할당 받기 위해 기다리고 있는 상태</li>
<li>프로세스는 준비상태 큐(스케쥴링 큐)에서 실행을 준비</li>
<li>접수 상태에서 준비상태로의 전이는 Job Scheduler에 의해 수행</li>
</ul>
</li>
<li><strong>실행</strong> : Run<!-- -->
<ul>
<li>준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태</li>
<li>할당 시간이 종료되면 프로세스는 준비상태로 전이</li>
<li>실행중인 프로세스에 I/O처리가 필요하면 실행중인 프로세스는 대기상태로 전이</li>
<li>준비 상태에서 실행상태로의 전이는 CPU Scheduler에 의해 수행</li>
</ul>
</li>
<li><strong>대기, 보류, 블록</strong>: 프로세스에 I/O처리가 필요하면 현재 실행 중인 프로세스가 중단되고 I/O처리가 완료될 때까지 대기하는 상태</li>
<li><strong>종료</strong> : Terminated, Exit 프로세스 실행이 끝나고 프로세스 할당이 해제된 상태</li>
<li>실행중지 : Suspend</li>
<li>하나의 프로세스가 입출력 이외의 다른 이유에 의해 실행되지 못하는 상태</li>
<li>실행중지된 프로세스는 다른 프로세스로 다시 시작하기 전에는 실행될 수 없다.</li>
<li>시스템에 이상이 있거나 부하가 많을 경우 운영체제 필요에 의해 중지</li>
<li>프로세스의 이상유무를 확인하기 위해 해당 프로세스를 완전히 종료하지 않고 중지</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=상태-용어>상태 용어<a href=#상태-용어 class=hash-link aria-label="상태 용어에 대한 직접 링크" title="상태 용어에 대한 직접 링크">​</a></h4>
<ul>
<li>Dispatch : 준비상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정</li>
<li>Wake Up : 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비상태로 전이되는 과정</li>
<li>Traffic Controller : 프로세스의 상태에 대한 조사와 통보 담당</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=스레드>스레드<a href=#스레드 class=hash-link aria-label="스레드에 대한 직접 링크" title="스레드에 대한 직접 링크">​</a></h3>
<ul>
<li>프로세스의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위</li>
<li>프로세스의 일부 특성을 가지고 있지 때문에 경량 프로세스라고 한다.</li>
<li>독립적인 스케쥴링의 최소 단위</li>
<li>동일 프로세스 환경에서 서로 독립적인 다중 수행 가능</li>
<li>병행성 증진</li>
<li>처리율 향상</li>
<li>응답시간 단축</li>
<li>기억장소 낭비 줄어듦</li>
<li>프로세스 간 통신 향상</li>
<li>공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=사용자-수준의-스레드>사용자 수준의 스레드<a href=#사용자-수준의-스레드 class=hash-link aria-label="사용자 수준의 스레드에 대한 직접 링크" title="사용자 수준의 스레드에 대한 직접 링크">​</a></h4>
<ul>
<li>사용자가 만든 라이브러리를 사용하여 스레드 운용</li>
<li>속도는 빠르지만 구현이 어려움</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=커널-수준의-스레드>커널 수준의 스레드<a href=#커널-수준의-스레드 class=hash-link aria-label="커널 수준의 스레드에 대한 직접 링크" title="커널 수준의 스레드에 대한 직접 링크">​</a></h4>
<ul>
<li>운영체제 커널에 의해 스레드 운용</li>
<li>구현 쉽지만 속도가 느림</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=스케쥴링>스케쥴링<a href=#스케쥴링 class=hash-link aria-label="스케쥴링에 대한 직접 링크" title="스케쥴링에 대한 직접 링크">​</a></h2>
<ul>
<li>프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업</li>
<li>장기 스케쥴링 : 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업</li>
<li>중기 스케쥴링 : 어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 작업</li>
<li>단기 스케쥴링 : 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업</li>
<li><strong>문맥교환</strong> : 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것으로 새로운 프로세스에 CPU를 할당하기 위해 현재 할당된 프로세스의 상태를 저장하고 새로운 프로세스의 상태정보를 설정한 후 CPU를 할당하여 실행되도록 하는 작업</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=목적-1>목적<a href=#목적-1 class=hash-link aria-label="목적에 대한 직접 링크" title="목적에 대한 직접 링크">​</a></h3>
<p>스케쥴링은 PCU나 자원을 효율적으로 사용하기 위한 정책</p>
<ul>
<li>공정성</li>
<li>처리율 증가</li>
<li>CPU 이용률 증가</li>
<li>우선순위 제도 : 우선순위가 높은 프로세스 먼저 실행</li>
<li>오버헤드 최소화</li>
<li>응답시간 최소화</li>
<li>반환시간 최소화</li>
<li>대시시간 최소화</li>
<li>균형 있는 자원의 사용</li>
<li>무한 연기 회피</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=성능-평가-기준>성능 평가 기준<a href=#성능-평가-기준 class=hash-link aria-label="성능 평가 기준에 대한 직접 링크" title="성능 평가 기준에 대한 직접 링크">​</a></h3>
<ul>
<li>CPU 이용률</li>
<li>처리율</li>
<li>반환시간</li>
<li>대기시간</li>
<li>응답시간</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=비선점-스케쥴링>비선점 스케쥴링<a href=#비선점-스케쥴링 class=hash-link aria-label="비선점 스케쥴링에 대한 직접 링크" title="비선점 스케쥴링에 대한 직접 링크">​</a></h3>
<ul>
<li>Non-preemptive</li>
<li>이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케쥴링 기법</li>
<li>프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용</li>
<li>모든 프로세스에 대한 요구를 공정하게 처리 가능</li>
<li>응답 시간 예측이 용이</li>
<li>일괄 처리 방식에 적합</li>
<li>짧은 작업이 긴 작업을 기다리는 경우가 발생</li>
<li>FCFS, SJF, 우선순위, HRN, 기한부 알고리즘</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=선점-스케쥴링>선점 스케쥴링<a href=#선점-스케쥴링 class=hash-link aria-label="선점 스케쥴링에 대한 직접 링크" title="선점 스케쥴링에 대한 직접 링크">​</a></h3>
<ul>
<li>Preemptive</li>
<li>하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 빼앗아 사용할 수 있는 스케쥴링 기법</li>
<li>우선순위가 높은 프로세스를 빠르게 처리 가능</li>
<li>시분할 시스템에 사용</li>
<li>많은 오버헤드 초래</li>
<li>인터럽트용 타이머 클록이 필요</li>
<li>RR, SRT, 선점우선순위, 다단계 큐, 다단계 피드백 큐 알고리즘</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=비선점-스케쥴링-1>비선점 스케쥴링<a href=#비선점-스케쥴링-1 class=hash-link aria-label="비선점 스케쥴링에 대한 직접 링크" title="비선점 스케쥴링에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=fcfs>FCFS<a href=#fcfs class=hash-link aria-label="FCFS에 대한 직접 링크" title="FCFS에 대한 직접 링크">​</a></h3>
<ul>
<li>FIFO</li>
<li>짧은 작업이 긴 작업을 기다리는 경우가 생김</li>
<li>가장 간단한 알고리즘</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=sjf>SJF<a href=#sjf class=hash-link aria-label="SJF에 대한 직접 링크" title="SJF에 대한 직접 링크">​</a></h3>
<ul>
<li>Shortest Job First = 단기 작업 우선</li>
<li>프로세스들 중에서 실행시간이 가장 짧은 프로세스에게 먼저 CPU를 할당</li>
<li>가장 적은 평균 대기시간을 제공하는 최적 알고리즘</li>
<li>실행시간이 긴 프로세스는 실행시간이 짧은 프로세스에게 할당 순위가 밀려 무한 연기 상태가 발생할 수 있음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=hrn>HRN<a href=#hrn class=hash-link aria-label="HRN에 대한 직접 링크" title="HRN에 대한 직접 링크">​</a></h3>
<ul>
<li>긴 프로세스에 불리한 SJF를 보완하기 위한 것</li>
<li>대기 시간과 서비스 실행 시간을 이용하는 기법</li>
<li>서비스 실행 시간이 짧거나 <strong>대기 시간이 긴 프로세스일 경우</strong> 우선순위가 높아진다.</li>
<li>우선순위 = (대기시간 + 서비스시간) / 서비스 시간</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=기한부>기한부<a href=#기한부 class=hash-link aria-label="기한부에 대한 직접 링크" title="기한부에 대한 직접 링크">​</a></h3>
<ul>
<li>Deadline</li>
<li>일정한 시간을 주고 그 시간안에 프로세스를 완료하도록 하는 기법</li>
<li>프로세스가 제한시간 안에 완료되지 않을 경우 제거되거나 처음부터 다시 실행해야함</li>
<li>프로세스 실행 시 집중적으로 요구되는 자원관리에 오버헤드가 발생</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=우선순위>우선순위<a href=#우선순위 class=hash-link aria-label="우선순위에 대한 직접 링크" title="우선순위에 대한 직접 링크">​</a></h3>
<ul>
<li>Priority</li>
<li>준비상태 큐에서 기다리는 각 프로세스마다 우선순위를 부여하여 그 중 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법</li>
<li>우선순위가 동일할 경우 FCFS 기법으로 CPU 할당</li>
<li>가장 낮은 순위를 부여받은 프로세스는 무한연기 또는 기아상태가 발생</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=에이징>에이징<a href=#에이징 class=hash-link aria-label="에이징에 대한 직접 링크" title="에이징에 대한 직접 링크">​</a></h3>
<ul>
<li>Aging</li>
<li>특정 프로세스의 우선순위가 낮아 무한정 기다리게 되는 경우 기다린 시간에 비례하여 일정 시간이 지나면 우선순위를 한 단계씩 높여 가까운 시간에 자원을 할당받도록하는 기법</li>
<li>SJF나 우선순위 기법에서 발생하는 무한연기, 기아상태를 예방</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=선점-스케쥴링-1>선점 스케쥴링<a href=#선점-스케쥴링-1 class=hash-link aria-label="선점 스케쥴링에 대한 직접 링크" title="선점 스케쥴링에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=선점-우선순위>선점 우선순위<a href=#선점-우선순위 class=hash-link aria-label="선점 우선순위에 대한 직접 링크" title="선점 우선순위에 대한 직접 링크">​</a></h3>
<ul>
<li>준비상태 큐의 프로세스 중에서 우선순위가 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법</li>
<li>준비상태 큐에 새로 들어온 프로세스의 우선순위가 높을 경우 현재 프로세스를 보류하고 새로운 프로세스를 실행</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=srt>SRT<a href=#srt class=hash-link aria-label="SRT에 대한 직접 링크" title="SRT에 대한 직접 링크">​</a></h3>
<ul>
<li>Shortest Remaining Time = 선점 SJF 기법</li>
<li>비선점 스케쥴링인 SJF기법을 선점으로 변경</li>
<li>시분할 시스템에 유용</li>
<li>오버헤드 증가</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=rr>RR<a href=#rr class=hash-link aria-label="RR에 대한 직접 링크" title="RR에 대한 직접 링크">​</a></h3>
<ul>
<li>Round Robin</li>
<li>시분할 시스템을 위해 고안</li>
<li>FCFS를 선점형태로 변경</li>
<li>시간할당량 동안만 실행 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주고 준비상태 큐의 가장 뒤로 배치</li>
<li>할당시간이 큰 경우 FCFS와 같음</li>
<li>할당시간이 작을 경우 문맥교환 및 오버헤드가 자주 발생되 요청 작업을 신속히 처리 불가</li>
<li>할당되는 시간의 크기가 작으면 작은 프로세스에 유리</li>
<li>대기시간 : 구하고자하는 프로세스의 가장 마지막 실행이 시작되기 전까지의 진행시간을 구하고 해당 프로세스가 앞에서 실행되었을 경우 그 시간을 뺀다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=다단계-큐>다단계 큐<a href=#다단계-큐 class=hash-link aria-label="다단계 큐에 대한 직접 링크" title="다단계 큐에 대한 직접 링크">​</a></h3>
<ul>
<li>MQ = Multi-level Queue</li>
<li>프로세스를 특정 그룹으로 분류할 수 있을경우 그룹에 따라 각기 다른 준비상태 큐를 사용하는 기법</li>
<li>우선순위에 따라 시스템 프로세스, 대화형 프로세스, 편집 프로세스, 일괄 처리 프로세스 등으로 나누어 큐를 배치</li>
<li>각 큐는 독자적인 스케쥴링을 가지고 있어 그룹의 특성에 따라 다른 스케쥴링 기법 사용 가능</li>
<li>각 큐가 준비상태로 들어간 경우 달느 준비상태 큐로 이동할 수 없음</li>
<li>하위 단계 큐를 실행 중이라도 상위 단계 큐에 프로세스가 들어오면 상위단계에게 CPU를 할당</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=다단계-피드백-큐>다단계 피드백 큐<a href=#다단계-피드백-큐 class=hash-link aria-label="다단계 피드백 큐에 대한 직접 링크" title="다단계 피드백 큐에 대한 직접 링크">​</a></h3>
<ul>
<li>MFQ = Multi-level Feedback Queue</li>
<li>다단계 큐 기법에서 준비상태 큐 사이를 이동할 수 있게 개선</li>
<li>적응 기법(Adaptive Mechanism)의 개념을 적용</li>
<li>각 준비상태 큐마다 시간할당량을 부여해서 완료하지 못한 프로세스는 다음 단계의 준비상태 큐로 이동</li>
<li>상위 단계 큐일수록 우선순위가 높고 시간할당량이 적다.</li>
<li>요구 시간이 적은 프로세스, I/O 프로세스, 오래 기다린 프로세스를 기준으로 높은 우선순위를 할당</li>
<li>하위 단계 큐를 실행 중이라도 상위 단계 큐에 프로세스가 들어오면 상위단계에게 CPU를 할당, 마지막 단계 큐에선 작업이 완료될 때까지 RR 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=병행-프로세스>병행 프로세스<a href=#병행-프로세스 class=hash-link aria-label="병행 프로세스에 대한 직접 링크" title="병행 프로세스에 대한 직접 링크">​</a></h2>
<p>두 개 이상의 프로세스들이 동시에 존재하며 실행상태에 있는 것</p>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=임계구역>임계구역<a href=#임계구역 class=hash-link aria-label="임계구역에 대한 직접 링크" title="임계구역에 대한 직접 링크">​</a></h3>
<ul>
<li>다중 프로그래밍 운영체제에서 여러 개의 프로세스가 공유한 데이터 및 자원에 대해 어느 한 시점에는 하나의 프로세스만 데이터 또는 자원을 사용하도록 지정된 공유 자원영역</li>
<li>하나의 프로세스만 접근할 수 있고 해당 프로세스가 자원을 반납한 후 에만 다른 프로세스가 자원이나 데이터를 사용할 수 있다.</li>
<li>특정 프로세스가 독점할 수 없다.</li>
<li>수행 중인 프로세스는 인터럽트가 불가능하다.</li>
<li>임계 구역 내의 작업은 신속하게 이루어져야 한다.</li>
<li>프로세스가 임계 구역에 대한 진입을 요청하면 일정 시간 내에 진입을 허락해야한다.</li>
<li>Critical Section</li>
<li>임계구역은 화장실에 비유해 기억하자</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=상호-배제-기법>상호 배제 기법<a href=#상호-배제-기법 class=hash-link aria-label="상호 배제 기법에 대한 직접 링크" title="상호 배제 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>
<p>특정 프로세스가 공유 자원을 사용하고 있을 경우 다른 프로세스가 해당 공유 자원을 사용하지 못하게 제어하는 기법</p>
</li>
<li>
<p>임계 구역을 유지하는 기법</p>
</li>
<li>
<p>소프트웨어적 구현</p>
<ul>
<li>두 개 프로세스 기준 : Dekker, Peterson 알고리즘</li>
<li>여러 개의 프로세스 기준 : Lamport의 빵집 알고리즘</li>
</ul>
</li>
<li>
<p>하드웨어적 구현 : Test & Set 기법, Swap 명령어 기법</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=동기화-기법>동기화 기법<a href=#동기화-기법 class=hash-link aria-label="동기화 기법에 대한 직접 링크" title="동기화 기법에 대한 직접 링크">​</a></h3>
<p>두 개 이상의 프로세스를 한 시점에서는 동시에 처리할 수 없으므로 각 프로세스에 대한 처리 순서를 결정하는 것으로 상호 배제의 한 형태</p>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=세마포어>세마포어<a href=#세마포어 class=hash-link aria-label="세마포어에 대한 직접 링크" title="세마포어에 대한 직접 링크">​</a></h4>
<ul>
<li>Semaphore = 신호기 = 깃발</li>
<li>각 프로세스에 제어 신호를 전달하여 순서대로 작업을 수행하도록 하는 기법</li>
<li>E.J.Dijkstra가 제안</li>
<li>P와 V라는 두 개의 연산에 의해서 동기화를 유지시키고 상호 배제의 원리를 보장</li>
<li>S는 P와 V 연산으로만 접근 가능한 세마포어 변수로 공유 자원의 개수를 나타내며 0과 1혹은 0과 양의 값을 가질 수 있다.</li>
<li>다른 프로세스가 이미 자원을 점유한 상태라면 자원을 사용할 수 있을 때까지 기다린다.</li>
<li>순서<!-- -->
<ul>
<li>P : <code>While S &lt;= 0 Do skip</code>;</li>
<li>S = S - 1;</li>
<li>V : S = S + 1;</li>
</ul>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=모니터>모니터<a href=#모니터 class=hash-link aria-label="모니터에 대한 직접 링크" title="모니터에 대한 직접 링크">​</a></h4>
<ul>
<li>Monitor</li>
<li>동기화를 구현하기 위한 특수 프로그램 기법</li>
<li>특정 공유 자원을 프로세스에게 할당하는데 필요한 데이터와 이 데이터를 처리하는 프로시저로 구성</li>
<li>자료 추상화와 정보 은폐 개념을 기초</li>
<li>공유 자원을 할당하기 위한 병행성 구조</li>
<li>모니터 내의 공유자원을 사용하려면 프로세스는 반드시 모니터 진입부를 호출해야함</li>
<li>외부 프로시저는 직접 액세스할 수 없음</li>
<li>모니터 경계에서 상호배제가 시행</li>
<li><strong>한 순간에 하나의 프로세스만 진입하여 자원을 사용</strong></li>
<li>Wait와 Signal 연산 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=교착상태>교착상태<a href=#교착상태 class=hash-link aria-label="교착상태에 대한 직접 링크" title="교착상태에 대한 직접 링크">​</a></h2>
<ul>
<li>Dead Lock</li>
<li>상호 배제에 의해 나타나는 문제점</li>
<li>둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=필요-충분-조건>필요 충분 조건<a href=#필요-충분-조건 class=hash-link aria-label="필요 충분 조건에 대한 직접 링크" title="필요 충분 조건에 대한 직접 링크">​</a></h3>
<p>교착상태가 되려면 이 조건들이 모두 충족되어야함</p>
<ul>
<li><strong>상호 배제</strong> : Mutual Exclusion 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 한다.</li>
<li><strong>점유와 대기</strong> : Hold & Wait 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.</li>
<li><strong>비선점</strong> : Non-preemption 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.</li>
<li><strong>환형 대기</strong> : Circular Wait 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 한다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=예방기법>예방기법<a href=#예방기법 class=hash-link aria-label="예방기법에 대한 직접 링크" title="예방기법에 대한 직접 링크">​</a></h3>
<ul>
<li>교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법</li>
<li>교착상태 발생의 네 가지 조건 중에서 어느 하나를 제거함으로 수행</li>
<li>자원의 낭비가 가장 심한 기법</li>
<li>상호 배제 부정 : 한 번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 한다, 실제로는 구현하지 않음</li>
<li>점유 대기 부정 : 프로세스가 실행되기 전 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구하도록 한다.</li>
<li>비선점 부정 : 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고 요구한 자원을 사용하기 위해 기다리게 한다.</li>
<li>환형 대기 부정 : 자원을 선형 순서로 분류하여 고유 번호를 할당하고 각 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 <strong>어느 한 방향으로만 자원을 요구</strong>하도록 한다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=회피기법>회피기법<a href=#회피기법 class=hash-link aria-label="회피기법에 대한 직접 링크" title="회피기법에 대한 직접 링크">​</a></h3>
<p>교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법</p>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=은행원-알고리즘>은행원 알고리즘<a href=#은행원-알고리즘 class=hash-link aria-label="은행원 알고리즘에 대한 직접 링크" title="은행원 알고리즘에 대한 직접 링크">​</a></h4>
<ul>
<li>E.J.Dijkstra가 제안한 것</li>
<li>은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래</li>
<li>각 프로세스에게 자원을 할당하여 교착상태가 발생하지 않음</li>
<li>모든 프로세스가 완료될 수 있는 상태를 안전 상태</li>
<li>교착상태가 발생할 수 있는 상태를 불안전 상태 (<strong>불안전 상태라고해서 모두 교착상태는 아님</strong>)</li>
<li>적용하기 위해선 자원의 양과 프로세스 수가 일정해야 한다.</li>
<li>프로세스의 모든 요구를 유한한 시간 안에 할당하는 것을 보장</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=발견기법>발견기법<a href=#발견기법 class=hash-link aria-label="발견기법에 대한 직접 링크" title="발견기법에 대한 직접 링크">​</a></h3>
<ul>
<li>시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것</li>
<li>교착상태 발견 알고리즘과 자원할당 그래프 등을 사용</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=회복기법>회복기법<a href=#회복기법 class=hash-link aria-label="회복기법에 대한 직접 링크" title="회복기법에 대한 직접 링크">​</a></h3>
<ul>
<li>교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것</li>
<li>프로세스 종료 : 교착상태에 있는 프로세스 종료</li>
<li>자원 선점 : 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에게 할당하며 해당 프로세스를 일시 정지시키는 방법</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=기억장치-관리>기억장치 관리<a href=#기억장치-관리 class=hash-link aria-label="기억장치 관리에 대한 직접 링크" title="기억장치 관리에 대한 직접 링크">​</a></h2>
<p>상위 계층구조일 수록 접근 속도와 접근 시간이 빠르지만 기억용량이 적고 비싸다.</p>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=반입-전략>반입 전략<a href=#반입-전략 class=hash-link aria-label="반입 전략에 대한 직접 링크" title="반입 전략에 대한 직접 링크">​</a></h3>
<ul>
<li>Fetch</li>
<li>보조기억장치에 보관중인 프로그램이나 데이터를 <strong>언제</strong> 주기억장치로 적재할 것인지를 결정하는 전략</li>
<li>요구 반입 : Demand Fetch 실행 중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재</li>
<li>예상 반입 : Anticipatory Fetch 실행 중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=배치-전략>배치 전략<a href=#배치-전략 class=hash-link aria-label="배치 전략에 대한 직접 링크" title="배치 전략에 대한 직접 링크">​</a></h3>
<ul>
<li>Placement</li>
<li>새로 반입되는 프로그램이나 데이터를 주기억장치의 <strong>어디에</strong> 위치시킬 것인지를 결정하는 전략</li>
<li>최초 적합 : First Fit 프로그램에 데이터가 들어갈 수 있는 크기의 빈 영역 중에 첫 번째 분할 영역에 배치</li>
<li>최적 적합 : Best Fit 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치</li>
<li>최악 적합 : Worst Fit 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=교체-전략>교체 전략<a href=#교체-전략 class=hash-link aria-label="교체 전략에 대한 직접 링크" title="교체 전략에 대한 직접 링크">​</a></h3>
<ul>
<li>주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략</li>
<li>FIFO, OPT, LRU, LFU, NUR, SCR</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=주기억장치-할당-기법>주기억장치 할당 기법<a href=#주기억장치-할당-기법 class=hash-link aria-label="주기억장치 할당 기법에 대한 직접 링크" title="주기억장치 할당 기법에 대한 직접 링크">​</a></h2>
<ul>
<li>연속 할당 기법 : 프로그램을 주기억장치에 연속으로 할당하는 기법 (로딩)<!-- -->
<ul>
<li>단일 분할 할당 기법 : 오버레이, 스와핑</li>
<li>다중 분할 할당 기법 : 고정 분할 할당 기법, 동적 분할 할당 기법</li>
</ul>
</li>
<li>분산 할당 기법 : 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법<!-- -->
<ul>
<li>페이징 기법</li>
<li>세그먼테이션 기법</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=단일-분할-할당-기법>단일 분할 할당 기법<a href=#단일-분할-할당-기법 class=hash-link aria-label="단일 분할 할당 기법에 대한 직접 링크" title="단일 분할 할당 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>주기억장치를 운영체제 영역과 사용자 영역으로 나누어 오직 한 명의 사용자만 주기억장치의 사용자 영역을 사용하는 기법</li>
<li><strong>경계 레지스터</strong>가 사용된다.</li>
<li>오버레이 기법을 사용하면서 주기억장치보다 큰 사용자 프로그램을 실행할 수 있게 되었다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=오버레이-기법>오버레이 기법<a href=#오버레이-기법 class=hash-link aria-label="오버레이 기법에 대한 직접 링크" title="오버레이 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법</li>
<li>보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례로 주기억장치에 적재하여 프로그램을 실행한다.</li>
<li>불필요한 조각이 위치한 장소에 새로운 프로그램 조각을 중첩하여 적재</li>
<li>프로그램을 여러 개의 조각으로 분할하는 작업은 프로그래머가 수행하므로 시스템 구조나 프로그램 구조를 알아야함</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=스와핑-기법>스와핑 기법<a href=#스와핑-기법 class=hash-link aria-label="스와핑 기법에 대한 직접 링크" title="스와핑 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법</li>
<li>하나의 사용자 프로그램이 완료될 때까지 교체 과정을 여러 번 수행할 수 있다.</li>
<li>주기억장치 => 보조기억장치 이동을 Swap Out</li>
<li>보조기억장치 => 주기억장치 이동을 Swap In</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=다중-분할-할당-기법>다중 분할 할당 기법<a href=#다중-분할-할당-기법 class=hash-link aria-label="다중 분할 할당 기법에 대한 직접 링크" title="다중 분할 할당 기법에 대한 직접 링크">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=고정-분할-할당>고정 분할 할당<a href=#고정-분할-할당 class=hash-link aria-label="고정 분할 할당에 대한 직접 링크" title="고정 분할 할당에 대한 직접 링크">​</a></h4>
<ul>
<li>Multiple contiguous Fixed partTition allocation = MFT = 정적 할당 = Static Allocation</li>
<li>프로그램을 할당하기 전에 운영체제가 주기억장치 사용자 영역을 여러 개의 고정된 크기로 분할하고 준비상태 큐에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법</li>
<li>프로그램을 실행하려면 <strong>프로그램 전체가 주기억장치에 위치</strong>해야 한다.</li>
<li>프로그램이 분할된 영역보다 커서 영역 안에 못 들어가는 경우가 있다.</li>
<li>내부 단편화 및 외부 단편화 발생</li>
<li>다중 프로그래밍을 위해 사용되었으나 현재는 사용되지 않음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=가변-분할-할당>가변 분할 할당<a href=#가변-분할-할당 class=hash-link aria-label="가변 분할 할당에 대한 직접 링크" title="가변 분할 할당에 대한 직접 링크">​</a></h3>
<ul>
<li>Multiple contiguous Variable parTition allocation = MVT = 동적 할당 = Dynamic Allocation</li>
<li>고정 분할 할당 기법의 단편화를 줄이기 위한 것으로 <strong>프로그램을 주기억 장치에 적재하면서 필요한 만큼의 크기로 영역을 분할</strong>하는 기법</li>
<li>주기억장치를 효율적으로 사용 가능</li>
<li>다중 프로그래밍의 정도를 높일 수 있음</li>
<li>실행될 프로세스 크기에 대한 제약이 적음</li>
<li>단편화를 해결할 수 있으나 영역과 영역사이에 단편화가 발생할 수 있음</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=단편화>단편화<a href=#단편화 class=hash-link aria-label="단편화에 대한 직접 링크" title="단편화에 대한 직접 링크">​</a></h2>
<ul>
<li>분할된 주기억 장치에 프로그램을 할당하고 반납하는 과정을 반복하면서 사용되지 않고 남는 기억장치의 빈 공간 조각</li>
<li>내부 단편화 : Internal Fragmentation 분할된 영역이 할당될 프로그램 크기보다 크기 때문에 남는 공간</li>
<li>외부 단편화 : External Fragmentation 분할된 영역이 할당될 프로그램 크기보다 작아 들어갈 수 없어 남는 공간</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=해결방법>해결방법<a href=#해결방법 class=hash-link aria-label="해결방법에 대한 직접 링크" title="해결방법에 대한 직접 링크">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=통합-기법>통합 기법<a href=#통합-기법 class=hash-link aria-label="통합 기법에 대한 직접 링크" title="통합 기법에 대한 직접 링크">​</a></h4>
<ul>
<li>Coalescing</li>
<li>빈 공간이 다른 빈 공간과 인접되어 있는지 점검한 후 결합하여 사용</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=압축-기법>압축 기법<a href=#압축-기법 class=hash-link aria-label="압축 기법에 대한 직접 링크" title="압축 기법에 대한 직접 링크">​</a></h4>
<ul>
<li>Compaction</li>
<li>분산되어 있는 단편화된 빈 공간을 결합하여 하나의 큰 공간을 만드는 작업</li>
<li>집약 = 가비지 컬렉션</li>
<li>분산된 단편화된 공간을 주기억 장치의 한 쪽 끝으로 옮긴 후 합침</li>
<li>압축이 실행되는 동안 시스템은 모든 일을 일시 중지</li>
<li>기억장소의 재배치<!-- -->
<ul>
<li>압축기법을 수행시에 각 프로그램에 주어진 분할영역의 주소를 새롭게 지정해줘야한다.</li>
<li>Base Register와 Boundary Register를 사용한다.</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=가상기억장치>가상기억장치<a href=#가상기억장치 class=hash-link aria-label="가상기억장치에 대한 직접 링크" title="가상기억장치에 대한 직접 링크">​</a></h2>
<ul>
<li>보조기억장치의 일부를 주기억장치처럼 사용하는 것</li>
<li>프로그램을 여러 개의 작은 블록으로 나눠서 가상기억장치에 보관하고 프로그램 실행시 요구되는 블록만 주기억장치에 불연속적으로 할당</li>
<li><strong>주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용</strong></li>
<li>주기억장치의 이용률과 다중 프로그래밍 효율 증대</li>
<li>단편화 해결</li>
<li>가상기억장치에 저장된 프로그램 실행시 주소변환 작업 필요</li>
<li>주소변환<!-- -->
<ul>
<li>가상기억장이체 있는 프로그램이 주기억장치에 적재되어 실행될 때 논리적인 가상주소를 실기억주소로 변환하는 것</li>
<li>주소 사상 = 주소 매핑</li>
<li>인위적 연속성 : Artificial Contiguity 연속적인 가상주소가 반드시 연속적인 실기억주소로 변환되지 않아도 된다.</li>
<li>가상주소는 보조기억장치에 있는 프로그램 상의 주소 = 논리 주소</li>
<li>실기억주소는 주기억장치에 있는 기억공간의 주소 = 실주소</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=페이징-기법>페이징 기법<a href=#페이징-기법 class=hash-link aria-label="페이징 기법에 대한 직접 링크" title="페이징 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>가상 기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법</li>
<li>페이지 : 프로그램을 일정한 크기로 나눈 단위</li>
<li>페이지 프레임 : 페이지 크기로 일정하게 나눠진 주기억장치의 단위</li>
<li><strong>외부 단편화는 발생하지 않으나 내부 단편화는 발생</strong></li>
<li>주소 변환을 위해 페이지 위치정보를 가지고 있는 <strong>페이지 맵 테이블 필요</strong></li>
<li>페이지 맵 테이블 사용으로 비용 증가, 처리속도 감소</li>
<li>일반적인 페이지 크기는 1~4KB</li>
<li>가상 주소는 페이지 번호와 실제 내용이 위치하고 있는 곳까지의 거리를 나타내는 변위값으로 구성</li>
<li>실기억주소는 페이지 프레임 번호와 프레임 내에서 실제 참조하는 위치까지의 거리를 나타내는 변위값으로 구성</li>
<li>페이지 맵 테이블은 주기억장치에 존재하는지의 여부를 나타내는 상태 비트와 보조기억장치 주소를 나타내는 디스크주소, 페이지가 주기억장치에 있을 때의 페이지 프레임 번호로 구성</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=page-fault>Page Fault<a href=#page-fault class=hash-link aria-label="Page Fault에 대한 직접 링크" title="Page Fault에 대한 직접 링크">​</a></h4>
<ul>
<li>프로그램 실행시 참조한 페이지가 주기억장치에 없는 현상</li>
<li>처리 순서<!-- -->
<ul>
<li>운영체제에서 트랩요청</li>
<li>사용자 레지스트리와 프로그램 상태 저장</li>
<li>현재 교체 가능한 페이지를 페이지 맵 테이블에서 검색</li>
<li>가상기억장치에 있는 페이지를 주기억장치로 전달</li>
<li>페이지 맵 테이블 갱신</li>
<li>프로그램 상태를 불러와 이전 작업 진행</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=세그먼테이션-기법>세그먼테이션 기법<a href=#세그먼테이션-기법 class=hash-link aria-label="세그먼테이션 기법에 대한 직접 링크" title="세그먼테이션 기법에 대한 직접 링크">​</a></h2>
<ul>
<li>Segmentation</li>
<li>가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법</li>
<li>각 세그먼트는 고유한 이름과 크기를 갖는다.</li>
<li>기억장치의 사용자 관점을 보존하는 기억장치 관리 기법이다.</li>
<li><strong>기억공간을 절약하기 위해 사용</strong>한다.</li>
<li>주소변환을 위해서 세그먼트 맵 테이블이 필요</li>
<li>세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며 이를 위해 기억장치 보호키가 필요</li>
<li><strong>내부 단편화는 발생하지 않으나 외부 단편화는 발생</strong></li>
<li>가상 주소는 세그먼트 번호와 세그먼트 내에 실제 내용이 위치하고 있는 곳까지의 거리를 나타내는 변위값으로 구성</li>
<li>실기억주소는 완전주소 형태이면 세그먼트 기분번지와 변위값을 더해서 구함</li>
<li>세그먼트 맵 테이블은 세그먼트 번호와 세그먼트 크기, 주기억장치 상의 기준번지로 구성</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=페이지-교체-알고리즘>페이지 교체 알고리즘<a href=#페이지-교체-알고리즘 class=hash-link aria-label="페이지 교체 알고리즘에 대한 직접 링크" title="페이지 교체 알고리즘에 대한 직접 링크">​</a></h2>
<ul>
<li>페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법</li>
<li>OPT ,FIFO, LRU, LFU, NUR, SCR</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=opt>OPT<a href=#opt class=hash-link aria-label="OPT에 대한 직접 링크" title="OPT에 대한 직접 링크">​</a></h3>
<ul>
<li>OPTimal replacement = 최적 교체</li>
<li>가장 오랫동안 사용하지 않을 페이지를 교체하는 기법</li>
<li>Belady가 제안</li>
<li>페이지 부재가 가장 적게 발생하는 효율적인 알고리즘</li>
<li>각 페이지의 호출 순서와 참조 상황을 예측해야하므로 실현 가능성이 없음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=fifo>FIFO<a href=#fifo class=hash-link aria-label="FIFO에 대한 직접 링크" title="FIFO에 대한 직접 링크">​</a></h3>
<ul>
<li>가장 오래 있었던 페이지를 교체하는 기법</li>
<li>이해하기 쉽고 프로그램이 및 설계가 간단</li>
<li>벨레이디의 모순 현상 발생 : 페이지 프레임 수를 증가시켰는데도 페이지 부재가 더 많이 일어나는 현상</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=lru>LRU<a href=#lru class=hash-link aria-label="LRU에 대한 직접 링크" title="LRU에 대한 직접 링크">​</a></h3>
<ul>
<li>Least Recently Used</li>
<li>가장 오랫동안 사용하지 않은 페이지를 교체하는 기법</li>
<li>각 페이지마다 Counter나 Stack을 두어 체크한다.</li>
<li>별도의 하드웨어가 필요하며 시간적인 오버헤드가 발생한다.</li>
<li>실제로 구현하기가 매우 어렵다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=lfu>LFU<a href=#lfu class=hash-link aria-label="LFU에 대한 직접 링크" title="LFU에 대한 직접 링크">​</a></h3>
<ul>
<li>Least Frequently Used</li>
<li>사용 빈도가 가장 적은 페이지를 교체하는 기법</li>
<li>프로그램 실행 초기에 많이 사용된 페이지가 후에 사용되지 않을 경우에도 프레임을 계속 차지할 수 있다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=nur>NUR<a href=#nur class=hash-link aria-label="NUR에 대한 직접 링크" title="NUR에 대한 직접 링크">​</a></h3>
<ul>
<li>Not Used Recently</li>
<li>LRU와 비슷한 알고리즘으로 최근에 사용하지 않은 페이지를 교체하는 기법</li>
<li>최근에 사용하지 않은 페이지는 나중에도 사용되지 않을 가능성이 높다는 것을 전제로, LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다.</li>
<li>각 페이지마다 <strong>참조 비트와 변형비트</strong>가 사용된다.<!-- -->
<ul>
<li>참조비트 : 페이지가 호출되지 않았을 때는 0, 호출되었을 때는 1</li>
<li>변형비트 : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1</li>
</ul>
</li>
<li>참조비트와 변형비트 값에 따라 교체될 페이지의 순서가 결정된다.</li>
</ul>
<table><thead><tr><th style=text-align:center>순서<th style=text-align:center>참조비트<th style=text-align:center>변형비트<tbody><tr><td style=text-align:center>1<td style=text-align:center>0<td style=text-align:center>0<tr><td style=text-align:center>2<td style=text-align:center>0<td style=text-align:center>1<tr><td style=text-align:center>3<td style=text-align:center>1<td style=text-align:center>0<tr><td style=text-align:center>4<td style=text-align:center>1<td style=text-align:center>1</table>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=scr>SCR<a href=#scr class=hash-link aria-label="SCR에 대한 직접 링크" title="SCR에 대한 직접 링크">​</a></h3>
<ul>
<li>Second Chance Replacement = 2차 기회 교체</li>
<li>가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것</li>
<li>FIFO의 단점을 보완한다.</li>
<li>각 페이지마다 참조 비트를 두고 0일경우 교체하고 1일 경우 참조 비트를 0으로 변경 후 FIFO 큐의 맨 마지막으로 이동시킨다.</li>
<li>LRU처럼 참조 비트를 둔다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=가상기억장치-관리>가상기억장치 관리<a href=#가상기억장치-관리 class=hash-link aria-label="가상기억장치 관리에 대한 직접 링크" title="가상기억장치 관리에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=페이지-크기>페이지 크기<a href=#페이지-크기 class=hash-link aria-label="페이지 크기에 대한 직접 링크" title="페이지 크기에 대한 직접 링크">​</a></h3>
<p><strong>페이지 크기가 작을 경우</strong></p>
<ul>
<li>페이지 단편화 감소</li>
<li>효율적인 워킹 셋 유지</li>
<li>Locality에 더 일치하기 때문에 기억장치 효율이 높아짐</li>
<li>맵 테이블의 크기가 커지고 매핑 속도가 늦어짐</li>
<li>디스크 접근 횟수가 많아져서 전체적인 I/O 효율성 감소</li>
</ul>
<p><strong>페이지 크기가 클 경우</strong></p>
<ul>
<li>맵 테이블 크기가 작아지고 매핑 속도가 빨라짐</li>
<li>디스크 접근 횟수가 줄어들어 I/O 효율성이 증가</li>
<li>페이지 단편화가 증가</li>
<li>불필요한 내용까지 주기억장치에 적재될 수 있음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=locality>Locality<a href=#locality class=hash-link aria-label="Locality에 대한 직접 링크" title="Locality에 대한 직접 링크">​</a></h3>
<ul>
<li>국부성 = 지역성 = 구역성 = 국소성</li>
<li>프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론</li>
<li>스레싱 방지를 위한 워킹 셋 이론의 기반</li>
<li>가상기억장치 관리의 이론적인 근거</li>
<li>Denning 교수에 의해 구역성의 개념이 증명</li>
<li>캐시 메모리 시스템의 이론적 근거</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=시간-구역성>시간 구역성<a href=#시간-구역성 class=hash-link aria-label="시간 구역성에 대한 직접 링크" title="시간 구역성에 대한 직접 링크">​</a></h4>
<ul>
<li>Temporal Locality</li>
<li>프로세스가 실행되면서 하나의 페이지를 일정 시간동안 집중적으로 액세스</li>
<li>한 번 참조한 페이지는 가까운 시간 내에 계속 참조할 가능성이 높음</li>
<li>Loop, Stack, Sub Routine, Counting, 집계(Totaling)</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=공간-구역성>공간 구역성<a href=#공간-구역성 class=hash-link aria-label="공간 구역성에 대한 직접 링크" title="공간 구역성에 대한 직접 링크">​</a></h4>
<ul>
<li>Spatial Locality</li>
<li>프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상</li>
<li>어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음을 의미</li>
<li>배열 순회, 순차적 코드 실행, 프로그래머가 변수를 서로 근처에 선언하여 할당되는 기억장소, 같은 영역에 있는 변수 참조할 때 사용</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=워킹-셋>워킹 셋<a href=#워킹-셋 class=hash-link aria-label="워킹 셋에 대한 직접 링크" title="워킹 셋에 대한 직접 링크">​</a></h3>
<ul>
<li>프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합</li>
<li>Denning이 제안한 프로그램의 움직임에 대한 모델로 프로그램의 Locality 특징을 이용</li>
<li>워킹 셋을 주기억장치에 상주시킴으로 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정</li>
<li>시간이 지남에 따라 자주 참조하는 페이지들의 집합이 변화하기 때문에 워킹셋은 시간에 따라 변경</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=페이지-부재-빈도-방식>페이지 부재 빈도 방식<a href=#페이지-부재-빈도-방식 class=hash-link aria-label="페이지 부재 빈도 방식에 대한 직접 링크" title="페이지 부재 빈도 방식에 대한 직접 링크">​</a></h3>
<ul>
<li>페이지 부재율에 따라 주기억장치에 있는 페이지 프레임의 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=프리페이징>프리페이징<a href=#프리페이징 class=hash-link aria-label="프리페이징에 대한 직접 링크" title="프리페이징에 대한 직접 링크">​</a></h3>
<ul>
<li>필요할 것 같은 모든 페이지를 한꺼번에 페이지 프레임에 적재하는 방식</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=스래싱>스래싱<a href=#스래싱 class=hash-link aria-label="스래싱에 대한 직접 링크" title="스래싱에 대한 직접 링크">​</a></h3>
<ul>
<li>Thrashing</li>
<li>프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상</li>
<li>다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중 자주 페이지 부재가 발생함으로써 나타나는 현상</li>
<li>다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 시점까지는 높아지지만, 더 높아질 경우 스래싱이 나타나고 CPU 이용률은 급격히 감소한다.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=스래싱-방지>스래싱 방지<a href=#스래싱-방지 class=hash-link aria-label="스래싱 방지에 대한 직접 링크" title="스래싱 방지에 대한 직접 링크">​</a></h4>
<ul>
<li>다중 프로그래밍의 정도를 적정 수준으로 유지</li>
<li>페이지 부재 빈도를 조절하여 사용</li>
<li>워킹 셋을 유지</li>
<li>부족한 자원을 증설하고 일부 프로세스를 중단</li>
<li>CPU 성능에 대한 자료의 지속적 관리 및 분석해 임계치를 예상하고 운영</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=디스크-스케쥴링>디스크 스케쥴링<a href=#디스크-스케쥴링 class=hash-link aria-label="디스크 스케쥴링에 대한 직접 링크" title="디스크 스케쥴링에 대한 직접 링크">​</a></h2>
<ul>
<li>사용할 데이터가 디스크 상에 여러 곳에 저장되어 있을 경우 데이터를 액세스하기 위해 디스크 헤드가 움직이는 경로를 결정하는 기법</li>
<li>탐색시간을 최적화하기 위해 수행된다.</li>
<li><strong>처리량 최대화</strong></li>
<li><strong>응답 시간 최소화</strong></li>
<li><strong>응답 시간 편차의 최소화</strong></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=fcfs-1>FCFS<a href=#fcfs-1 class=hash-link aria-label="FCFS에 대한 직접 링크" title="FCFS에 대한 직접 링크">​</a></h3>
<ul>
<li>FIFO</li>
<li>가장 간단한 스케쥴링으로 디스크 대기 큐에 먼저 들어온 순서로 실행</li>
<li>디스크 오버헤드가 적을 때 효율적</li>
<li>프로그래밍이 쉬움</li>
<li>헤드 이동거리가 상당히 길어질 수 있다.</li>
<li>디스크 오버헤드가 커지면 응답시간이 길어진다.</li>
<li>탐색 시간을 최적화하려는 시도가 없는 기법</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=sstf>SSTF<a href=#sstf class=hash-link aria-label="SSTF에 대한 직접 링크" title="SSTF에 대한 직접 링크">​</a></h3>
<ul>
<li>Short Seek Time First</li>
<li>탐색거리가 가장 짧은 트랙에 대한 요청을 먼저 서비스</li>
<li>현재 헤드 위치에서 가장 가까운 거리에 있는 트랙으로 헤드를 이동</li>
<li>FCFS보다 처리량이 많고 평균 탐색 시간이 짧다.</li>
<li>일괄 처리 시스템에 유용</li>
<li>먼 거리의 트랙은 무한정 기다릴 수도 있음</li>
<li>응답 시간 편차가 크기 때문에 대화형 시스템에 부적합</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=scan>SCAN<a href=#scan class=hash-link aria-label="SCAN에 대한 직접 링크" title="SCAN에 대한 직접 링크">​</a></h3>
<ul>
<li>SSTF가 갖는 탐색 시간의 편차를 해소하기 위한 기법</li>
<li>Denning이 개발, 대부분의 디스크 스케쥴링에서 기본 전략으로 이용</li>
<li>현재 헤드의 위치에서 진행방향이 결정되면 탐색 거리가 짧은 순서에 따라 그 방향의 모든 요청을 서비스하고, 끝까지 이동하면 역방향으로 요청 사항을 서비스</li>
<li>헤드가 이동하면서 새로운 요청이 서비스됨</li>
<li>현재 진행방향에 더 이상의 요청이 없을 때만 방향을 바꿈</li>
<li>SSTF에서 발생하는 응답 시간의 편차 감소</li>
<li>오버헤드가 적을 경우 가장 효율적인 기법</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=c-scan>C-SCAN<a href=#c-scan class=hash-link aria-label="C-SCAN에 대한 직접 링크" title="C-SCAN에 대한 직접 링크">​</a></h3>
<ul>
<li>Cicular SCAN</li>
<li>항상 바깥쪽에서 안쪽으로 움직이면서 가장 짧은 탐색 거리를 갖는 요청을 서비스</li>
<li>헤드는 트랙 바깥쪽에서 안쪽으로 한 방향만 움직이며 서비스하여 끝까지 이동한 후 안쪽에 더 이상의 요청이 없으면 헤드는 가장 바깥쪽의 끝으로 이동한 후 다시 안쪽으로 이동하면서 요청을 서비스</li>
<li>처음과 마지막 트랙을 인접시킨 것과 같은 원형 형태로 디스크를 처리</li>
<li><strong>새로운 요청이 도착하면 다음 헤드가 진행할 때 서비스</strong></li>
<li>트랙 안쪽과 바깥쪽 요청에 대한 서비스가 공평</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=lock>LOCK<a href=#lock class=hash-link aria-label="LOCK에 대한 직접 링크" title="LOCK에 대한 직접 링크">​</a></h3>
<ul>
<li>SCAN 기법을 기초로 사용하되 마지막 요청을 서비스한 후 그 방향의 끝으로 이동하는 것이 아니라 바로 역방향으로 진행하는 기법</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=c-lock>C-LOCK<a href=#c-lock class=hash-link aria-label="C-LOCK에 대한 직접 링크" title="C-LOCK에 대한 직접 링크">​</a></h3>
<ul>
<li>C-SCAN 기법을 기초로 사용하되 바깥쪽에서 안쪽 방향의 모든 요청을 처리한 후 가장 바깥쪽 요청 트랙으로 이동한 후 안쪽 방향으로 요청을 서비스</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=n-scan>N-SCAN<a href=#n-scan class=hash-link aria-label="N-SCAN에 대한 직접 링크" title="N-SCAN에 대한 직접 링크">​</a></h3>
<ul>
<li>N-step SCAN</li>
<li>SCAN 기법의 무한 대기 발생 가능성을 제거한 것</li>
<li>어떤 방향의 진행이 시작될 시에 대기 중이던 요청들만 서비스하고 진행 도중 들어온 요청은 한데 모아서 다음 반대 방향 진행 때 서비스하는 기법</li>
<li>SSTF나 SCAN보다 응답시간의 편차가 적다.</li>
<li>특정 방향에 많은 수의 요청이 도착할 경우 반대 방향에서의 무한 지연 발생을 방지</li>
<li>진행도중 도착한 요청은 반대 방향 진행시 서비스하기 위해 디스크 대기 큐에 저장</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=eschenbach>Eschenbach<a href=#eschenbach class=hash-link aria-label="Eschenbach에 대한 직접 링크" title="Eschenbach에 대한 직접 링크">​</a></h3>
<ul>
<li>에션바흐는 부하가 매우 큰 항공 예약 시스템을 위해 개발</li>
<li>탐색 시간과 회전 지연 시간을 최적화하기 위한 최초의 기법</li>
<li>헤드는 C-SCAN처럼 움직이며 모든 실린더는 그 실린더에 요청이 있던 없던 전체 트랙이 한 바퀴를 회전할 동안에 서비스를 받음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=sltf>SLTF<a href=#sltf class=hash-link aria-label="SLTF에 대한 직접 링크" title="SLTF에 대한 직접 링크">​</a></h3>
<ul>
<li>Shortest Latency Time First = Sector Queuing</li>
<li>회전 지연 시간의 최적화를 위해 구현된 기법</li>
<li>드럼에서 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=파일>파일<a href=#파일 class=hash-link aria-label="파일에 대한 직접 링크" title="파일에 대한 직접 링크">​</a></h2>
<ul>
<li>사용자가 작성한 서로 관련 잇는 레코드의 집합체</li>
<li>프로그램 구성의 기본 단위며 보조기억장치에 저장</li>
<li>소멸성 : 파일을 추가하거나 제거하는 작업의 빈도수</li>
<li>활성률 : 프로그램이 한번 수행되는 동안 처리되는 레코드 수의 백분율</li>
<li>크기 : 파일에 저장되어 있는 정보량</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=파일-시스템>파일 시스템<a href=#파일-시스템 class=hash-link aria-label="파일 시스템에 대한 직접 링크" title="파일 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>파일의 저장, 액세스, 공유, 보호 등 보조기억장치에서의 파일을 총괄하는 파일 관리 기술</li>
<li>사용자와 보조기억장치 사이에서 인터페이스를 제공</li>
<li>사용자가 파일을 생성, 수정, 제거할 수 있도록 한다.</li>
<li>파일을 공동으로 사용할 수 있게 한다.</li>
<li>여러 종류의 액세스 제어방법 제공</li>
<li>사용자가 적합한 구조로 파일을 구성</li>
<li>파일의 예비와 복구 등의 기능 제공</li>
<li>사용자가 물리적 장치 이름 대신에 기호화된 이름을 사용할 수 있게 함</li>
<li>사용자가 파일을 편리하게 사용할 수 있도록 파일의 논리적 상태를 보여줘야함</li>
<li>파일을 안전하게 사용할 수 있도록하고 파일이 보호되어야함</li>
<li>파일 정보가 손실되지 않도록 데이터 무결성을 유지</li>
<li>파일 단위 작업 : Open Close Create Copy Destory Rename List</li>
<li>파일 내 레코드 단위 작업 : Read Write Update Insert Delete Search</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=파일-디스크립터>파일 디스크립터<a href=#파일-디스크립터 class=hash-link aria-label="파일 디스크립터에 대한 직접 링크" title="파일 디스크립터에 대한 직접 링크">​</a></h3>
<ul>
<li>File Descriptor = 파일 서술자 = FCB = File Control Block = 파일 제어 블록</li>
<li>시스템이 필요로하는 파일에 대한 정보를 갖고 있는 제어블록</li>
<li>파일마다 독립적으로 존재</li>
<li>시스템에 따라 다른 구조를 가짐</li>
<li>보조기억장치 내에 저장되어 있다가 해당 파일이 열릴 때 주기억장치로 옮겨짐</li>
<li>파일 시스템이 관리하므로 사용자가 참조 불가</li>
<li><strong>파일 디스크립터의 정보</strong>
<ul>
<li>파일 이름 및 파일 크기</li>
<li>보조기억장치에서의 파일 위치</li>
<li>파일 구조 : 순차, 색인 순차, 색인 파일..</li>
<li>보조기억장치의 유형</li>
<li>액세스 제어 정보</li>
<li>파일 유형 : 텍스트, 목적 프로그램...</li>
<li>생성 날짜와 시간</li>
<li>제거 날짜와 시간</li>
<li>최종 수정 날짜와 시간</li>
<li>액세스한 횟수</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=파일-구조>파일 구조<a href=#파일-구조 class=hash-link aria-label="파일 구조에 대한 직접 링크" title="파일 구조에 대한 직접 링크">​</a></h2>
<p>파일 접근 방법이라고도 한다.</p>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=순차-파일>순차 파일<a href=#순차-파일 class=hash-link aria-label="순차 파일에 대한 직접 링크" title="순차 파일에 대한 직접 링크">​</a></h3>
<ul>
<li>Sequential File = 순서 파일 = 순차 접근 방식 = SAM = Sequential Access Method</li>
<li>레코드를 논리적인 처리 순서에 따라 연속된 물리적 저장공간에 기록하는 것</li>
<li>레코드들이 순차적으로 기록되어 판독할 때도 순차적으로 접근</li>
<li>자기 테이프를 모형화한 구조</li>
<li>일괄 처리에 적합한 구조</li>
<li>레코드를 삽입하거나 삭제하는 경우 <strong>파일 전체를 복사한 후 수행</strong>하므로 시간이 오래 걸림<!-- -->
<ul>
<li>파일 전체를 복사</li>
<li>복사된 파일을 대상으로 레코드를 특정 위치에 삽입하거나 삭제</li>
<li>모든 레코드의 위치를 순차적으로 재배치</li>
<li>재비치된 복사파일을 원래 파일로 저장</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=직접-파일>직접 파일<a href=#직접-파일 class=hash-link aria-label="직접 파일에 대한 직접 링크" title="직접 파일에 대한 직접 링크">​</a></h3>
<ul>
<li>Direct File = 직접 접근 방식 = DAM = Direct Access Method</li>
<li>파일을 구성하는 레코드를 임의의 물리적 저장공간에 기록하는 것</li>
<li>레코드에 특정 기준으로 키가 할당</li>
<li>**해싱 함수(사상함수)**를 이용하여 이 키에 대한 보조기억장치의 물리적 상대 레코드 주소를 계산한 후 해당하는 주소에 레코드를 저장</li>
<li>레코드는 해싱 함수에 의해 계산된 물리적 주소를 통해 접근</li>
<li>임의 접근이 가능한 자기 디스크나 드럼을 사용</li>
<li>접근 시간이 빠르고 레코드의 삽입, 삭제, 갱신이 용이</li>
<li>레코드의 주소 변환 과정이 필요해 시간 소요</li>
<li>기억공간의 효율 저하</li>
<li>기억장치의 물리적 구조에 대한 지식 필요</li>
<li>프로그래밍이 복잡</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=색인-순차-파일>색인 순차 파일<a href=#색인-순차-파일 class=hash-link aria-label="색인 순차 파일에 대한 직접 링크" title="색인 순차 파일에 대한 직접 링크">​</a></h3>
<ul>
<li>Indexed Sequential File = 색인 순차 접근 방식 = ISAM = Index Sequential Access Method</li>
<li>순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 형태</li>
<li>각 레코드를 키 값 순으로 논리적으로 저장하고 시스템은 각 레코드의 실제 주소가 저장된 색인을 관리</li>
<li>레코드 참조시 색인을 탐색한 후 색인이 가리키는 포인터를 사용하여 참조</li>
<li>자기디스크에서 많이 사용</li>
<li>자기테이프에서 사용 불가</li>
<li>순차처리나 임의처리가 모두 가능</li>
<li>효율적인 검색 가능하고 삽입 삭제 갱신이 용이</li>
<li>색인영역이나 오버플로 영역을 설정해야하므로 기억공간이 필요</li>
<li>색인을 이용하여 참조하기 때문에 접근 시간이 직접파일보다 느리다.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=구성-2>구성<a href=#구성-2 class=hash-link aria-label="구성에 대한 직접 링크" title="구성에 대한 직접 링크">​</a></h4>
<ul>
<li>기본 영역 : Prime Area 실제 레코드가 기록되는 데이터 영역</li>
<li>색인 영역 : Index Area 레코드들의 위치를 찾아가는 색인이 기록되는 영역</li>
<li>오버플로 영역 : Overflow Area 예비로 확보해 둔 영역</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=분할파일>분할파일<a href=#분할파일 class=hash-link aria-label="분할파일에 대한 직접 링크" title="분할파일에 대한 직접 링크">​</a></h3>
<ul>
<li>하나의 파일을 여러 개로 분할하여 저장하는 형태</li>
<li>여러 개의 순차 서브파일로 구성된 파일</li>
<li>백업과 같이 하드디스크에 있는 내용을 테이프와 같은 보조기억장치에 저장할 때 사용</li>
<li>파일의 크기가 클 경우 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=디렉터리-구조>디렉터리 구조<a href=#디렉터리-구조 class=hash-link aria-label="디렉터리 구조에 대한 직접 링크" title="디렉터리 구조에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=1단계-디렉터리-구조>1단계 디렉터리 구조<a href=#1단계-디렉터리-구조 class=hash-link aria-label="1단계 디렉터리 구조에 대한 직접 링크" title="1단계 디렉터리 구조에 대한 직접 링크">​</a></h3>
<ul>
<li>단일 디렉터리 구조</li>
<li>모든 파일이 하나의 디렉터리 내에 위치하여 관리되는 구조</li>
<li>모든 파일들이 유일한 이름을 갖고 있어야함</li>
<li>모든 파일이 같은 디렉터리 내에 유지되므로 이해가 쉬움</li>
<li>파일이나 사용자의 수가 증가하면 파일 관리가 복잡</li>
<li>파일명은 일반적으로 내용과 관련된 이름을 사용</li>
<li>파일명의 길이는 시스템에 따라 제한을 받음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=2단계-디렉터리-구조>2단계 디렉터리 구조<a href=#2단계-디렉터리-구조 class=hash-link aria-label="2단계 디렉터리 구조에 대한 직접 링크" title="2단계 디렉터리 구조에 대한 직접 링크">​</a></h3>
<ul>
<li>중앙에 마스터 파일 디렉터리(MFD)가 있고, 그 아래 사용자별 파일 디렉터리(UFD)가 있는 2계층 구조</li>
<li>마스터 파일 디렉터리는 각 사용자의 정보와 사용자 파일 디렉터리를 가리키는 포인터를 갖고 있으며 사용자 파일 디렉터리를 관리</li>
<li>사용자 파일 디렉터리는 오직 한 사용자가 갖고 있는 파일들에 대한 정보를 가짐</li>
<li>각 사용자는 다른 사용자의 파일 디렉터리를 검색할 수 없음</li>
<li>한 사용자 파일 디렉터리에서는 유일한 파일이름을 사용해야되나 서로 다른 사용자라면 동일한 파일이름을 사용할 수 있다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=트리-디렉터리-구조>트리 디렉터리 구조<a href=#트리-디렉터리-구조 class=hash-link aria-label="트리 디렉터리 구조에 대한 직접 링크" title="트리 디렉터리 구조에 대한 직접 링크">​</a></h3>
<ul>
<li>하나의 루트 디렉터리와 여러 개의 서브 디렉터리로 구성된 구조</li>
<li>DOS, UNIX, Windows의 <strong>운영체제에서 사용되는 디렉터리 구조</strong></li>
<li>디렉터리 탐색은 포인터를 사용</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=비순환-그래프-디렉터리-구조>비순환 그래프 디렉터리 구조<a href=#비순환-그래프-디렉터리-구조 class=hash-link aria-label="비순환 그래프 디렉터리 구조에 대한 직접 링크" title="비순환 그래프 디렉터리 구조에 대한 직접 링크">​</a></h3>
<ul>
<li>비주기 그래프 디렉터리 = Acyclic Graph Directory</li>
<li>하위 파일이나 하위 디렉터리를 공동으로 사용할 수 있는 것</li>
<li><strong>사이클이 허용되지 않는 구조</strong> = 하위 디렉터리가 상위 디렉터리나 상위 파일을 공유할 수 없다.</li>
<li>하나의 파일이나 디렉터리가 여러 개의 경로로 접근이 가능</li>
<li>디렉터리 구조가 복잡하고 시스템 성능이 저하됨</li>
<li>공유된 파일을 삭제할 경우 고아포인터(Dangling Pointer)가 발생</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=일반적인-그래프-디렉터리-구조>일반적인 그래프 디렉터리 구조<a href=#일반적인-그래프-디렉터리-구조 class=hash-link aria-label="일반적인 그래프 디렉터리 구조에 대한 직접 링크" title="일반적인 그래프 디렉터리 구조에 대한 직접 링크">​</a></h3>
<ul>
<li>트리 구조에 링크를 첨가시켜 사이클을 허용하는 그래프 구조</li>
<li>디렉터리와 파일 공유에 완전한 융통성</li>
<li>탐색 알고리즘이 간단하여 파일과 디렉터리를 액세스하기 쉬움</li>
<li>사용되지 않은 디스크 공간을 되찾기 위해 가비지 컬렉션이 필요</li>
<li>가비지 컬렉팅을 해야되기에 참조 계수기가 필요</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=디스크-공간-할당-방법>디스크 공간 할당 방법<a href=#디스크-공간-할당-방법 class=hash-link aria-label="디스크 공간 할당 방법에 대한 직접 링크" title="디스크 공간 할당 방법에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=연속-할당>연속 할당<a href=#연속-할당 class=hash-link aria-label="연속 할당에 대한 직접 링크" title="연속 할당에 대한 직접 링크">​</a></h3>
<ul>
<li>Contiguous Allocation</li>
<li>연속된 공간에 할당하는 방법으로 생성되는 파일의 크기만큼 공간이 있어야함</li>
<li>논리적으로 연속된 레코드가 물리적인 저장공간에도 연속적으로 저장됨</li>
<li>파일의 생성과 삭제가 반복되면 단편화 발생</li>
<li>단편화를 줄이기 위해 재배치에 의한 주기적인 압축이 필요</li>
<li>파일의 크기가 시간에 따라 변경될 경우 구현하기 어려움</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=불연속-할당>불연속 할당<a href=#불연속-할당 class=hash-link aria-label="불연속 할당에 대한 직접 링크" title="불연속 할당에 대한 직접 링크">​</a></h3>
<ul>
<li>Non-Contiguous Allocation</li>
<li>디스크 공간을 일정 단위로 나누어 할당하는 기법</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=섹터-단위-할당>섹터 단위 할당<a href=#섹터-단위-할당 class=hash-link aria-label="섹터 단위 할당에 대한 직접 링크" title="섹터 단위 할당에 대한 직접 링크">​</a></h4>
<ul>
<li>하나의 파일이 디스크 섹터 단위로 분산되어 할당되는 방법</li>
<li>하나의 파일에 속하는 섹터들이 연결 리스트로 구성</li>
<li>디렉터리는 파일의 시작과 마지막 주소에 대한 정보만 가지고 있음</li>
<li>섹터 단위로 저장되므로 디스크 단편화가 발생되지 않음</li>
<li>파일의 크기만큼 연속된 공간이 없어도 저장 가능</li>
<li>레코드 검색시 파일이 속한 레코드를 순차적으로 검색해야 하므로 탐색시간이 오래 걸린다.</li>
<li>직접 접근이 불가능</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=블록-단위-할당>블록 단위 할당<a href=#블록-단위-할당 class=hash-link aria-label="블록 단위 할당에 대한 직접 링크" title="블록 단위 할당에 대한 직접 링크">​</a></h4>
<ul>
<li>하나의 파일이 연속된 여러 개의 섹터를 묶은 블록 단위로 할당되는 방법</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_B5Wd" id=블록-체인-기법>블록 체인 기법<a href=#블록-체인-기법 class=hash-link aria-label="블록 체인 기법에 대한 직접 링크" title="블록 체인 기법에 대한 직접 링크">​</a></h5>
<ul>
<li>할당 단위를 블록으로 구성하는 방법</li>
<li>하나의 블록은 러 개의 섹터로 구성</li>
<li>디렉터리는 파일의 첫 번째 블록을 가리키는 포인터를 가지고 있음</li>
<li>하나의 블록은 데이터와 다음 블록을 가리키는 포인터로 구성</li>
<li>삽입 삭제시 포인터만 수정하면 되므로 간단</li>
<li>순차적으로 탐색해야 되므로 속도가 느림</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_B5Wd" id=색인-블록-체인-기법>색인 블록 체인 기법<a href=#색인-블록-체인-기법 class=hash-link aria-label="색인 블록 체인 기법에 대한 직접 링크" title="색인 블록 체인 기법에 대한 직접 링크">​</a></h5>
<ul>
<li>인덱스 블록 체인 기법</li>
<li>파일이 할당된 블록의 모든 포인터를 색인 블록에 모아 <strong>직접 접근이 가능</strong></li>
<li>디렉터리는 파일의 색인 블록에 대한 포인터를 갖고 있음</li>
<li>색인 블록의 포인터를 사용하여 직접 접근이 가능해 탐색 시간이 빠름</li>
<li>삽입시 색인 블록을 재구성</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_B5Wd" id=블록-지향-파일-사상-기법>블록 지향 파일 사상 기법<a href=#블록-지향-파일-사상-기법 class=hash-link aria-label="블록 지향 파일 사상 기법에 대한 직접 링크" title="블록 지향 파일 사상 기법에 대한 직접 링크">​</a></h5>
<ul>
<li>포인터 대신 파일 할당 테이블(File Allocation Table)에 있는 블록번호를 사용하는 기법</li>
<li>파일 할당 테이블에는 각 블록에 해당하는 항목이 있고 각 항목은 블록번호에 의해 색인된다.</li>
<li>블록 번호에 의해 색인된 테이블의 각 항목은 다음 블록의 블록번호를 가짐</li>
<li>디스크 구조의 특성상 블록번호는 실제 기억공간의 주소로 쉽게 변환 가능</li>
<li>데이터의 삽입 삭제가 용이</li>
<li>디렉터리는 파일 할당 테이블의 시작위치를 가지고 있음</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=자원-보호>자원 보호<a href=#자원-보호 class=hash-link aria-label="자원 보호에 대한 직접 링크" title="자원 보호에 대한 직접 링크">​</a></h2>
<ul>
<li>불법적으로 접근하는 것을 제어</li>
<li>자원의 물리적인 손상을 예방하는 기법</li>
<li>접근 제어 행렬, 전역 테이블, 접근 제어 리스트, 권한(자격) 리스트</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=접근-제어-행렬-기법>접근 제어 행렬 기법<a href=#접근-제어-행렬-기법 class=hash-link aria-label="접근 제어 행렬 기법에 대한 직접 링크" title="접근 제어 행렬 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>Access Control Matrix</li>
<li>자원보호의 일반적인 모델</li>
<li>객체에 대한 접근 권한을 행렬로써 표시한 기법</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=전역-테이블-기법>전역 테이블 기법<a href=#전역-테이블-기법 class=hash-link aria-label="전역 테이블 기법에 대한 직접 링크" title="전역 테이블 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>Global Table</li>
<li>가장 단순한 구현 방법</li>
<li>세 개의 순서쌍인 영역, 개체, 접근 권한의 집합을 목록 형태로 구성</li>
<li>테이블이 매우 커서 주기억장치에 저장할 수 없으므로 가상기억장치 기법을 사용해야한다.</li>
<li>주기억장치에 저장될 경우 공간 낭비</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=접근-제어-리스트>접근 제어 리스트<a href=#접근-제어-리스트 class=hash-link aria-label="접근 제어 리스트에 대한 직접 링크" title="접근 제어 리스트에 대한 직접 링크">​</a></h3>
<ul>
<li>Access Control List</li>
<li>접근 제어 행렬에 있는 각 열, 즉 객체를 중심으로 접근 리스트를 구성</li>
<li>각 객체에 대한 리스트는 영역, 접근권한의 순서쌍으로 구성되며 객체에 대한 접근 권한을 갖는 모든 영역을 정의</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=권한-리스트-기법>권한 리스트 기법<a href=#권한-리스트-기법 class=hash-link aria-label="권한 리스트 기법에 대한 직접 링크" title="권한 리스트 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>Capability List = 자격 리스트</li>
<li>접근 제어 행렬에 있는 각 행, 즉 영역을 중심으로 권한 리스트를 구성</li>
<li>권한 리스트는 영역과 결합되어 있지만 그 영역에서 수행중인 프로세스가 직접 접근할 수는 없다.</li>
<li>권한 리스트는 운영체제에 의해 유지되며 사용자에 의해 간접적으로만 접근이 되는 보호된 객체이기 때문</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=lock-key-기법>Lock-Key 기법<a href=#lock-key-기법 class=hash-link aria-label="Lock-Key 기법에 대한 직접 링크" title="Lock-Key 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>접근 제어 리스트와 권한 리스트를 절충한 기법</li>
<li>객체는 Lock 영역은 Key라 불리는 유일 값을 가지고 있어 영역과 객체가 일치하는 경우만 해당 객체를 접근 가능</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=파일-보호-기법>파일 보호 기법<a href=#파일-보호-기법 class=hash-link aria-label="파일 보호 기법에 대한 직접 링크" title="파일 보호 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>자원 보호 기법과 마찬가지로 파일에 대한 일방적인 접근과 손상 및 파괴를 방지하기 위함</li>
<li>Naming, Password, Access Control</li>
<li>파일의 명명 : 접근하고자 하는 파일 이름을 모르는 사용자를 접근 대상에서 제외</li>
<li>비밀번호</li>
<li>접근 제어 : 공유 데이터에 접근할 수 있는 권한을 제어, 각 파일마다 접근 목록을 둔다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=보안>보안<a href=#보안 class=hash-link aria-label="보안에 대한 직접 링크" title="보안에 대한 직접 링크">​</a></h2>
<ul>
<li>컴퓨터 시스템 내에 있는 프로그램과 데이터에 대해 통제된 접근 방식을 어떻게 제공할 것인가를 다루는 것</li>
<li>컴퓨터 시스템 내의 자원을 보호하고 대응하기 위한 일련의 정책과 행위</li>
<li>프로그램, 프로세스 또는 사용자의 허용된 권한 외의 접근을 제한</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=보안-요건>보안 요건<a href=#보안-요건 class=hash-link aria-label="보안 요건에 대한 직접 링크" title="보안 요건에 대한 직접 링크">​</a></h3>
<ul>
<li>기밀성 : Confidentiality 자원은 인가된 사용자에게만 접근이 허용, 노출되어도 데이터를 읽을 수 없음</li>
<li>무결성 : Integrity 오직 인가된 사용자만 수정 가능</li>
<li>가용성 : Availability 인가받은 사용자는 언제든 사용 가능</li>
<li>인증 : Authentication</li>
<li>부인 방지 : NonRepudiation 데이터를 송수신한 자가 송수신 사실을 부인할 수 없도록 송수신 증거 제공</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=보안-유지-기법>보안 유지 기법<a href=#보안-유지-기법 class=hash-link aria-label="보안 유지 기법에 대한 직접 링크" title="보안 유지 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>외부 보안<!-- -->
<ul>
<li>시설보안</li>
<li>운용보안 : 사용자마다 인가된 등급 부여</li>
</ul>
</li>
<li>사용자 인터페이스 보안 : 사용자의 신원 확인</li>
<li>내부 보안<!-- -->
<ul>
<li>하드웨어나 운영체제에 내장된 보안 기능 사용</li>
<li>하드웨어나 운영체제 내에 접근 제어 코드를 내장</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=보안-위험-감소-방법>보안 위험 감소 방법<a href=#보안-위험-감소-방법 class=hash-link aria-label="보안 위험 감소 방법에 대한 직접 링크" title="보안 위험 감소 방법에 대한 직접 링크">​</a></h3>
<ul>
<li>사용자 감시 : User Surveillance</li>
<li>위험 탐지 : Threat Monitoring</li>
<li>확충 : Amplification</li>
<li>패스워드 보호</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=정보-보안-기법>정보 보안 기법<a href=#정보-보안-기법 class=hash-link aria-label="정보 보안 기법에 대한 직접 링크" title="정보 보안 기법에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=비밀키-시스템>비밀키 시스템<a href=#비밀키-시스템 class=hash-link aria-label="비밀키 시스템에 대한 직접 링크" title="비밀키 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>Private Key System</li>
<li>동일한 키로 데이터를 암호화하고 복호화하는 대칭 암호화 기법</li>
<li>암/복호화의 속도가 빠르며 알고리즘이 단순</li>
<li>파일 크기가 작음</li>
<li>사용자가 많아지면 관리할 키의 수가 상대적으로 많아지고 키의 분배가 어려워짐</li>
<li>DES (Data Encryption Standard)</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=공용키-시스템>공용키 시스템<a href=#공용키-시스템 class=hash-link aria-label="공용키 시스템에 대한 직접 링크" title="공용키 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>Public Key System</li>
<li>서로 다른 키로 데이터를 암호화하고, 복호화하는 비대칭 암호화 기법</li>
<li>키의 분배가 용이하고 관리해야할 키의 개수가 적음</li>
<li>암/복호화 속도가 느리며 알고리즘이 복잡</li>
<li>파일의 크기가 큼</li>
<li>RSA (Rivest Shamir Adleman)</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=디지털-서명-기법>디지털 서명 기법<a href=#디지털-서명-기법 class=hash-link aria-label="디지털 서명 기법에 대한 직접 링크" title="디지털 서명 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>Digital Signature Mechanism</li>
<li>고유의 전자 서명으로 송신자가 전자 문서 송신 사실을 부인할 수 없도록 함</li>
<li>작성 내용이 송수신 과정에서 변조된 사실이 없다는 것을 증명</li>
<li>공개키 암호화 기법을 사용</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=여분-정보-삽입-기법>여분 정보 삽입 기법<a href=#여분-정보-삽입-기법 class=hash-link aria-label="여분 정보 삽입 기법에 대한 직접 링크" title="여분 정보 삽입 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>Traffic Padding Mechanism</li>
<li>정상 데이터에 여분의 거짓 데이터를 삽입하여 불법적으로 데이터를 분석하는 공격을 방어하는 기법</li>
<li>삽입한 거짓 데이터가 정상 데이터와 구별이 되지 않아야함</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=인증-교환-기법>인증 교환 기법<a href=#인증-교환-기법 class=hash-link aria-label="인증 교환 기법에 대한 직접 링크" title="인증 교환 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>Authentication Exchange Mechanism</li>
<li>수신자가 메세지 전송 도중 변경되지 않았음을 확인할 수 있다.</li>
<li>메세지가 정당한 상대방으로부터 전달된 것을 확인할 수 있다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=접근-제어-기법>접근 제어 기법<a href=#접근-제어-기법 class=hash-link aria-label="접근 제어 기법에 대한 직접 링크" title="접근 제어 기법에 대한 직접 링크">​</a></h3>
<ul>
<li>Access Control Mechanism</li>
<li>데이터에 접근이 허가된 사용자에게만 데이터 사용을 허용하는 정책을 강화하기 위해 사용</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=fault-tolerant-system>Fault Tolerant System<a href=#fault-tolerant-system class=hash-link aria-label="Fault Tolerant System에 대한 직접 링크" title="Fault Tolerant System에 대한 직접 링크">​</a></h3>
<ul>
<li>고장 방지 시스템 = 결함 허용 시스템</li>
<li>시스템 부품 고장이나 프로그램에 버그가 있더라도 시스템 전체에 장애가 발생하지 않도록 시스템을 구성하는 방법</li>
<li>Dual System : 같은 장치를 두 개로 구성하여 하나가 고장나면 다른 하나를 작동시켜 작업을 처리하는 시스템</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=다중-처리기>다중 처리기<a href=#다중-처리기 class=hash-link aria-label="다중 처리기에 대한 직접 링크" title="다중 처리기에 대한 직접 링크">​</a></h2>
<ul>
<li>Multi Processor</li>
<li>하나의 시스템에 여러 개의 처리기를 두어 하나의 작업을 각 처리기에게 할당하여 수행하도록 하는 것을 의미</li>
<li>강결합 시스템</li>
<li>실행시간이 감소되고 전체 효율을 향상</li>
<li><strong>하나의 운영체제에 의해 전체 시스템이 제어</strong></li>
<li>하나의 공통된 기억장소를 가짐</li>
<li>프로세서 중 하나가 고장 나도 다른 프로세서들에 의해 작업이 처리되므로 장애극복 가능</li>
<li>각 프로세서는 자체 계산능력을 가짐</li>
<li>프로세서나 주변장치 등을 공동으로 사용</li>
<li>주변장치가 기억장치에 연결되는 방식에 따라 시분할 및 공유버스, 크로스바 교환행렬, 하이퍼 큐브 방식으로 나뉨</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=시분할-및-공유-버스-연결-방식>시분할 및 공유 버스 연결 방식<a href=#시분할-및-공유-버스-연결-방식 class=hash-link aria-label="시분할 및 공유 버스 연결 방식에 대한 직접 링크" title="시분할 및 공유 버스 연결 방식에 대한 직접 링크">​</a></h3>
<ul>
<li>각종 장치들을 버스 하나로 연결한 방식</li>
<li>장치 연결이 단순하고 경제적이며 융통성이 있음</li>
<li>장치 추가 용이</li>
<li><strong>한 시점에 하나의 전송만 가능</strong></li>
<li>버스가 고장나면 시스템이 먹통</li>
<li>시스템 전체 전송량이 버스의 전송률에 의해 제한</li>
<li>장치들의 경쟁 상태가 발생하면 시스템 효율이 저하</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=크로스바-교환-행렬-연결-방식>크로스바 교환 행렬 연결 방식<a href=#크로스바-교환-행렬-연결-방식 class=hash-link aria-label="크로스바 교환 행렬 연결 방식에 대한 직접 링크" title="크로스바 교환 행렬 연결 방식에 대한 직접 링크">​</a></h3>
<ul>
<li>시분할 및 공유 버스 방식에서 버스의 수를 기억장치의 수만큼 증가시켜 연결한 방식</li>
<li>각 기억장치마다 다른 경로를 사용 가능</li>
<li>두 개의 서로 다른 기억장치를 동시에 참조</li>
<li>장치의 연결이 복잡</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=하이퍼-큐브-연결-방식>하이퍼 큐브 연결 방식<a href=#하이퍼-큐브-연결-방식 class=hash-link aria-label="하이퍼 큐브 연결 방식에 대한 직접 링크" title="하이퍼 큐브 연결 방식에 대한 직접 링크">​</a></h3>
<ul>
<li>다수의 프로세서들을 연결하는 방식으로 비교적 경제적</li>
<li>네 개의 프로세서를 두 개 씩 서로 이웃하게 연결한 사각형 모양의 2차원 하이퍼 큐브를 만들고, 여기에 대응점을 각각 연결하여 3차원 하이퍼 큐브를 형성하고.. 계속 늘린다.</li>
<li>다수의 프로세서를 연결할 수 있으며 확장성이 좋음</li>
<li>많은 프로세서를 연결시에 비용이 급속도로 증가</li>
<li>하나의 프로세서에 연결되는 다른 프로세서의 수가 (연결점) n개일 경우 프로세서는 총 2^n개가 필요</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=다중-포트-기억장치-연결-방식>다중 포트 기억장치 연결 방식<a href=#다중-포트-기억장치-연결-방식 class=hash-link aria-label="다중 포트 기억장치 연결 방식에 대한 직접 링크" title="다중 포트 기억장치 연결 방식에 대한 직접 링크">​</a></h3>
<ul>
<li>시분할 및 공유 버스방식과 크로스바 교환 행렬 방식을 혼합한 형태의 방식</li>
<li>많은 수의 프로세서를 쉽게 연결 가능</li>
<li>다양한 연결이 가능하다.</li>
<li>전송 시간이 비교적 느림</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=다중-처리기의-운영체제-구조>다중 처리기의 운영체제 구조<a href=#다중-처리기의-운영체제-구조 class=hash-link aria-label="다중 처리기의 운영체제 구조에 대한 직접 링크" title="다중 처리기의 운영체제 구조에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=주종-처리기>주종 처리기<a href=#주종-처리기 class=hash-link aria-label="주종 처리기에 대한 직접 링크" title="주종 처리기에 대한 직접 링크">​</a></h3>
<ul>
<li>Master / Slave 처리기</li>
<li>하나의 프로세서를 Master로 지정하고 나머지는 Slave로 지정하는 구조</li>
<li>주 프로세서가 고장나면 전체 시스템 먹통</li>
<li><strong>주 프로세서만 입출력을 수행하므로 비대칭 구조</strong></li>
<li>주 프로세서<!-- -->
<ul>
<li>입출력과 연산 담당</li>
<li>운영체제 수행</li>
</ul>
</li>
<li>종 프로세서<!-- -->
<ul>
<li>연산만 담당</li>
<li>입출력발생시 주프로세서에 요청</li>
<li>사용자 프로그램만 담당</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=분리-실행-처리기>분리 실행 처리기<a href=#분리-실행-처리기 class=hash-link aria-label="분리 실행 처리기에 대한 직접 링크" title="분리 실행 처리기에 대한 직접 링크">​</a></h3>
<ul>
<li>주/종처리기의 비대칭성을 보완하여 각 프로세서가 독자적인 운영체제를 가지고 있도록 구성</li>
<li>각 프로세서에서 발생하는 인터럽트는 해당 프로세서에서 해결</li>
<li>한 프로세서에 일이 밀려있어도 다른 프로세서는 유휴상태가 될 수 있다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=대칭적-처리기>대칭적 처리기<a href=#대칭적-처리기 class=hash-link aria-label="대칭적 처리기에 대한 직접 링크" title="대칭적 처리기에 대한 직접 링크">​</a></h3>
<ul>
<li>분리 실행 처리기를 보완하여 여러 프로세서들이 완전한 기능을 갖춘 하나의 운영체제를 공유하여 수행하는 구조</li>
<li>가장 복잡하지만 가장 강력함</li>
<li>여러 개의 프로세서가 동시에 수행 가능</li>
<li>모든 프로세서가 동등한 권한을 가짐</li>
<li>메모리와 입출력장치를 공유</li>
<li>프로세서간의 통신은 공유 메모리를 통해 이루어짐</li>
<li>공유된 장치를 사용할 때 대립문제가 발생하므로 대비책 필요</li>
<li>프로세서의 수를 늘려도 시스템 효율은 향상되지 않음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=약결합-시스템>약결합 시스템<a href=#약결합-시스템 class=hash-link aria-label="약결합 시스템에 대한 직접 링크" title="약결합 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>Loosely Coupled System = 분산 처리 시스템</li>
<li>각 <strong>프로세서마다 독립된 메모리</strong>를 가진 시스템</li>
<li>둘 이상의 독립된 컴퓨터 시스템을 통신망을 통해 연결한 시스템</li>
<li>각 <strong>시스템마다 독자적인 운영체제</strong>를 가짐</li>
<li>각 시스템마다 독자적인 운영이 가능하므로 프로세서간 결합력이 약함</li>
<li>프로세서 간 통신은 메세지 전달이나 원격 프로시져 호출을 통해 이뤄짐</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=강결합-시스템>강결합 시스템<a href=#강결합-시스템 class=hash-link aria-label="강결합 시스템에 대한 직접 링크" title="강결합 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>Tightly Coupled System = 다중 처리 시스템 = 병렬 처리 시스템</li>
<li>동일 운영체제 하에서 여러 개의 프로세서가 하나의 메모리를 공유하여 사용하는 시스템</li>
<li><strong>하나의 운영체제</strong>가 모든 프로세서와 시스템 하드웨어를 제어</li>
<li>프로세서 간의 통신은 공유 메모리를 통해 이뤄짐</li>
<li><strong>하나의 메모리</strong>를 사용하므로 프로세서 간의 결합력이 강함</li>
<li>공유 메모리를 차지하는 프로세서 간의 경쟁을 최소화 해야함</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=분산-처리-시스템-1>분산 처리 시스템<a href=#분산-처리-시스템-1 class=hash-link aria-label="분산 처리 시스템에 대한 직접 링크" title="분산 처리 시스템에 대한 직접 링크">​</a></h2>
<ul>
<li>Distributed Processing System</li>
<li>약결합 시스템으로 독립적인 처리능력을 가진 컴퓨터 시스템을 통신망으로 연결한 시스템</li>
<li>사용자는 각 컴퓨터 위치를 몰라도 자원을 사용 가능</li>
<li>중앙 집중형 시스템에 비해 개발이 어려움</li>
<li><strong>보안 문제 발생</strong></li>
<li>시스템 유지상 통일성을 잃기 쉬움</li>
<li>시스템 설계가 복잡하고 데이터 처리 서비스의 질이 떨어짐</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=설계-목적>설계 목적<a href=#설계-목적 class=hash-link aria-label="설계 목적에 대한 직접 링크" title="설계 목적에 대한 직접 링크">​</a></h3>
<ul>
<li>자원 공유</li>
<li>연산 속도 향상</li>
<li>신뢰도 향상 : 여러 시스템 중 하나의 시스템에 오류가 발생해도 다른 시스템에서 처리 가능</li>
<li>컴퓨터 통신 : 지리적으로 멀어도 정보 교환 가능</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=투명성>투명성<a href=#투명성 class=hash-link aria-label="투명성에 대한 직접 링크" title="투명성에 대한 직접 링크">​</a></h3>
<ul>
<li>Transparence</li>
<li>분산 처리 운영체제에서 구체적인 시스템 환경을 사용자가 알 수 없도록 함</li>
<li>환경을 알지 못해도 원하는 작업을 수행할 수 있도록 지원</li>
<li>자원의 위치나 정보가 변경되더라도 사용자가 이를 인식하지 못하게 함</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=종류-2>종류<a href=#종류-2 class=hash-link aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크">​</a></h4>
<ul>
<li>위치 투명성 : 물리적 위치를 몰라도 자원에 접근 가능</li>
<li>이주 투명성 : 사용자나 응용 프로그램의 동작에 영향을 받지 않고 시스템 내에 있는 자원을 이동 가능</li>
<li>복제 투명성 : 자원의 복제를 사용자에게 통지할 필요 없이 자유로이 복제</li>
<li>병행 투명성 : 자원을 병행 처리하고 공유 가능</li>
<li>접근 투명성</li>
<li>성능 투명성 : 성능을 증가시키기 위해 시스템 재구성 가능</li>
<li>규모 투명성 : 시스템 구조나 알고리즘의 변경 없이 확장 가능</li>
<li>고장 투명성 : 고장이 나도 작업 가능</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=계층구조>계층구조<a href=#계층구조 class=hash-link aria-label="계층구조에 대한 직접 링크" title="계층구조에 대한 직접 링크">​</a></h3>
<ul>
<li>하드웨어 계층</li>
<li>기억장치 계층</li>
<li>프로세스 계층</li>
<li>파일시스템 계층</li>
<li>사용자 프로그램 계층</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=분산-파일-시스템>분산 파일 시스템<a href=#분산-파일-시스템 class=hash-link aria-label="분산 파일 시스템에 대한 직접 링크" title="분산 파일 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>여러 사이트에 분산되어 있는 서버, 장치, 사용자들에 대한 파일 서비스를 제공하는 시스템</li>
<li>분산 시스템이 통신망으로 연결되어 있으므로 파일 서비스는 여러 개의 기억장치에서 네트워크를 통해 이뤄짐</li>
<li>서로 다른 컴퓨터 사용자 간에 정보를 쉽게 공유 가능</li>
<li>NFS : 선 마이크로 시스템에서 개발</li>
<li>LoCUS : 캘리포니아 대에서 개발</li>
<li>Andrew : 카네기 멜론 대학에서 개발</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=분산-처리-시스템-분류>분산 처리 시스템 분류<a href=#분산-처리-시스템-분류 class=hash-link aria-label="분산 처리 시스템 분류에 대한 직접 링크" title="분산 처리 시스템 분류에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=위상에-따른-분류>위상에 따른 분류<a href=#위상에-따른-분류 class=hash-link aria-label="위상에 따른 분류에 대한 직접 링크" title="위상에 따른 분류에 대한 직접 링크">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=망형---완전-연결>망형 - 완전 연결<a href=#망형---완전-연결 class=hash-link aria-label="망형 - 완전 연결에 대한 직접 링크" title="망형 - 완전 연결에 대한 직접 링크">​</a></h4>
<ul>
<li>Full Connection</li>
<li>각 사이트들이 시스템 내의 다른 모든 사이트와 직접 연결된 구조</li>
<li>사이트 수가 n개이면 링크 수는 n(n - 1) / 2</li>
<li>모든 사이트를 연결해야 하므로 기본비용은 많이 들지만 통신비용은 적다.</li>
<li>하나의 링크가 고장나도 다른 링크를 이요하므로 신뢰성이 높다.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=망형---부분-연결>망형 - 부분 연결<a href=#망형---부분-연결 class=hash-link aria-label="망형 - 부분 연결에 대한 직접 링크" title="망형 - 부분 연결에 대한 직접 링크">​</a></h4>
<ul>
<li>Partially Connection</li>
<li>시스템 내의 일부 사이트들 간에만 직접 연결하는 구조</li>
<li>직접 연결되지 않은 사이트는 연결된 타 사이트를 통해 통신</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=트리-또는-계층형>트리 또는 계층형<a href=#트리-또는-계층형 class=hash-link aria-label="트리 또는 계층형에 대한 직접 링크" title="트리 또는 계층형에 대한 직접 링크">​</a></h4>
<ul>
<li>Tree, Hierarchy</li>
<li>분산 처리 시스템의 가장 대표적인 형태</li>
<li>각 사이트들이 트리 형태로 연결된 구조</li>
<li>부모 사이트의 자식 사이트는 그 부모 사이트를 통해 통신이 이뤄짐</li>
<li>부모 사이트가 고장나면 자식 사이트는 통신이 불가능</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=성형>성형<a href=#성형 class=hash-link aria-label="성형에 대한 직접 링크" title="성형에 대한 직접 링크">​</a></h4>
<ul>
<li>스타형</li>
<li>모든 사이트가 하나의 중앙 사이트에 직접 연결되어 있고 다른 사이트와는 연결되어 있지 않은 구조</li>
<li>기본 비용은 사이트 수에 비례하며 통신비용이 적다.</li>
<li>구조가 간단하고 보수 및 관리가 용이하다.</li>
<li>중앙 사이트가 고장나면 다 먹통</li>
<li>데이터 전송이 없는 사이트가 접속된 통신회선은 휴지 상태가 된다.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=환형>환형<a href=#환형 class=hash-link aria-label="환형에 대한 직접 링크" title="환형에 대한 직접 링크">​</a></h4>
<ul>
<li>링형</li>
<li>시스템 내의 각 사이트가 인접하는 달느 두 사이트와만 직접 연결된 구조</li>
<li>정보는 <strong>단방향 또는 양방향으로 전달 가능</strong></li>
<li>특정 사이트가 고장나면 통신이 불가능해짐</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=다중-접근-버스-연결>다중 접근 버스 연결<a href=#다중-접근-버스-연결 class=hash-link aria-label="다중 접근 버스 연결에 대한 직접 링크" title="다중 접근 버스 연결에 대한 직접 링크">​</a></h4>
<ul>
<li>Multi Access Bus Connection</li>
<li>시스템 내의 모든 사이트들이 공유 버스에 연결된 구조</li>
<li>기본 비용은 사이트 수에 비례하고 통신 비용은 일반적으로 저렴</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=범위에-따른-분류>범위에 따른 분류<a href=#범위에-따른-분류 class=hash-link aria-label="범위에 따른 분류에 대한 직접 링크" title="범위에 따른 분류에 대한 직접 링크">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=lan>LAN<a href=#lan class=hash-link aria-label="LAN에 대한 직접 링크" title="LAN에 대한 직접 링크">​</a></h4>
<ul>
<li>근거리 통신망</li>
<li>버스형이나 링형 사용</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=wan>WAN<a href=#wan class=hash-link aria-label="WAN에 대한 직접 링크" title="WAN에 대한 직접 링크">​</a></h4>
<ul>
<li>광대역 통신망</li>
<li>국가-국가간 대륙-대륙간</li>
<li>일정 지역 사이트를 근거리 통신망으로 연결 후 각 근거리 통신망을 연결하는 방식</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=프로세서-모델에-따른-분류>프로세서 모델에 따른 분류<a href=#프로세서-모델에-따른-분류 class=hash-link aria-label="프로세서 모델에 따른 분류에 대한 직접 링크" title="프로세서 모델에 따른 분류에 대한 직접 링크">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=클라이언트서버-모델>클라이언트/서버 모델<a href=#클라이언트서버-모델 class=hash-link aria-label="클라이언트/서버 모델에 대한 직접 링크" title="클라이언트/서버 모델에 대한 직접 링크">​</a></h4>
<ul>
<li>클라이언트와 서버가 하나의 작업을 분산 협동 처리 하는 방식</li>
<li>프로그램의 모듈성과 융통성을 증대</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=프로세서-풀-모델>프로세서 풀 모델<a href=#프로세서-풀-모델 class=hash-link aria-label="프로세서 풀 모델에 대한 직접 링크" title="프로세서 풀 모델에 대한 직접 링크">​</a></h4>
<ul>
<li>하나 이상의 프로세서 풀과 여러 서버가 연결된 형태</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=혼합-모델>혼합 모델<a href=#혼합-모델 class=hash-link aria-label="혼합 모델에 대한 직접 링크" title="혼합 모델에 대한 직접 링크">​</a></h4>
<ul>
<li>Hybrid Model</li>
<li>클라이언트/서버 모델과 프로세서 풀 모델을 혼합한 형태의 방식</li>
<li>사용자는 워크스테이션이나 단말기를 통해 시스템에 접근</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=운영체제에-따른-분류>운영체제에 따른 분류<a href=#운영체제에-따른-분류 class=hash-link aria-label="운영체제에 따른 분류에 대한 직접 링크" title="운영체제에 따른 분류에 대한 직접 링크">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=네트워크-운영체제>네트워크 운영체제<a href=#네트워크-운영체제 class=hash-link aria-label="네트워크 운영체제에 대한 직접 링크" title="네트워크 운영체제에 대한 직접 링크">​</a></h4>
<ul>
<li>독자적인 운영체제를 가지고 있는 시스템을 네트워크로 구성한 것</li>
<li>사용자가 원격 시스템으로 로그인하거나 원격 시스템으로부터 필요한 자원을 전달 받는 방식</li>
<li>사용자는 시스템의 각 장치에 대해 알고 있어야 함</li>
<li>지역적으로 멀리 떨어진 대규모 시스템에 사용</li>
<li>설계와 구현이 쉽다.</li>
<li>자원 공유가 번거로움</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=분산-운영체제>분산 운영체제<a href=#분산-운영체제 class=hash-link aria-label="분산 운영체제에 대한 직접 링크" title="분산 운영체제에 대한 직접 링크">​</a></h4>
<ul>
<li>하나의 운영체제가 모든 시스템 내의 자원을 관리하는 것</li>
<li>원격에 있는 자원을 마치 지역 자원인 것과 같이 쉽게 접근하여 사용하는 방식</li>
<li>사용이 편리하고 시스템 간 자원 공유가 용이</li>
<li>하나의 운영체제가 시스템 전체를 관리해야 하므로 설계와 구현이 어려움</li>
<li>요청한 컴퓨터에 요청된 컴퓨터의 자원이 이주됨으로 자원 사용 가능</li>
<li>데이터 이주<!-- -->
<ul>
<li>데이터를 요청한 사용자의 컴퓨터로 해당 데이터의 복사본을 전송 시키는 방식</li>
<li>사용자가 데이터가 필요하지 않을 경우 데이터의 복사본을 원래 컴퓨터로 돌려보냄</li>
</ul>
</li>
<li>연산 이주<!-- -->
<ul>
<li>요청한 데이터가 있는 컴퓨터에서 데이터를 처리하여 해당 결과를 요청한 컴퓨터에게 보내는 방식</li>
<li>결과를 전송시키는 것</li>
</ul>
</li>
<li>프로세스 이주 : 프로세스의 전체 또는 일부를 다른 컴퓨터에서 실행되도록 하는 방식</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=unix>UNIX<a href=#unix class=hash-link aria-label="UNIX에 대한 직접 링크" title="UNIX에 대한 직접 링크">​</a></h2>
<ul>
<li>서버 컴퓨터에서 사용되는 운영체제</li>
<li>시분할 시스템을 위해 설계된 대화식 운영체제</li>
<li>소스가 공개된 개방형 시스템</li>
<li>크기가 작고 이해하기 쉬움</li>
<li>이식성이 높고 프로세스 간 호환성이 높음</li>
<li>Multi User, Multi Tasking</li>
<li>트리 구조의 파일 시스템</li>
<li>하나 이상의 작업을 백그라운드에서 수행하므로 여러 작업을 동시 처리 가능</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=구성-3>구성<a href=#구성-3 class=hash-link aria-label="구성에 대한 직접 링크" title="구성에 대한 직접 링크">​</a></h3>
<ul>
<li>하드웨어</li>
<li>커널</li>
<li>쉘</li>
<li>유틸리티</li>
<li>사용자</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=커널>커널<a href=#커널 class=hash-link aria-label="커널에 대한 직접 링크" title="커널에 대한 직접 링크">​</a></h4>
<ul>
<li>UNIX의 핵심 부분</li>
<li>컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행</li>
<li>하드웨어를 보호하고 <strong>프로그램과 하드웨어 간의 인터페이스 역할</strong></li>
<li>프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 변환</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=쉘>쉘<a href=#쉘 class=hash-link aria-label="쉘에 대한 직접 링크" title="쉘에 대한 직접 링크">​</a></h4>
<ul>
<li>사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 <strong>명령어 해석기</strong></li>
<li><strong>시스템과 사용자 간의 인터페이스 역할</strong></li>
<li>DOS의 COMMAND.COM과 같은 기능</li>
<li><strong>보조기억장치에 명령어가 포함된 파일로 존재</strong>하며 교체처리가 가능</li>
<li>주기억장치에 상주하지 않는다.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=유틸리티>유틸리티<a href=#유틸리티 class=hash-link aria-label="유틸리티에 대한 직접 링크" title="유틸리티에 대한 직접 링크">​</a></h4>
<ul>
<li>일반 사용자가 작성한 응용 프로그램을 처리하는데 사용</li>
<li>에디터, 컴파일러, 인터프리터, 디버거</li>
<li>DOS의 외부명령어</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=프로세스간-통신>프로세스간 통신<a href=#프로세스간-통신 class=hash-link aria-label="프로세스간 통신에 대한 직접 링크" title="프로세스간 통신에 대한 직접 링크">​</a></h3>
<ul>
<li>각 프로세스는 시스템 호출을 통해 커널의 기능을 사용</li>
<li>프로세스 간 통신은 시그널, 파이프, 소켓 등을 사용</li>
<li>시그널 : 간단한 메세지를 이용하여 통신, 초기 UNIX</li>
<li>파이프 : 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신</li>
<li>소켓 : 프로세스 간의 대화를 가능하게 하는 쌍방향 통신</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=unix-파일-시스템>UNIX 파일 시스템<a href=#unix-파일-시스템 class=hash-link aria-label="UNIX 파일 시스템에 대한 직접 링크" title="UNIX 파일 시스템에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=파일-시스템-1>파일 시스템<a href=#파일-시스템-1 class=hash-link aria-label="파일 시스템에 대한 직접 링크" title="파일 시스템에 대한 직접 링크">​</a></h3>
<ul>
<li>트리 구조</li>
<li>디렉터리나 주변장치를 파일과 동일하게 취급</li>
<li>파일 생성 및 삭제, 보호 기능을 가짐</li>
<li>일반파일, 디렉터리파일, 특수파일 형식 제공</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=파일-시스템-구조>파일 시스템 구조<a href=#파일-시스템-구조 class=hash-link aria-label="파일 시스템 구조에 대한 직접 링크" title="파일 시스템 구조에 대한 직접 링크">​</a></h3>
<ul>
<li>디스크를 블록으로 분류하여 배치한 구조</li>
<li>부트 블록, 슈퍼블록, 아이노드 블록, 데이터 블록으로 구성</li>
<li>부트 블록 : 부팅 시 필요한 코드를 저장</li>
<li>슈퍼 블록 : 전체 파일 시스템에 대한 정보를 저장</li>
<li>Index-Node 블록 : 각 파일이나 디렉터리에 대한 모든 정보를 저장하고 있는 블록<!-- -->
<ul>
<li>파일 소유자의 사용자 번호 및 그룹 번호</li>
<li>파일 크기</li>
<li>파일 타입</li>
<li>생성 시기</li>
<li>최종 변경 시기</li>
<li>최근 사용 시기</li>
<li>파일 보호 권한</li>
<li>파일 링크 수</li>
<li>데이터가 저장된 블록의 시작 주소</li>
</ul>
</li>
<li>데이터 블록 : 디렉터립려로 디렉터리 엔트리와 실제 파일에 대한 데이터가 저장된 블록</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=프로세스-관련-명령어>프로세스 관련 명령어<a href=#프로세스-관련-명령어 class=hash-link aria-label="프로세스 관련 명령어에 대한 직접 링크" title="프로세스 관련 명령어에 대한 직접 링크">​</a></h3>
<ul>
<li>fork : 프로세스 생성, 하위 프로세서 호출, 프로세스 복제</li>
<li>exec : 프로세스 수행</li>
<li>exit : 프로세스 종료</li>
<li>wait : fort 후 exec에 의해 실행되는 프로세스의 상위 프로세스가 하위 프로세스 종료 등의 event를 기다림</li>
<li>kill : 프로세스 제거</li>
<li>getpid : 자신의 프로세스 아이디</li>
<li>getppid : 부모 프로세스 아이디</li>
<li>& : 백그라운드 처리를 위해 명령의 끝에 입력</li>
<li>signal : 신호를 받았을 때 프로세스가 취할 동작 지정</li>
<li>pipe : 프로세스 간 통신을 위한 경로 설정</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=파일-및-디렉터리-명령어>파일 및 디렉터리 명령어<a href=#파일-및-디렉터리-명령어 class=hash-link aria-label="파일 및 디렉터리 명령어에 대한 직접 링크" title="파일 및 디렉터리 명령어에 대한 직접 링크">​</a></h3>
<ul>
<li>creat : 파일 생성</li>
<li>open : 파일을 사용할 수 있는 상태로 준비</li>
<li>close : 파일 닫기</li>
<li>cp : 복사</li>
<li>mv : 파일 이동 또는 이름 변경</li>
<li>rm : 파일 삭제</li>
<li>cat : 파일 내용 표시</li>
<li>chmod : 파일 사용 허가 지정</li>
<li>chown : 소유자 변경</li>
<li>find : 파일 찾기</li>
<li>mknod : 특수 파일 생성</li>
<li>mount : 파일 시스템 마운팅</li>
<li>mkfs : 파일 시스템 생성</li>
<li>fsck : 파일 시스템 검사</li>
<li>mkdir : 디렉터리 생성</li>
<li>chdir : 디렉터리 위치 변경</li>
<li>rmdir : 디렉터리 삭제</li>
<li>ls : 디렉터리 파일 목록 확인</li>
<li>finger : 사용자 정보 표시</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=windows>Windows<a href=#windows class=hash-link aria-label="Windows에 대한 직접 링크" title="Windows에 대한 직접 링크">​</a></h2>
<ul>
<li>GUI</li>
<li>선점형 멀티태스킹 : 동시에 여러 개의 프로그램을 실행하는 멀티 프로그래밍을 하면서 운영체제가 각 작업의 CPU 이용시간을 제어하여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 방식</li>
<li>FAT 32 파일 시스템 사용</li>
<li>Plug and Play</li>
<li>OLE 사용 : 다른 여러 프로그램에서 작성된 문자가 르미 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입하여 편집할 수 있는 기능</li>
<li>255자의 긴 파일명</li>
<li>Single User 시스템</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_B5Wd" id=ms-dos>MS-DOS<a href=#ms-dos class=hash-link aria-label="MS-DOS에 대한 직접 링크" title="MS-DOS에 대한 직접 링크">​</a></h2>
<ul>
<li>CUI</li>
<li>Single User</li>
<li>Single Tasking</li>
<li>시스템 파일 : 도스의 핵심파일로 주변장치의 입출력과 시스템 전체를 통제, MSDOS.SYS와 IO.SYS가 있다.</li>
<li>명령어 처리기 : COMMAND.COM</li>
<li>자동 일괄 처리 파일 : AUTOEXEC.BAT</li>
<li>환경 설정 파일 : CONFIG.SYS</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_B5Wd" id=명령어>명령어<a href=#명령어 class=hash-link aria-label="명령어에 대한 직접 링크" title="명령어에 대한 직접 링크">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=내부-명령어>내부 명령어<a href=#내부-명령어 class=hash-link aria-label="내부 명령어에 대한 직접 링크" title="내부 명령어에 대한 직접 링크">​</a></h4>
<ul>
<li>COMMAND.COM에 포함되어 있고 메모리에 항상 상주되어 있다.</li>
<li>DIR : 파일 목록 표시</li>
<li>COPY : 복사</li>
<li>TYPE : 파일 내용 표시 (like cat)</li>
<li>REN : 파일 이름 변경</li>
<li>DEL : 파일 삭제</li>
<li>MD : 디렉터리 생성</li>
<li>CD : 디렉터리 위치 변경</li>
<li>RD : 디렉터리 삭제</li>
<li>CLS : 화면 내용을 지움</li>
<li>VER : 버전 표시 (like uname)</li>
<li>PATH : 파일 탐색 경로 지정</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_B5Wd" id=외부-명령어>외부 명령어<a href=#외부-명령어 class=hash-link aria-label="외부 명령어에 대한 직접 링크" title="외부 명령어에 대한 직접 링크">​</a></h4>
<ul>
<li>실행과정이 복잡하거나 자주 사요하지 않는 것</li>
<li>디스크에 파일로 저장</li>
<li>처리속도가 느림</li>
<li>UNDELETE : 삭제한 파일 복원</li>
<li>SYS : 시스템 파일 복사</li>
<li>ATTRIB : 파일 속성 변경 (like chmod)</li>
<li>MOVE : 파일 이동</li>
<li>FIND : 파일 찾기</li>
<li>FORMAT : 포맷</li>
<li>UNFORMAT : 포맷한 디스크를 복원</li>
<li>CHKDSK : 디스크 상태 점검 (like df)</li>
<li>DISKCOPY : 디스크 단위 복사</li>
<li>DISKCOMP : 디스크 비교</li>
</ul></div><footer class=docusaurus-mt-lg><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class=col><b>태그:</b><ul class="tags_qhWe padding--none margin-left--sm"><li class=tag_iafL><a rel=tag title="Engineer Information Processing" class="tag_GpwW tagRegular_I5Y7" href=/tags/정보처리/>정보처리</a></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href=/2017/02/12/소프트웨어-공학-정리/><div class=pagination-nav__sublabel>이전 게시물</div><div class=pagination-nav__label>소프트웨어 공학 정리</div></a><a class="pagination-nav__link pagination-nav__link--next" href=/2017/02/06/npm-version-update/><div class=pagination-nav__sublabel>다음 게시물</div><div class=pagination-nav__label>npm 업데이트시 npm 폴더가 사라졌을 때</div></a></nav></main><div class="col col--2"><div class="tableOfContents_KUGQ thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#시스템-소프트웨어 class="table-of-contents__link toc-highlight">시스템 소프트웨어</a><ul><li><a href=#구성 class="table-of-contents__link toc-highlight">구성</a><li><a href=#제어-프로그램 class="table-of-contents__link toc-highlight">제어 프로그램</a><li><a href=#처리-프로그램 class="table-of-contents__link toc-highlight">처리 프로그램</a></ul><li><a href=#운영체제 class="table-of-contents__link toc-highlight">운영체제</a><ul><li><a href=#목적 class="table-of-contents__link toc-highlight">목적</a><li><a href=#기능 class="table-of-contents__link toc-highlight">기능</a><li><a href=#자원관리 class="table-of-contents__link toc-highlight">자원관리</a><li><a href=#종류 class="table-of-contents__link toc-highlight">종류</a></ul><li><a href=#운영체제-운용-기법 class="table-of-contents__link toc-highlight">운영체제 운용 기법</a><ul><li><a href=#일괄-처리-시스템 class="table-of-contents__link toc-highlight">일괄 처리 시스템</a><li><a href=#다중-프로그래밍-시스템 class="table-of-contents__link toc-highlight">다중 프로그래밍 시스템</a><li><a href=#시분할-시스템 class="table-of-contents__link toc-highlight">시분할 시스템</a><li><a href=#다중-처리-시스템 class="table-of-contents__link toc-highlight">다중 처리 시스템</a><li><a href=#실시간-처리-시스템 class="table-of-contents__link toc-highlight">실시간 처리 시스템</a><li><a href=#다중-모드-처리 class="table-of-contents__link toc-highlight">다중 모드 처리</a><li><a href=#분산-처리-시스템 class="table-of-contents__link toc-highlight">분산 처리 시스템</a><li><a href=#발달과정 class="table-of-contents__link toc-highlight">발달과정</a></ul><li><a href=#컴파일러와-인터프리터 class="table-of-contents__link toc-highlight">컴파일러와 인터프리터</a><ul><li><a href=#저급-언어 class="table-of-contents__link toc-highlight">저급 언어</a><li><a href=#고급-언어 class="table-of-contents__link toc-highlight">고급 언어</a><li><a href=#컴파일러 class="table-of-contents__link toc-highlight">컴파일러</a><li><a href=#인터프리터 class="table-of-contents__link toc-highlight">인터프리터</a></ul><li><a href=#어셈블리어-1 class="table-of-contents__link toc-highlight">어셈블리어</a><ul><li><a href=#형식 class="table-of-contents__link toc-highlight">형식</a><li><a href=#어셈블러 class="table-of-contents__link toc-highlight">어셈블러</a></ul><li><a href=#매크로 class="table-of-contents__link toc-highlight">매크로</a><ul><li><a href=#부프로그램과-비교 class="table-of-contents__link toc-highlight">부프로그램과 비교</a><li><a href=#매크로-프로세서 class="table-of-contents__link toc-highlight">매크로 프로세서</a></ul><li><a href=#링커 class="table-of-contents__link toc-highlight">링커</a><li><a href=#로더 class="table-of-contents__link toc-highlight">로더</a><ul><li><a href=#기능-1 class="table-of-contents__link toc-highlight">기능</a><li><a href=#종류-1 class="table-of-contents__link toc-highlight">종류</a></ul><li><a href=#프로세스 class="table-of-contents__link toc-highlight">프로세스</a><ul><li><a href=#pcb class="table-of-contents__link toc-highlight">PCB</a><li><a href=#프로세스-상태 class="table-of-contents__link toc-highlight">프로세스 상태</a><li><a href=#스레드 class="table-of-contents__link toc-highlight">스레드</a></ul><li><a href=#스케쥴링 class="table-of-contents__link toc-highlight">스케쥴링</a><ul><li><a href=#목적-1 class="table-of-contents__link toc-highlight">목적</a><li><a href=#성능-평가-기준 class="table-of-contents__link toc-highlight">성능 평가 기준</a><li><a href=#비선점-스케쥴링 class="table-of-contents__link toc-highlight">비선점 스케쥴링</a><li><a href=#선점-스케쥴링 class="table-of-contents__link toc-highlight">선점 스케쥴링</a></ul><li><a href=#비선점-스케쥴링-1 class="table-of-contents__link toc-highlight">비선점 스케쥴링</a><ul><li><a href=#fcfs class="table-of-contents__link toc-highlight">FCFS</a><li><a href=#sjf class="table-of-contents__link toc-highlight">SJF</a><li><a href=#hrn class="table-of-contents__link toc-highlight">HRN</a><li><a href=#기한부 class="table-of-contents__link toc-highlight">기한부</a><li><a href=#우선순위 class="table-of-contents__link toc-highlight">우선순위</a><li><a href=#에이징 class="table-of-contents__link toc-highlight">에이징</a></ul><li><a href=#선점-스케쥴링-1 class="table-of-contents__link toc-highlight">선점 스케쥴링</a><ul><li><a href=#선점-우선순위 class="table-of-contents__link toc-highlight">선점 우선순위</a><li><a href=#srt class="table-of-contents__link toc-highlight">SRT</a><li><a href=#rr class="table-of-contents__link toc-highlight">RR</a><li><a href=#다단계-큐 class="table-of-contents__link toc-highlight">다단계 큐</a><li><a href=#다단계-피드백-큐 class="table-of-contents__link toc-highlight">다단계 피드백 큐</a></ul><li><a href=#병행-프로세스 class="table-of-contents__link toc-highlight">병행 프로세스</a><ul><li><a href=#임계구역 class="table-of-contents__link toc-highlight">임계구역</a><li><a href=#상호-배제-기법 class="table-of-contents__link toc-highlight">상호 배제 기법</a><li><a href=#동기화-기법 class="table-of-contents__link toc-highlight">동기화 기법</a></ul><li><a href=#교착상태 class="table-of-contents__link toc-highlight">교착상태</a><ul><li><a href=#필요-충분-조건 class="table-of-contents__link toc-highlight">필요 충분 조건</a><li><a href=#예방기법 class="table-of-contents__link toc-highlight">예방기법</a><li><a href=#회피기법 class="table-of-contents__link toc-highlight">회피기법</a><li><a href=#발견기법 class="table-of-contents__link toc-highlight">발견기법</a><li><a href=#회복기법 class="table-of-contents__link toc-highlight">회복기법</a></ul><li><a href=#기억장치-관리 class="table-of-contents__link toc-highlight">기억장치 관리</a><ul><li><a href=#반입-전략 class="table-of-contents__link toc-highlight">반입 전략</a><li><a href=#배치-전략 class="table-of-contents__link toc-highlight">배치 전략</a><li><a href=#교체-전략 class="table-of-contents__link toc-highlight">교체 전략</a></ul><li><a href=#주기억장치-할당-기법 class="table-of-contents__link toc-highlight">주기억장치 할당 기법</a><ul><li><a href=#단일-분할-할당-기법 class="table-of-contents__link toc-highlight">단일 분할 할당 기법</a><li><a href=#오버레이-기법 class="table-of-contents__link toc-highlight">오버레이 기법</a><li><a href=#스와핑-기법 class="table-of-contents__link toc-highlight">스와핑 기법</a><li><a href=#다중-분할-할당-기법 class="table-of-contents__link toc-highlight">다중 분할 할당 기법</a><li><a href=#가변-분할-할당 class="table-of-contents__link toc-highlight">가변 분할 할당</a></ul><li><a href=#단편화 class="table-of-contents__link toc-highlight">단편화</a><ul><li><a href=#해결방법 class="table-of-contents__link toc-highlight">해결방법</a></ul><li><a href=#가상기억장치 class="table-of-contents__link toc-highlight">가상기억장치</a><ul><li><a href=#페이징-기법 class="table-of-contents__link toc-highlight">페이징 기법</a></ul><li><a href=#세그먼테이션-기법 class="table-of-contents__link toc-highlight">세그먼테이션 기법</a><li><a href=#페이지-교체-알고리즘 class="table-of-contents__link toc-highlight">페이지 교체 알고리즘</a><ul><li><a href=#opt class="table-of-contents__link toc-highlight">OPT</a><li><a href=#fifo class="table-of-contents__link toc-highlight">FIFO</a><li><a href=#lru class="table-of-contents__link toc-highlight">LRU</a><li><a href=#lfu class="table-of-contents__link toc-highlight">LFU</a><li><a href=#nur class="table-of-contents__link toc-highlight">NUR</a><li><a href=#scr class="table-of-contents__link toc-highlight">SCR</a></ul><li><a href=#가상기억장치-관리 class="table-of-contents__link toc-highlight">가상기억장치 관리</a><ul><li><a href=#페이지-크기 class="table-of-contents__link toc-highlight">페이지 크기</a><li><a href=#locality class="table-of-contents__link toc-highlight">Locality</a><li><a href=#워킹-셋 class="table-of-contents__link toc-highlight">워킹 셋</a><li><a href=#페이지-부재-빈도-방식 class="table-of-contents__link toc-highlight">페이지 부재 빈도 방식</a><li><a href=#프리페이징 class="table-of-contents__link toc-highlight">프리페이징</a><li><a href=#스래싱 class="table-of-contents__link toc-highlight">스래싱</a></ul><li><a href=#디스크-스케쥴링 class="table-of-contents__link toc-highlight">디스크 스케쥴링</a><ul><li><a href=#fcfs-1 class="table-of-contents__link toc-highlight">FCFS</a><li><a href=#sstf class="table-of-contents__link toc-highlight">SSTF</a><li><a href=#scan class="table-of-contents__link toc-highlight">SCAN</a><li><a href=#c-scan class="table-of-contents__link toc-highlight">C-SCAN</a><li><a href=#lock class="table-of-contents__link toc-highlight">LOCK</a><li><a href=#c-lock class="table-of-contents__link toc-highlight">C-LOCK</a><li><a href=#n-scan class="table-of-contents__link toc-highlight">N-SCAN</a><li><a href=#eschenbach class="table-of-contents__link toc-highlight">Eschenbach</a><li><a href=#sltf class="table-of-contents__link toc-highlight">SLTF</a></ul><li><a href=#파일 class="table-of-contents__link toc-highlight">파일</a><ul><li><a href=#파일-시스템 class="table-of-contents__link toc-highlight">파일 시스템</a><li><a href=#파일-디스크립터 class="table-of-contents__link toc-highlight">파일 디스크립터</a></ul><li><a href=#파일-구조 class="table-of-contents__link toc-highlight">파일 구조</a><ul><li><a href=#순차-파일 class="table-of-contents__link toc-highlight">순차 파일</a><li><a href=#직접-파일 class="table-of-contents__link toc-highlight">직접 파일</a><li><a href=#색인-순차-파일 class="table-of-contents__link toc-highlight">색인 순차 파일</a><li><a href=#분할파일 class="table-of-contents__link toc-highlight">분할파일</a></ul><li><a href=#디렉터리-구조 class="table-of-contents__link toc-highlight">디렉터리 구조</a><ul><li><a href=#1단계-디렉터리-구조 class="table-of-contents__link toc-highlight">1단계 디렉터리 구조</a><li><a href=#2단계-디렉터리-구조 class="table-of-contents__link toc-highlight">2단계 디렉터리 구조</a><li><a href=#트리-디렉터리-구조 class="table-of-contents__link toc-highlight">트리 디렉터리 구조</a><li><a href=#비순환-그래프-디렉터리-구조 class="table-of-contents__link toc-highlight">비순환 그래프 디렉터리 구조</a><li><a href=#일반적인-그래프-디렉터리-구조 class="table-of-contents__link toc-highlight">일반적인 그래프 디렉터리 구조</a></ul><li><a href=#디스크-공간-할당-방법 class="table-of-contents__link toc-highlight">디스크 공간 할당 방법</a><ul><li><a href=#연속-할당 class="table-of-contents__link toc-highlight">연속 할당</a><li><a href=#불연속-할당 class="table-of-contents__link toc-highlight">불연속 할당</a></ul><li><a href=#자원-보호 class="table-of-contents__link toc-highlight">자원 보호</a><ul><li><a href=#접근-제어-행렬-기법 class="table-of-contents__link toc-highlight">접근 제어 행렬 기법</a><li><a href=#전역-테이블-기법 class="table-of-contents__link toc-highlight">전역 테이블 기법</a><li><a href=#접근-제어-리스트 class="table-of-contents__link toc-highlight">접근 제어 리스트</a><li><a href=#권한-리스트-기법 class="table-of-contents__link toc-highlight">권한 리스트 기법</a><li><a href=#lock-key-기법 class="table-of-contents__link toc-highlight">Lock-Key 기법</a><li><a href=#파일-보호-기법 class="table-of-contents__link toc-highlight">파일 보호 기법</a></ul><li><a href=#보안 class="table-of-contents__link toc-highlight">보안</a><ul><li><a href=#보안-요건 class="table-of-contents__link toc-highlight">보안 요건</a><li><a href=#보안-유지-기법 class="table-of-contents__link toc-highlight">보안 유지 기법</a><li><a href=#보안-위험-감소-방법 class="table-of-contents__link toc-highlight">보안 위험 감소 방법</a></ul><li><a href=#정보-보안-기법 class="table-of-contents__link toc-highlight">정보 보안 기법</a><ul><li><a href=#비밀키-시스템 class="table-of-contents__link toc-highlight">비밀키 시스템</a><li><a href=#공용키-시스템 class="table-of-contents__link toc-highlight">공용키 시스템</a><li><a href=#디지털-서명-기법 class="table-of-contents__link toc-highlight">디지털 서명 기법</a><li><a href=#여분-정보-삽입-기법 class="table-of-contents__link toc-highlight">여분 정보 삽입 기법</a><li><a href=#인증-교환-기법 class="table-of-contents__link toc-highlight">인증 교환 기법</a><li><a href=#접근-제어-기법 class="table-of-contents__link toc-highlight">접근 제어 기법</a><li><a href=#fault-tolerant-system class="table-of-contents__link toc-highlight">Fault Tolerant System</a></ul><li><a href=#다중-처리기 class="table-of-contents__link toc-highlight">다중 처리기</a><ul><li><a href=#시분할-및-공유-버스-연결-방식 class="table-of-contents__link toc-highlight">시분할 및 공유 버스 연결 방식</a><li><a href=#크로스바-교환-행렬-연결-방식 class="table-of-contents__link toc-highlight">크로스바 교환 행렬 연결 방식</a><li><a href=#하이퍼-큐브-연결-방식 class="table-of-contents__link toc-highlight">하이퍼 큐브 연결 방식</a><li><a href=#다중-포트-기억장치-연결-방식 class="table-of-contents__link toc-highlight">다중 포트 기억장치 연결 방식</a></ul><li><a href=#다중-처리기의-운영체제-구조 class="table-of-contents__link toc-highlight">다중 처리기의 운영체제 구조</a><ul><li><a href=#주종-처리기 class="table-of-contents__link toc-highlight">주종 처리기</a><li><a href=#분리-실행-처리기 class="table-of-contents__link toc-highlight">분리 실행 처리기</a><li><a href=#대칭적-처리기 class="table-of-contents__link toc-highlight">대칭적 처리기</a><li><a href=#약결합-시스템 class="table-of-contents__link toc-highlight">약결합 시스템</a><li><a href=#강결합-시스템 class="table-of-contents__link toc-highlight">강결합 시스템</a></ul><li><a href=#분산-처리-시스템-1 class="table-of-contents__link toc-highlight">분산 처리 시스템</a><ul><li><a href=#설계-목적 class="table-of-contents__link toc-highlight">설계 목적</a><li><a href=#투명성 class="table-of-contents__link toc-highlight">투명성</a><li><a href=#계층구조 class="table-of-contents__link toc-highlight">계층구조</a><li><a href=#분산-파일-시스템 class="table-of-contents__link toc-highlight">분산 파일 시스템</a></ul><li><a href=#분산-처리-시스템-분류 class="table-of-contents__link toc-highlight">분산 처리 시스템 분류</a><ul><li><a href=#위상에-따른-분류 class="table-of-contents__link toc-highlight">위상에 따른 분류</a><li><a href=#범위에-따른-분류 class="table-of-contents__link toc-highlight">범위에 따른 분류</a><li><a href=#프로세서-모델에-따른-분류 class="table-of-contents__link toc-highlight">프로세서 모델에 따른 분류</a><li><a href=#운영체제에-따른-분류 class="table-of-contents__link toc-highlight">운영체제에 따른 분류</a></ul><li><a href=#unix class="table-of-contents__link toc-highlight">UNIX</a><ul><li><a href=#구성-3 class="table-of-contents__link toc-highlight">구성</a><li><a href=#프로세스간-통신 class="table-of-contents__link toc-highlight">프로세스간 통신</a></ul><li><a href=#unix-파일-시스템 class="table-of-contents__link toc-highlight">UNIX 파일 시스템</a><ul><li><a href=#파일-시스템-1 class="table-of-contents__link toc-highlight">파일 시스템</a><li><a href=#파일-시스템-구조 class="table-of-contents__link toc-highlight">파일 시스템 구조</a><li><a href=#프로세스-관련-명령어 class="table-of-contents__link toc-highlight">프로세스 관련 명령어</a><li><a href=#파일-및-디렉터리-명령어 class="table-of-contents__link toc-highlight">파일 및 디렉터리 명령어</a></ul><li><a href=#windows class="table-of-contents__link toc-highlight">Windows</a><li><a href=#ms-dos class="table-of-contents__link toc-highlight">MS-DOS</a><ul><li><a href=#명령어 class="table-of-contents__link toc-highlight">명령어</a></ul></ul></div></div></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class=footer__title>Support Me</div><ul class="footer__items clean-list"><li class=footer__item><a href=https://www.buymeacoffee.com/LOUB2kN target=_blank rel="noopener noreferrer" style="cursor: pointer;">
                <img src=https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png style="height: auto !important;width: auto !important;">
              </a></ul></div><div class="theme-layout-footer-column col footer__col"><div class=footer__title>Feeds</div><ul class="footer__items clean-list"><li class=footer__item><a href=https://gracefullight.dev/rss.xml target=_blank rel="noopener noreferrer" class=footer__link-item>RSS<svg width=13.5 height=13.5 aria-hidden=true class=iconExternalLink_BHrW><use href=#theme-svg-external-link /></svg></a><li class=footer__item><a href=https://gracefullight.dev/atom.xml target=_blank rel="noopener noreferrer" class=footer__link-item>Atom<svg width=13.5 height=13.5 aria-hidden=true class=iconExternalLink_BHrW><use href=#theme-svg-external-link /></svg></a></ul></div></div><div class="footer__bottom text--center"><div class=footer__copyright>Copyright © 2016-2025 Eunkwang Shin.</div></div></div></footer></div>