<!doctype html><html lang=ko dir=ltr class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated=false><head><meta charset=UTF-8><meta name=generator content="Docusaurus v3.9.2"><title data-rh=true>전자계산기 구조 정리 | gracefullight.dev</title><meta data-rh=true name=viewport content="width=device-width, initial-scale=1.0"/><meta data-rh=true name=twitter:card content=summary_large_image /><meta data-rh=true property=og:url content=https://gracefullight.dev/2017/01/30/전자계산기-구조-정리/ /><meta data-rh=true property=og:locale content=ko /><meta data-rh=true property=og:locale:alternate content=en /><meta data-rh=true name=docusaurus_locale content=ko /><meta data-rh=true name=docusaurus_tag content=default /><meta data-rh=true name=docsearch:language content=ko /><meta data-rh=true name=docsearch:docusaurus_tag content=default /><meta data-rh=true content=gcY9SiftHgQoJjBZ7IgwNNN5_atLPAX6kWb1nFVfa6E name=google-site-verification /><meta data-rh=true content=65AD1E28C0D057CEB3C68FBC0293E55B name=msvalidate.01 /><meta data-rh=true content=d024c2837887f72dc7b3792b958be74d69ba9593 name=naver-site-verification /><meta data-rh=true content=f7c93483a6f87c79 name=yandex-verification /><meta data-rh=true content=yZEdU1ABcR name=baidu-site-verification /><meta data-rh=true content=uelupjqqsm5egzlhy1aev2rfxow5yt name=facebook-domain-verification /><meta data-rh=true property=og:title content="전자계산기 구조 정리 | gracefullight.dev"/><meta data-rh=true name=description content="불 대수"/><meta data-rh=true property=og:description content="불 대수"/><meta data-rh=true property=og:type content=article /><meta data-rh=true property=article:published_time content=2017-01-30T00:35:16.000Z /><meta data-rh=true property=article:author content=https://github.com/gracefullight /><meta data-rh=true property=article:tag content=정보처리 /><link data-rh=true rel=icon href=/img/favicon.ico /><link data-rh=true rel=canonical href=https://gracefullight.dev/2017/01/30/전자계산기-구조-정리/ /><link data-rh=true rel=alternate href=https://gracefullight.dev/2017/01/30/전자계산기-구조-정리/ hreflang=ko /><link data-rh=true rel=alternate href=https://gracefullight.dev/en/2017/01/30/전자계산기-구조-정리/ hreflang=en /><link data-rh=true rel=alternate href=https://gracefullight.dev/2017/01/30/전자계산기-구조-정리/ hreflang=x-default /><link data-rh=true rel=preconnect href=https://RFS69RSYOJ-dsn.algolia.net crossorigin=anonymous /><script data-rh=true type=application/ld+json>{"@context":"https://schema.org","@id":"https://gracefullight.dev/2017/01/30/전자계산기-구조-정리","@type":"BlogPosting","author":{"@type":"Person","description":"Owner","image":"https://avatars.githubusercontent.com/u/11773683?v=4","name":"Eunkwang Shin","url":"https://github.com/gracefullight"},"datePublished":"2017-01-30T00:35:16.000Z","description":"불 대수","headline":"전자계산기 구조 정리","isPartOf":{"@id":"https://gracefullight.dev/","@type":"Blog","name":"Blog"},"keywords":[],"mainEntityOfPage":"https://gracefullight.dev/2017/01/30/전자계산기-구조-정리","name":"전자계산기 구조 정리","url":"https://gracefullight.dev/2017/01/30/전자계산기-구조-정리"}</script><link rel=alternate type=application/rss+xml href=/rss.xml title="gracefullight.dev RSS Feed"><link rel=alternate type=application/atom+xml href=/atom.xml title="gracefullight.dev Atom Feed"><link rel=alternate type=application/json href=/feed.json title="gracefullight.dev JSON Feed"><link rel=preconnect href=https://www.google-analytics.com><link rel=preconnect href=https://www.googletagmanager.com><script async src="https://www.googletagmanager.com/gtag/js?id=G-E99DNE7S05"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-E99DNE7S05",{})</script><link rel=search type=application/opensearchdescription+xml title=gracefullight.dev href=/opensearch.xml><link href=/img/favicon-32x32.png rel=icon><link href=/manifest.json rel=manifest><meta content=#f28913 name=theme-color><meta content=yes name=mobile-web-app-capable><meta content=#f28913 name=apple-mobile-web-app-status-bar-style><link href=/img/apple-touch-icon.png rel=apple-touch-icon><link rel=preconnect href=https://pagead2.googlesyndication.com><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3004788392777865" async crossorigin=anonymous></script><link rel=preconnect href=https://www.clarity.ms><script>!function(t,e,n,a,c,i,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(i=e.createElement(a)).async=1,i.src="https://www.clarity.ms/tag/"+c,(r=e.getElementsByTagName(a)[0]).parentNode.insertBefore(i,r)}(window,document,"clarity","script","aongv9xgi6")</script><link rel=preconnect href=https://wcs.naver.net><script src=https://wcs.naver.net/wcslog.js async></script><script>if(!wcs_add)var wcs_add={};wcs_add.wa="156bc73a81e3bd0",window.wcs&&wcs_do()</script><link rel=preconnect href=https://cdn.channel.io><script>!function(){var n=window;if(n.ChannelIO)return(window.console.error||window.console.log||function(){})("ChannelIO script included twice.");var e=function(){e.c(arguments)};function t(){if(!n.ChannelIOInitialized){n.ChannelIOInitialized=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://cdn.channel.io/plugin/ch-plugin-web.js",e.charset="UTF-8";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}}e.q=[],e.c=function(n){e.q.push(n)},n.ChannelIO=e,"complete"===document.readyState?t():window.attachEvent?window.attachEvent("onload",t):(window.addEventListener("DOMContentLoaded",t,!1),window.addEventListener("load",t,!1))}(),ChannelIO("boot",{pluginKey:"0fd130ba-a1a6-4b7e-802a-e82a885a7fd8"})</script><link rel=preconnect href=https://static.cloudflareinsights.com><script src=https://static.cloudflareinsights.com/beacon.min.js defer data-cf-beacon='{"token":"c0899829e72b45e98dff77241127252c"}'></script><link href=https://mc.yandex.ru rel=preconnect><script>!function(e,t,c,n,r,a,s){e[r]=e[r]||function(){(e[r].a=e[r].a||[]).push(arguments)},e[r].l=+new Date;for(var i=0;i<document.scripts.length;i++)if(document.scripts[i].src===n)return;a=t.createElement(c),s=t.getElementsByTagName(c)[0],a.async=1,a.src=n,s.parentNode.insertBefore(a,s)}(window,document,"script","https://mc.yandex.ru/metrika/tag.js?id=104072655","ym"),ym(0x63405cf,"init",{ssr:!0,clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!1})</script><link href=https://cdn.jsdelivr.net rel=preconnect><script type=application/ld+json>{"@context":"http://schema.org","@type":"Person","email":"mailto:gracefullight.dev@gmail.com","image":"https://avatars.githubusercontent.com/u/11773683?v=4","jobTitle":"FullStack JavaScript Developer","logo":"https://gracefullight.dev/img/apple-touch-icon.png","name":"Eunkwang Shin","nationality":"Korean","sameAs":["https://github.com/gracefullight","https://linkedin.com/in/gracefullight"],"url":"https://gracefullight.dev"}</script><link rel=stylesheet crossorigin=anonymous href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css type=text/css><link rel=stylesheet href=/assets/css/styles.775e2857.css /><script src=/assets/js/runtime~main.8c99d553.js defer></script><script src=/assets/js/main.55b7c064.js defer></script></head><body class=navigation-with-keyboard><svg style="display: none;"><defs>
<symbol id=theme-svg-external-link viewBox="0 0 24 24"><path fill=currentColor d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><link rel=preload as=image href=/img/favicon-32x32.png /><link rel=preload as=image href="https://avatars.githubusercontent.com/u/11773683?v=4"/><div role=region aria-label="본문으로 건너뛰기"><a class=skipToContent_fXgn href=#__docusaurus_skipToContent_fallback>본문으로 건너뛰기</a></div><nav aria-label=Main class="theme-layout-navbar navbar navbar--fixed-top"><div class=navbar__inner><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/><div class=navbar__logo><img src=/img/favicon-32x32.png alt="gracefullight.dev blog logo" class="themedComponent_mlkZ themedComponent--light_NVdE"/><img src=/img/favicon-32x32.png alt="gracefullight.dev blog logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"/></div><b class="navbar__title text--truncate">gracefullight.dev</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href=# aria-haspopup=true aria-expanded=false role=button class=navbar__link><svg viewBox="0 0 24 24" width=20 height=20 aria-hidden=true class=iconLanguage_nlXk><path fill=currentColor d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/></svg>한국어</a><ul class=dropdown__menu><li><a href=/2017/01/30/전자계산기-구조-정리/ target=_self rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang=ko>한국어</a><li><a href=/en/2017/01/30/전자계산기-구조-정리/ target=_self rel="noopener noreferrer" class=dropdown__link lang=en>English</a></ul></div><a class="navbar__item navbar__link" href=/archive/>Archives</a><a class="navbar__item navbar__link" href=/tags/>Tags</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href=https://github.com/gracefullight target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type=button disabled title="system mode" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 system mode)"><svg viewBox="0 0 24 24" width=24 height=24 aria-hidden=true class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill=currentColor d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"/></svg><svg viewBox="0 0 24 24" width=24 height=24 aria-hidden=true class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill=currentColor d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"/></svg><svg viewBox="0 0 24 24" width=24 height=24 aria-hidden=true class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill=currentColor d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"/></svg></button></div><div class=navbarSearchContainer_Bca1><button type=button class="DocSearch DocSearch-Button" aria-label="검색 (Meta+k)" aria-keyshortcuts=Meta+k><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 24 24" aria-hidden=true><circle cx=11 cy=11 r=8 stroke=currentColor fill=none stroke-width=1.4 /><path d="m21 21-4.3-4.3" stroke=currentColor fill=none stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>검색</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class=row><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">최근 포스트</div><div role=group><h3 class=yearGroupHeading_rMGB>2026</h3><ul class="sidebarItemList_Yudw clean-list"><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/2026/02/27/free-up-storage-space-on-mac/>Free up storage space on mac</a><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/2026/02/27/promoting-an-opensource-project/>Promoting an opensource project</a><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/2026/02/24/iqc-002/>IQC 002</a><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/2026/02/23/tim-002/>TIM 002</a><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/2026/02/17/innovation-tactics/>Innovation Tactics</a><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/2026/01/31/agentic-sdlc/>Agentic SDLC</a><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/2026/01/29/local-docker-env/>로컬 도커 환경 툴 비교</a><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/vocab/phrasal-verbs-01/>Phrasal Verbs 01</a><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/vocab/phrasal-verbs-014/>Phrasal Verbs 014</a><li class=sidebarItem__DBe><a class=sidebarItemLink_mo7H href=/vocab/phrasal-verbs-013/>Phrasal Verbs 013</a></ul></div></nav></aside><main class="col col--7"><article class=""><header><h1 class=title_f1Hy>전자계산기 구조 정리</h1><div class="container_mt6G margin-vert--md"><time datetime=2017-01-30T00:35:16.000Z>2017년 1월 30일</time> · <!-- -->약 37분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a class=avatar__photo-link href=/authors/me/><img class="avatar__photo authorImage_XqGP" src="https://avatars.githubusercontent.com/u/11773683?v=4" alt="Eunkwang Shin"/></a><div class="avatar__intro authorDetails_lV9A"><div class=avatar__name><a href=/authors/me/><span class=authorName_yefp translate=no>Eunkwang Shin</span></a></div><small class=authorTitle_nd0D title=Owner>Owner</small><div class=authorSocials_rSDt><a href=https://www.linkedin.com/in/gracefullight/ target=_blank rel="noopener noreferrer" class=authorSocialLink_owbf title=LinkedIn><svg xmlns=http://www.w3.org/2000/svg width=1em height=1em preserveAspectRatio=xMidYMid viewBox="0 0 256 256" style=--dark:#0a66c2;--light:#ffffffe6 class="authorSocialIcon_XYv3 linkedinSvg_FCgI"><path d="M218.123 218.127h-37.931v-59.403c0-14.165-.253-32.4-19.728-32.4-19.756 0-22.779 15.434-22.779 31.369v60.43h-37.93V95.967h36.413v16.694h.51a39.907 39.907 0 0 1 35.928-19.733c38.445 0 45.533 25.288 45.533 58.186l-.016 67.013ZM56.955 79.27c-12.157.002-22.014-9.852-22.016-22.009-.002-12.157 9.851-22.014 22.008-22.016 12.157-.003 22.014 9.851 22.016 22.008A22.013 22.013 0 0 1 56.955 79.27m18.966 138.858H37.95V95.967h37.97v122.16ZM237.033.018H18.89C8.58-.098.125 8.161-.001 18.471v219.053c.122 10.315 8.576 18.582 18.89 18.474h218.144c10.336.128 18.823-8.139 18.966-18.474V18.454c-.147-10.33-8.635-18.588-18.966-18.453"/></svg></a><a href=https://github.com/gracefullight target=_blank rel="noopener noreferrer" class=authorSocialLink_owbf title=GitHub><svg xmlns=http://www.w3.org/2000/svg width=1em height=1em viewBox="0 0 256 250" preserveAspectRatio=xMidYMid style=--dark:#000;--light:#fff class="authorSocialIcon_XYv3 githubSvg_Uu4N"><path d="M128.001 0C57.317 0 0 57.307 0 128.001c0 56.554 36.676 104.535 87.535 121.46 6.397 1.185 8.746-2.777 8.746-6.158 0-3.052-.12-13.135-.174-23.83-35.61 7.742-43.124-15.103-43.124-15.103-5.823-14.795-14.213-18.73-14.213-18.73-11.613-7.944.876-7.78.876-7.78 12.853.902 19.621 13.19 19.621 13.19 11.417 19.568 29.945 13.911 37.249 10.64 1.149-8.272 4.466-13.92 8.127-17.116-28.431-3.236-58.318-14.212-58.318-63.258 0-13.975 5-25.394 13.188-34.358-1.329-3.224-5.71-16.242 1.24-33.874 0 0 10.749-3.44 35.21 13.121 10.21-2.836 21.16-4.258 32.038-4.307 10.878.049 21.837 1.47 32.066 4.307 24.431-16.56 35.165-13.12 35.165-13.12 6.967 17.63 2.584 30.65 1.255 33.873 8.207 8.964 13.173 20.383 13.173 34.358 0 49.163-29.944 59.988-58.447 63.157 4.591 3.972 8.682 11.762 8.682 23.704 0 17.126-.148 30.91-.148 35.126 0 3.407 2.304 7.398 8.792 6.14C219.37 232.5 256 184.537 256 128.002 256 57.307 198.691 0 128.001 0Zm-80.06 182.34c-.282.636-1.283.827-2.194.39-.929-.417-1.45-1.284-1.15-1.922.276-.655 1.279-.838 2.205-.399.93.418 1.46 1.293 1.139 1.931Zm6.296 5.618c-.61.566-1.804.303-2.614-.591-.837-.892-.994-2.086-.375-2.66.63-.566 1.787-.301 2.626.591.838.903 1 2.088.363 2.66Zm4.32 7.188c-.785.545-2.067.034-2.86-1.104-.784-1.138-.784-2.503.017-3.05.795-.547 2.058-.055 2.861 1.075.782 1.157.782 2.522-.019 3.08Zm7.304 8.325c-.701.774-2.196.566-3.29-.49-1.119-1.032-1.43-2.496-.726-3.27.71-.776 2.213-.558 3.315.49 1.11 1.03 1.45 2.505.701 3.27Zm9.442 2.81c-.31 1.003-1.75 1.459-3.199 1.033-1.448-.439-2.395-1.613-2.103-2.626.301-1.01 1.747-1.484 3.207-1.028 1.446.436 2.396 1.602 2.095 2.622Zm10.744 1.193c.036 1.055-1.193 1.93-2.715 1.95-1.53.034-2.769-.82-2.786-1.86 0-1.065 1.202-1.932 2.733-1.958 1.522-.03 2.768.818 2.768 1.868Zm10.555-.405c.182 1.03-.875 2.088-2.387 2.37-1.485.271-2.861-.365-3.05-1.386-.184-1.056.893-2.114 2.376-2.387 1.514-.263 2.868.356 3.061 1.403Z"/></svg></a><a href=mailto:gracefullight.dev@gmail.com target=_blank rel="noopener noreferrer" class=authorSocialLink_owbf title=Email><svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24" fill=none stroke=currentColor stroke-linecap=round stroke-linejoin=round stroke-width=2 class=authorSocialIcon_XYv3><path stroke=none d="M0 0h24v24H0z"/><path d="M7.2 12a4.8 4.8 0 1 0 9.6 0 4.8 4.8 0 1 0-9.6 0"/><path d="M16.8 12v1.8a3 3 0 0 0 6 0V12a10.8 10.8 0 1 0-6.6 9.936"/></svg></a></div></div></div></div></div></header><div id=__blog-post-container class=markdown><h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=불-대수>불 대수<a href=#불-대수 class=hash-link aria-label="불 대수에 대한 직접 링크" title="불 대수에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">영국 수학자 불에 의해 개발</li>
<li class="">AND : 입력 값이 모두 1일 때 1 출력</li>
<li class="">OR : 입력 값이 하나라도 1일 때 1 출력</li>
<li class="">NOT : 부정</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=기본-공식>기본 공식<a href=#기본-공식 class=hash-link aria-label="기본 공식에 대한 직접 링크" title="기본 공식에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class=""><strong>합의 곱을 곱의 합으로 변환</strong></li>
<li class="">분배법칙 예외 : A ＋(B×C) = (A ＋ B)(B ＋ C)</li>
<li class="">드모르강<!-- -->
<ul>
<li class="">(A ＋ B)` = A`×B`</li>
<li class="">(A×B)` = A`＋ B`</li>
</ul>
</li>
<li class="">멱등<!-- -->
<ul>
<li class="">A ＋ A = A</li>
<li class="">A×A = A</li>
</ul>
</li>
<li class="">보수<!-- -->
<ul>
<li class="">A ＋ A` = 1</li>
<li class="">A×A` = 0</li>
</ul>
</li>
<li class="">항등<!-- -->
<ul>
<li class="">A ＋ 0 = A</li>
<li class="">A ＋ 1 = 1</li>
<li class="">A×0 = 0</li>
<li class="">A×1 = A</li>
</ul>
</li>
<li class="">콘센서스<!-- -->
<ul>
<li class="">AB ＋ BC ＋ CA` = AB ＋ CA`</li>
<li class="">(A ＋ B)(B ＋ C)(C ＋ A`) = (A ＋ B)(C ＋ A`)</li>
</ul>
</li>
<li class="">복원 : A`` = A</li>
<li class="">기타<!-- -->
<ul>
<li class="">A ＋ A`B = A ＋ B</li>
<li class="">A ＋ AB = A</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=카르노-맵>카르노 맵<a href=#카르노-맵 class=hash-link aria-label="카르노 맵에 대한 직접 링크" title="카르노 맵에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">설계된 논리식을 도표로 표현하여 최소화 하는 방법</li>
<li class="">Karnaugh map = K-map = 카노맵</li>
</ul>
<p><img decoding=async loading=lazy src=https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg/275px-K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg.png alt="카르노 맵" class=img_ev3q />
AB와 CD의 위치를 바꾸어 계산하는게 쉽다.</p>
<table><thead><tr><th><th><strong>00</strong><th><strong>01</strong><th><strong>11</strong><th><strong>10</strong><tbody><tr><td><strong>00</strong><td>0<td>1<td>3<td>2<tr><td><strong>01</strong><td>4<td>5<td>7<td>6<tr><td><strong>11</strong><td>12<td>13<td>15<td>14<tr><td><strong>10</strong><td>8<td>9<td>11<td>10</table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=논리-게이트>논리 게이트<a href=#논리-게이트 class=hash-link aria-label="논리 게이트에 대한 직접 링크" title="논리 게이트에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">BUFFER : 입력된 정보를 그대로 출력</li>
<li class="">NAND : NOT + AND</li>
<li class="">NOR : NOT + OR</li>
<li class="">XOR : 입력이 같으면 0, 다르면 1<!-- -->
<ul>
<li class="">X = A⊕B</li>
<li class="">X = A`B + AB`</li>
<li class="">X = (A + B)(A` + B`)</li>
</ul>
</li>
<li class="">XNOR : NOT + XOR<!-- -->
<ul>
<li class="">X = A⊙B</li>
<li class="">X = (A⊕B)`</li>
<li class="">X = AB + A`B`</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=조합논리회로>조합논리회로<a href=#조합논리회로 class=hash-link aria-label="조합논리회로에 대한 직접 링크" title="조합논리회로에 대한 직접 링크" translate=no>​</a></h2>
<p>반가산기, 전가산기, 병렬가산기, 반감산기, 전감산기, 디코더, 인코더, 멀티플렉서, 디멀티플렉서, 다수결회로, 비교기 등</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=반가산기>반가산기<a href=#반가산기 class=hash-link aria-label="반가산기에 대한 직접 링크" title="반가산기에 대한 직접 링크" translate=no>​</a></h3>
<p>2진수 두 개를 더한 합과 자리올림수를 구하는 조합논리회로</p>
<ul>
<li class="">합은 S, 자리올림(캐리)는 C</li>
<li class="">C = AB</li>
<li class="">S = A`B + AB` = A⊕B</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=전가산기>전가산기<a href=#전가산기 class=hash-link aria-label="전가산기에 대한 직접 링크" title="전가산기에 대한 직접 링크" translate=no>​</a></h3>
<p>1bit 2진수 3자리를 더하여 합과 자리올림수를 구하는 조합논리회로</p>
<ul>
<li class="">두 개의 반가산기와 한 개의 OR GATE로 구성</li>
<li class="">합은 S, 자리올림(캐리)는 C</li>
<li class="">C = (A⊕B)C + AB</li>
<li class="">S = (A⊕B)⊕C</li>
<li class="">3 × 8 디코더 1개 + 4 입력 OR 게이트 2개로 구성가능</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=병렬가산기>병렬가산기<a href=#병렬가산기 class=hash-link aria-label="병렬가산기에 대한 직접 링크" title="병렬가산기에 대한 직접 링크" translate=no>​</a></h3>
<p>n bit로 된 2진수 A, B에 대한 덧셈을 n개의 전가산기를 이용하여 구현한 실질적인 가산기</p>
<ul>
<li class="">전파지연을 줄이기 위해 Carry Look Ahead 사용</li>
<li class="">전파지연 : ALU Path에서 가장 긴 Delay</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=반감산기>반감산기<a href=#반감산기 class=hash-link aria-label="반감산기에 대한 직접 링크" title="반감산기에 대한 직접 링크" translate=no>​</a></h3>
<p>1bit 2진수 2자리에 대한 감산을 하는 조합논리회로</p>
<ul>
<li class="">차는 D, 빌려온 수는 B</li>
<li class="">B = A`B</li>
<li class="">D = A`B + A`B = A⊕B</li>
<li class="">2 × 4 디코더 1개 + 3 입력 OR 게이트 1개로 구성가능</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=디코더>디코더<a href=#디코더 class=hash-link aria-label="디코더에 대한 직접 링크" title="디코더에 대한 직접 링크" translate=no>​</a></h3>
<p>n bit의 코드화된 정보를 그 코드의 각 bit 조합에 따라 2^n개의 출력으로 번역하는 조합논리회로</p>
<ul>
<li class=""><strong>n개의 입력을 2^n개의 출력으로</strong></li>
<li class="">명령어의 명령부나 번지를 해독할 때 사용</li>
<li class="">주로 AND 게이트로 구성</li>
<li class="">부호화된 데이터에서 정보를 찾아냄</li>
<li class="">n × 2^n 디코더의 AND 게이트 수 : 2^n 개<!-- -->
<ul>
<li class="">5 × 8 디코더 : 8개</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=인코더>인코더<a href=#인코더 class=hash-link aria-label="인코더에 대한 직접 링크" title="인코더에 대한 직접 링크" translate=no>​</a></h3>
<p>2^n개의 입력선으로 입력된 값을 n개의 출력선으로 코드화해서 출력하는 조합논리회로</p>
<ul>
<li class=""><strong>2^n개의 입력을 n개의 출력으로</strong>
<ul>
<li class="">16개의 입력선일 경우 4개의 출력선 필요 (2^4)</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=멀티플렉서>멀티플렉서<a href=#멀티플렉서 class=hash-link aria-label="멀티플렉서에 대한 직접 링크" title="멀티플렉서에 대한 직접 링크" translate=no>​</a></h3>
<p>2^n개의 입력선 중 1개를 <strong>선택</strong>하여 그 선에서 입력되는 값을 1개의 출력선으로 출력하는 조합논리회로</p>
<ul>
<li class="">2^n개의 입력선 중 1개의 선을 선택하기 위해 <strong>n개의 선택선 이용</strong>
<ul>
<li class="">16개의 입력선일 경우 4개의 선택선 필요 (2^4)</li>
<li class=""><strong>출력선은 하나</strong></li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=디멀티플렉서>디멀티플렉서<a href=#디멀티플렉서 class=hash-link aria-label="디멀티플렉서에 대한 직접 링크" title="디멀티플렉서에 대한 직접 링크" translate=no>​</a></h3>
<p>1개의 입력선으로 들어오는 데이터를 2^n개의 출력선 중 1개를 선택하여 출력하는 회로</p>
<ul>
<li class="">2^n개의 출력선 중 1개의 선을 선택하기 위해 <strong>n개의 선택선 이용</strong></li>
<li class="">16개의 출력선일 경우 4개의 선택선 필요 (2^4)</li>
<li class=""><strong>입력선은 하나</strong></li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=순서논리회로>순서논리회로<a href=#순서논리회로 class=hash-link aria-label="순서논리회로에 대한 직접 링크" title="순서논리회로에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">외부의 입력과 현재 상태에 따라 출력이 결정</li>
<li class="">논리 게이트 외에 메모리 요소와 피드백 기능을 포함</li>
<li class="">기억기능 존재</li>
<li class="">출력이 일정한 값을 갖지 않음</li>
<li class=""><strong>플리플롭과 논리 게이트로 구성</strong></li>
<li class="">동기식과 비동기식으로 나뉨</li>
<li class=""><strong>플리플롭, 카운터, 레지스터, RAM, CPU</strong> 등</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=플리플롭>플리플롭<a href=#플리플롭 class=hash-link aria-label="플리플롭에 대한 직접 링크" title="플리플롭에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">전원이 공급되는한 상태의 변화를 위한 외부신호가 발생할 때까지 현재의 상태를 그대로 유지하는 논리회로</li>
<li class="">레지스터, 카운터, 반도체메모리(RAM)의 기본 구성요소</li>
<li class="">2진수 1bit를 저장 가능</li>
<li class="">두 개의 NAND 또는 두 개의 NOR 게이트를 이용하여 구성</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=특성표>특성표<a href=#특성표 class=hash-link aria-label="특성표에 대한 직접 링크" title="특성표에 대한 직접 링크" translate=no>​</a></h4>
<p>순서논리회로의 기능을 나타내는 표로 입력선의 값에 따라 현재 상태가 다음 상태로 어떻게 변하여 저장되는지를 나타낸다.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=여기표>여기표<a href=#여기표 class=hash-link aria-label="여기표에 대한 직접 링크" title="여기표에 대한 직접 링크" translate=no>​</a></h4>
<p>특성표 대신 순서논리회로의 기능을 표로 나타낸 것, 현재 상태 값을 새로운 값으로 변경시키려면 입력선으로 어떤 값을 입력해야 하는가를 나타낸다.
출력을 이용하여 입력을 알아내는 것.</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=rs-플립플롭>RS 플립플롭<a href=#rs-플립플롭 class=hash-link aria-label="RS 플립플롭에 대한 직접 링크" title="RS 플립플롭에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Reset-Set FF</li>
<li class="">특성표</li>
</ul>
<table><thead><tr><th style=text-align:center>S<th style=text-align:center>R<th style=text-align:center>Q<tbody><tr><td style=text-align:center>0<td style=text-align:center>0<td style=text-align:center>無<tr><td style=text-align:center>0<td style=text-align:center>1<td style=text-align:center>0<tr><td style=text-align:center>1<td style=text-align:center>0<td style=text-align:center>1<tr><td style=text-align:center>1<td style=text-align:center>1<td style=text-align:center>不可</table>
<ul>
<li class="">여기표는 특성표를 떠올리면 구할 수 있다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=d-플립플롭>D 플립플롭<a href=#d-플립플롭 class=hash-link aria-label="D 플립플롭에 대한 직접 링크" title="D 플립플롭에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">RS 플리플롭의 R선에 인버터(NOT 연산자)를 추가하여 S선과 하나로 묶어서 입력선을 하나만 구성한 플립플롭</li>
<li class="">입력값을 그대로 저장하는 기능을 수행</li>
<li class="">특성표</li>
</ul>
<table><thead><tr><th style=text-align:center>D<th style=text-align:center>Q<tbody><tr><td style=text-align:center>0<td style=text-align:center>0<tr><td style=text-align:center>1<td style=text-align:center>1</table>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=jk-플립플롭>JK 플립플롭<a href=#jk-플립플롭 class=hash-link aria-label="JK 플립플롭에 대한 직접 링크" title="JK 플립플롭에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">RS에서 S=1, R=1일 때 동작하지 않는 점을 보완한 플립플롭</li>
<li class="">RS 플립플롭의 입력선 S와 R에 <strong>AND 게이트 2개</strong>를 추가하여 JK 플립플롭의 입력선 J와 K로 사용한다.</li>
<li class="">모든 플립플롭의 기능을 포함한다.</li>
<li class="">플립플롭의 네가지 기능을 모두 갖춘 것을 찾으라는 문제가 나오면 RS가 있으면 RS, JK가 있으면 JK</li>
<li class="">특성표</li>
</ul>
<table><thead><tr><th style=text-align:center>S<th style=text-align:center>R<th style=text-align:center>Q<tbody><tr><td style=text-align:center>0<td style=text-align:center>0<td style=text-align:center>無<tr><td style=text-align:center>0<td style=text-align:center>1<td style=text-align:center>0<tr><td style=text-align:center>1<td style=text-align:center>0<td style=text-align:center>1<tr><td style=text-align:center>1<td style=text-align:center>1<td style=text-align:center>보수</table>
<ul>
<li class="">여기표는 특성표를 떠올리면 구할 수 있다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=t-플립플롭>T 플립플롭<a href=#t-플립플롭 class=hash-link aria-label="T 플립플롭에 대한 직접 링크" title="T 플립플롭에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">JK 플립플롭의 두 입력선을 묶어서 한 개의 입력선으로 구성한 플립플롭</li>
<li class="">T=1인 경우 현재 상태를 토글한다. <strong>보수가 출력</strong>된다.</li>
<li class="">카운터에 이용</li>
</ul>
<table><thead><tr><th style=text-align:center>T<th style=text-align:center>Q<tbody><tr><td style=text-align:center>0<td style=text-align:center>無<tr><td style=text-align:center>1<td style=text-align:center>보수</table>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=ms-플립플롭>M/S 플립플롭<a href=#ms-플립플롭 class=hash-link aria-label="M/S 플립플롭에 대한 직접 링크" title="M/S 플립플롭에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">마스터-슬레이브 플립플롭</li>
<li class="">출력 측의 일부가 입력 측에 피드백되어 유발되는 레이스 현상을 없애기 위해 고안된 플립플롭</li>
<li class="">두 개의 플립플롭으로 구성</li>
<li class="">레이스 현상 : 입력이 되는 조합회로의 출력을 플리플롭이 받는 동안 플리플롭의 내부 상태가 변하고 있으면 그 상태값이 피드백통로를 통해 조합회로로 전달되므로 회로가 불안정해지는 현상</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=자료-구성-단위>자료 구성 단위<a href=#자료-구성-단위 class=hash-link aria-label="자료 구성 단위에 대한 직접 링크" title="자료 구성 단위에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=비트>비트<a href=#비트 class=hash-link aria-label="비트에 대한 직접 링크" title="비트에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">자료, 정보 표현의 최소 단위</li>
<li class="">0과 1을 표시하는 2진수 1자리</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=니블>니블<a href=#니블 class=hash-link aria-label="니블에 대한 직접 링크" title="니블에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">4bit가 모여 구성</li>
<li class="">16진수 1자리를 표현하기에 적합</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=바이트>바이트<a href=#바이트 class=hash-link aria-label="바이트에 대한 직접 링크" title="바이트에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class=""><strong>문자를 표현하는 최소 단위</strong></li>
<li class="">8bit가 모여 1Byte</li>
<li class="">1Byte는 256가지의 정보를 표현(2^8bit)</li>
<li class="">Alphanumeric은 1Byte, 한글한자는 2Byte</li>
<li class="">KB = 2의 10승, MB = 2의 20승...</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=워드>워드<a href=#워드 class=hash-link aria-label="워드에 대한 직접 링크" title="워드에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">컴퓨터가 한 번에 처리할 수 있는 명령 단위</li>
<li class=""><strong>전워드 : 4Byte</strong> (full word)</li>
<li class="">하프워드 : 2Byte (반워드)</li>
<li class="">더블워드 : 8Byte</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=필드>필드<a href=#필드 class=hash-link aria-label="필드에 대한 직접 링크" title="필드에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">파일 구성의 최소 단위</li>
<li class="">의미 있는 정보를 표현하는 최소 단위</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=레코드>레코드<a href=#레코드 class=hash-link aria-label="레코드에 대한 직접 링크" title="레코드에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">하나 이상의 관련된 필드가 모여서 구성</li>
<li class="">컴퓨터 내부 자료 처리 단위</li>
<li class=""><strong>논리 레코드</strong>를 의미</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=블록>블록<a href=#블록 class=hash-link aria-label="블록에 대한 직접 링크" title="블록에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class=""><strong>물리 레코드</strong></li>
<li class="">하나 이상의 논리 레코드가 모여서 구성</li>
<li class="">각종 저장 매체와의 입출력 단위를 의미</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=파일>파일<a href=#파일 class=hash-link aria-label="파일에 대한 직접 링크" title="파일에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">프로그램 구성의 기본 단위</li>
<li class="">같은 종류의 여러 레코드가 모여서 구성</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=데이터베이스>데이터베이스<a href=#데이터베이스 class=hash-link aria-label="데이터베이스에 대한 직접 링크" title="데이터베이스에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">여러 개의 관련된 파일의 집합</li>
<li class="">관계형, 계층형, 망형 DB</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=진법>진법<a href=#진법 class=hash-link aria-label="진법에 대한 직접 링크" title="진법에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=2진수>2진수<a href=#2진수 class=hash-link aria-label="2진수에 대한 직접 링크" title="2진수에 대한 직접 링크" translate=no>​</a></h3>
<p>정수는 나누고 소숫점은 곱하고</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=8진수>8진수<a href=#8진수 class=hash-link aria-label="8진수에 대한 직접 링크" title="8진수에 대한 직접 링크" translate=no>​</a></h3>
<p>2진수를 구하고 3자리씩 묶고</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=16진수>16진수<a href=#16진수 class=hash-link aria-label="16진수에 대한 직접 링크" title="16진수에 대한 직접 링크" translate=no>​</a></h3>
<p>2진수를 구하고 4자리씩 묶고</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=보수>보수<a href=#보수 class=hash-link aria-label="보수에 대한 직접 링크" title="보수에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">덧셈회로를 이용하여 뺄셈을 수행하기 위해 사용</li>
<li class="">1의 보수 : 그냥 반전</li>
<li class="">2의 보수<!-- -->
<ul>
<li class="">1의 보수를 구한 뒤 1을 더함</li>
<li class="">뒤에서부터 1이 나올때까지는 그냥쓰고 나머지는 반전</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=뺄셈>뺄셈<a href=#뺄셈 class=hash-link aria-label="뺄셈에 대한 직접 링크" title="뺄셈에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">1의 보수 이용 : 자리올림이 발생하면 결과에 자리올림수를 더한다.</li>
<li class="">2의 보수 이용 : 자리올림이 발생하면 버린다.</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=고정-소수점>고정 소수점<a href=#고정-소수점 class=hash-link aria-label="고정 소수점에 대한 직접 링크" title="고정 소수점에 대한 직접 링크" translate=no>​</a></h2>
<p>정수 데이터 표현 및 연산에 사용하는 방법</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=2진연산>2진연산<a href=#2진연산 class=hash-link aria-label="2진연산에 대한 직접 링크" title="2진연산에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">정수값을 2진수로 변환하여 표현하는 방식</li>
<li class="">표현할 수 있는 범위가 작음</li>
<li class="">연산속도 빠름</li>
<li class="">맨처음 1bit는 부호비트로 사용</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=음수연산>음수연산<a href=#음수연산 class=hash-link aria-label="음수연산에 대한 직접 링크" title="음수연산에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">부호화 절대치법 : 양수 표현에 대해 부호비트만 바꾼다.</li>
<li class="">부호화 1의 보수법 : 양수 표현에 대해 1의 보수를 구한다.</li>
<li class="">부호화 2의 보수법 : 양수 표현에 대해 2의 보수를 구한다.<!-- -->
<ul>
<li class="">1의 보수 표현법에 비해 음수 1개를 더 표현할 수 있다.</li>
<li class="">자리올림을 무시하므로 1의 보수 표현에 비해 연산이 간단하다.</li>
<li class="">0이 하나만 존재한다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>부호화 2진 표현을 10진수로 변경시</strong></p>
<ol>
<li class="">부호 비트를 빼고 2의 보수 연산</li>
<li class="">부호를 대입</li>
</ol>
</blockquote>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=10진연산>10진연산<a href=#10진연산 class=hash-link aria-label="10진연산에 대한 직접 링크" title="10진연산에 대한 직접 링크" translate=no>​</a></h3>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=언팩연산>언팩연산<a href=#언팩연산 class=hash-link aria-label="언팩연산에 대한 직접 링크" title="언팩연산에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">존형 10진연산 = Zone Decimal</li>
<li class=""><strong>연산이 불가능</strong>하다.</li>
<li class=""><strong>데이터 입출력에 사용</strong></li>
<li class="">1Byte로 10진수 1자리를 표현</li>
<li class="">4개의 존 비트와 4개의 숫자 비트를 사용</li>
<li class=""><strong>최하위 바이트의 존 부분을 부호로 사용</strong></li>
<li class="">Zone = F, Digit = 4Bit 2진수</li>
<li class="">Sign = 양수 C, 음수 D, 부호 없는 양수 F</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=팩연산>팩연산<a href=#팩연산 class=hash-link aria-label="팩연산에 대한 직접 링크" title="팩연산에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class=""><strong>연산이 가능</strong></li>
<li class=""><strong>데이터 입출력 불가능</strong></li>
<li class="">1Byte로 10진수 2자리를 표현</li>
<li class=""><strong>최하위 바이트의 마지막 4Bit를 부호로 사용</strong></li>
<li class="">Digit = 4Bit 2진수</li>
<li class="">Sign = 양수 C, 음수 D, 부호 없는 양수 F</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=부동소수점>부동소수점<a href=#부동소수점 class=hash-link aria-label="부동소수점에 대한 직접 링크" title="부동소수점에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">매우 크거나 작은 수, 매우 정밀한 수를 적은 비트로 표현 가능</li>
<li class="">연산시간이 느림</li>
<li class="">부동 소수점의 연산 수행횟수를 FLOPS로 표시<!-- -->
<ul>
<li class=""><strong>FLOPS</strong> : FLoating point Operations Per Second, 컴퓨터 연산속도의 단위</li>
</ul>
</li>
<li class="">지수부와 가수부를 분리하는 <strong>정규화</strong> 과정 필요
<strong>정규화</strong> : <code>0.1 &lt;= 가수부분 &lt; 1</code> 을 만족시키게 변경</li>
<li class="">4Byte를 사용하는 단정도와 8Byte를 사용하는 배정도 표현법</li>
<li class="">지수부에는 정규화해서 분리한 지수값을 <strong>64Bias</strong>법으로 표현<!-- -->
<ul>
<li class="">64Bias : 지수 7Bit에 100 0000이 입력되어 있고 2^n의 n만큼을 더하고 뺴서 지수를 표현하는 방식</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=ieee-표준>IEEE 표준<a href=#ieee-표준 class=hash-link aria-label="IEEE 표준에 대한 직접 링크" title="IEEE 표준에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">IEEE 754 표준</li>
<li class="">정규화시 가수부가 1이되게 정규화</li>
<li class=""><strong>127Bais</strong>를 사용해 지수 8Bit에 0111 1111이 들어있음</li>
</ul>
<table><thead><tr><th style=text-align:center>구분<th style=text-align:center>크기<th style=text-align:center>부호<th style=text-align:center>지수<th style=text-align:center>가수<tbody><tr><td style=text-align:center>single<td style=text-align:center><strong>32</strong><td style=text-align:center>1<td style=text-align:center><strong>8</strong><td style=text-align:center>23<tr><td style=text-align:center>double<td style=text-align:center><strong>64</strong><td style=text-align:center>1<td style=text-align:center><strong>11</strong><td style=text-align:center>52<tr><td style=text-align:center>extended<td style=text-align:center>80<td style=text-align:center>1<td style=text-align:center>11<td style=text-align:center>68</table>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=연산>연산<a href=#연산 class=hash-link aria-label="연산에 대한 직접 링크" title="연산에 대한 직접 링크" translate=no>​</a></h3>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=덧셈-및-뺄셈>덧셈 및 뺄셈<a href=#덧셈-및-뺄셈 class=hash-link aria-label="덧셈 및 뺄셈에 대한 직접 링크" title="덧셈 및 뺄셈에 대한 직접 링크" translate=no>​</a></h4>
<ol>
<li class="">0인지 확인</li>
<li class="">지수가 큰쪽에 수를 맞추어 정규화</li>
<li class="">연산</li>
<li class="">결과 정규화</li>
</ol>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=곱셈>곱셈<a href=#곱셈 class=hash-link aria-label="곱셈에 대한 직접 링크" title="곱셈에 대한 직접 링크" translate=no>​</a></h4>
<ol>
<li class="">0인지 확인</li>
<li class="">지수 덧셈</li>
<li class="">가수 곱셈</li>
<li class="">결과 정규화</li>
</ol>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=나눗셈>나눗셈<a href=#나눗셈 class=hash-link aria-label="나눗셈에 대한 직접 링크" title="나눗셈에 대한 직접 링크" translate=no>​</a></h4>
<ol>
<li class="">0인지 확인</li>
<li class="">레지스터 초기화</li>
<li class="">부호 결정</li>
<li class="">나눠지는 수가 나누는 수보다 작게 나눠지는 수를 정규화</li>
<li class="">지수 뺄셈</li>
<li class="">가수 나눗셈</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=자료-표현>자료 표현<a href=#자료-표현 class=hash-link aria-label="자료 표현에 대한 직접 링크" title="자료 표현에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=bcd>BCD<a href=#bcd class=hash-link aria-label="BCD에 대한 직접 링크" title="BCD에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">2진화 10진코드 = Binary Coded Decimal</li>
<li class="">6Bit 코드로 IBM에서 개발</li>
<li class="">1개의 문자를 2개의 Zone Bit와 4개의 Digit Bit로 표현</li>
<li class="">6Bit이므로 64개 문자 표현 가능</li>
<li class="">1Bit의 Parity Bit를 추가해 <strong>7Bit로 사용</strong></li>
<li class=""><strong>영소문자 표현 불가</strong></li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=ascii>ASCII<a href=#ascii class=hash-link aria-label="ASCII에 대한 직접 링크" title="ASCII에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">American Standard Code for Information Interchange</li>
<li class="">7Bit 코드로 미국 표준협회에서 개발</li>
<li class="">7Bit이므로 128개의 문자 표현 가능</li>
<li class="">1Bit의 Parity Bit를 추가해 <strong>8Bit로 사용</strong></li>
<li class=""><strong>영대소문자, 숫자, 제어문자, 특수문자 등 표현 가능</strong></li>
<li class="">통신 제어용 및 마이크로 컴퓨터의 기본코드로 사용</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=ebcdic>EBCDIC<a href=#ebcdic class=hash-link aria-label="EBCDIC에 대한 직접 링크" title="EBCDIC에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">8Bit 코드로 IBM에서 개발</li>
<li class="">1개의 문자를 4개의 Zone Bit와 4개의 Digit Bit로 표현</li>
<li class="">8Bit이므로 256개의 문자 표현 가능</li>
<li class="">1Bit의 Parity Bit를 추가해 <strong>9Bit로 사용</strong></li>
<li class=""><strong>특수문자, 영대소문자, 숫자 등 표현 가능</strong></li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=bcd-코드>BCD 코드<a href=#bcd-코드 class=hash-link aria-label="BCD 코드에 대한 직접 링크" title="BCD 코드에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">10진수 1자리를 2진수 4Bit로 표현</li>
<li class=""><strong>8421 코드</strong></li>
<li class=""><strong>가중치 코드</strong>
<ul>
<li class="">2진수 각 자리가 고유한 값을 가지는 코드</li>
</ul>
</li>
<li class="">BCD에서 Zone을 생략한 형태</li>
<li class="">10진수 입출력이 간편</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=excess3-코드>Excess3 코드<a href=#excess3-코드 class=hash-link aria-label="Excess3 코드에 대한 직접 링크" title="Excess3 코드에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">BCD 코드에 3을 더하여 만든 코드</li>
<li class="">모든 비트가 동시에 0이 되는 경우가 없다.</li>
<li class=""><strong>3 초과 코드</strong></li>
<li class=""><strong>자기보수 코드</strong></li>
<li class=""><strong>비가중치 코드</strong></li>
<li class="">10진수를 표현하기 위함이다.</li>
<li class="">보수를 구하기 편해 산술연산에 좋다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=gray-코드>Gray 코드<a href=#gray-코드 class=hash-link aria-label="Gray 코드에 대한 직접 링크" title="Gray 코드에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">BCD 코드의 인접하는 Bit를 XOR 연산하여 만든 코드</li>
<li class="">코드 변환이 용이</li>
<li class="">입출력장치, A/D변환기, 주변장치 등에서 숫자를 표현할 때 사용</li>
<li class="">1Bit만 변화시켜 다음 수치로 증가시키기 때문에 하드웨어 오류가 적다.</li>
<li class="">2진수를 Gray로 변경시 : n자 모양으로 연산<!-- -->
<ul>
<li class="">첫번째 그레이 비트는 2진수 첫번째 비트 그대로</li>
<li class="">2진수 비트를 앞뒤로 XOR 연산</li>
</ul>
</li>
<li class="">Gray를 2진수로 변경시 : h자 모양으로 연산<!-- -->
<ul>
<li class="">첫번째 2진수는 그레이 비트 그대로</li>
<li class="">두번째부턴 왼쪽 변경된 2진수와 변경할 우측 그레이 비트를 XOR 연산</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=패리티-코드>패리티 코드<a href=#패리티-코드 class=hash-link aria-label="패리티 코드에 대한 직접 링크" title="패리티 코드에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">전송된 코드의 오류를 검사하기 위해 데이터 비트 외에 1Bit의 패리티 체크 비트를 추가하는 것</li>
<li class="">1Bit의 오류만 검출 가능</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=홀수-패리티>홀수 패리티<a href=#홀수-패리티 class=hash-link aria-label="홀수 패리티에 대한 직접 링크" title="홀수 패리티에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Odd Parity = 기수 패리티</li>
<li class="">1의 갯수가 홀수가 되도록 0이나 1을 마지막에 추가</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=짝수-패리티>짝수 패리티<a href=#짝수-패리티 class=hash-link aria-label="짝수 패리티에 대한 직접 링크" title="짝수 패리티에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Even Parity = 우수 패리티</li>
<li class="">1의 갯수가 짝수가 되도록 0이나 1을 마지막에 추가</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=해밍-코드>해밍 코드<a href=#해밍-코드 class=hash-link aria-label="해밍 코드에 대한 직접 링크" title="해밍 코드에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">오류를 검출하고 교정이 가능한 코드</li>
<li class="">2Bit의 오류를 검출할 수 있고 1Bit를 교정 가능</li>
<li class="">잉여비트가 많이 필요</li>
<li class="">1, 2, 4, 8, ... <strong>2^n번째 Bit는 오류 검출을 위한 패리티 비트</strong></li>
<li class="">패리티 비트 결정시<!-- -->
<ul>
<li class="">1번 Bit는 1, 3, 5, 7...</li>
<li class="">2번 Bit는 2, 3, 6, 7, 10, 11... 2Bit씩 건너 뛰면서</li>
<li class="">4번 Bit는 4, 5, 6, 7, 12, 13, 14, 15... 4Bit씩 건너 뛰면서</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=코드-분류>코드 분류<a href=#코드-분류 class=hash-link aria-label="코드 분류에 대한 직접 링크" title="코드 분류에 대한 직접 링크" translate=no>​</a></h3>
<p>가중치코드는 일반적으로 숫자로 이루어져 있다.</p>
<table><thead><tr><th style=text-align:center>분류<th style=text-align:center>코드종류<tbody><tr><td style=text-align:center>가중치<td style=text-align:center>BCD(8421), 2421, 84-2-1, Biquinary, 51111, RingCounter<tr><td style=text-align:center>비가중치<td style=text-align:center>3초과(Excess3), Gray, Jonson, 2outof5, 3outof5<tr><td style=text-align:center>자기보수<td style=text-align:center>3초과(Excess3), 2421, 51111, 84-2-1<tr><td style=text-align:center>오류검출<td style=text-align:center>해밍, 패리티, Biquinary, RingCounter, 2outof5, 3outof5</table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=중앙처리장치>중앙처리장치<a href=#중앙처리장치 class=hash-link aria-label="중앙처리장치에 대한 직접 링크" title="중앙처리장치에 대한 직접 링크" translate=no>​</a></h2>
<p><strong>제어장치, 연산장치, 레지스터, 버스</strong>로 구성</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=제어장치>제어장치<a href=#제어장치 class=hash-link aria-label="제어장치에 대한 직접 링크" title="제어장치에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">컴퓨터의 모든 장치에 대한 동작을 지시하고 제어</li>
<li class="">명령 레지스터에서 읽어들인 명령어를 해독해 장치에 제어신호를 보내 명령을 수행하도록 지시</li>
<li class="">제어장치에 입력되는 항목<!-- -->
<ul>
<li class="">명령어 레지스터</li>
<li class="">플래그</li>
<li class="">클록</li>
</ul>
</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=구성요소>구성요소<a href=#구성요소 class=hash-link aria-label="구성요소에 대한 직접 링크" title="구성요소에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">명령 레지스터 : 현재 실행중인 명령어 내용 기억</li>
<li class="">명령 해독기(디코더) : 명령 레지스터에 있는 명령어를 해독</li>
<li class="">제어 발생기(인코더) : 해독된 명령에 따라 각 장치로 본래 제어 신호 생성</li>
<li class="">제어 주소 레지스터(CAR) : 다음에 실행할 마이크로 명령어의 주소를 저장하는 레지스터<!-- -->
<ul>
<li class="">매핑의 결과값, 주소필드, 서브루틴 레지스터의 내용이 기록</li>
</ul>
</li>
<li class="">제어 버퍼 레지스터(CBR) : 제어 기억장치로부터 읽혀진 마이크로명령어를 일시적으로 저장하는 레지스터</li>
<li class="">제어 기억장치 : 마이크로 프로그램을 저장하는 내부 기억장치</li>
<li class="">순서 제어모듈 : 마이크로 명령어의 실행 순서를 결정하는 회로집합</li>
<li class="">순차 카운터 : 디코더에 의해 선택된 번호에 해당하는 타이밍 신호를 생성</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=연산장치>연산장치<a href=#연산장치 class=hash-link aria-label="연산장치에 대한 직접 링크" title="연산장치에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">제어장치에 명령에 따라 실제로 연산을 수행하는 장치</li>
<li class="">산술연산, 논리연산, 관계연산, Shift 등</li>
<li class="">가산기, 누산기(AC), 보수기(Complementor), 데이터레지스터, 오버플로 검출기, 시프트 레지스터 등</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=레지스터>레지스터<a href=#레지스터 class=hash-link aria-label="레지스터에 대한 직접 링크" title="레지스터에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소</li>
<li class="">플리플롭이나 래치들을 병렬로 연결하여 구성</li>
<li class="">메모리 중에서 속도가 가장 빠르다.</li>
<li class="">레지스터의 크기는 워드를 구성하는 비트 개수만큼의 플립플롭으로 구성<!-- -->
<ul>
<li class="">워드의 크기가 16Bit => 레지스터는 16개의 플립플롭이나 래치로 구성</li>
</ul>
</li>
<li class="">저장값을 0으로 하는 것을 설정해제(CLR)</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=자료전송>자료전송<a href=#자료전송 class=hash-link aria-label="자료전송에 대한 직접 링크" title="자료전송에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">직렬 전송 : 직렬 시프트 마이크로 오퍼레이션, 느림</li>
<li class="">병렬 전송 : 하나의 클록펄스 동안 워드가 동시에 전송</li>
<li class="">버스 전송 : 모든 레지스터가 공통으로 이용하는 경로, 병렬에 비해 결선의 수를 줄일 수 있다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=주요-레지스터>주요 레지스터<a href=#주요-레지스터 class=hash-link aria-label="주요 레지스터에 대한 직접 링크" title="주요 레지스터에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class=""><strong>PC</strong> : 프로그램 카운터, 다음번 실행할 명령어의 번지를 기억하는 레지스터로 분기 명령이 실행되는 경우 그 목적지 주소로 갱신</li>
<li class=""><strong>IR</strong> : 명령레지스터, 현재 실행중인 명령의 내용을 기억하는 레지스터</li>
<li class=""><strong>AC</strong> : 누산기, 연산된 결과를 일시적으로 저장하는 레지스터</li>
<li class=""><strong>PSWR</strong> : <strong>Status Register, Program Status Word Register, Flag Regiester</strong>
<ul>
<li class="">시스템 내부의 순간 상태가 기록된 정보를 PSW라 한다.</li>
<li class="">오버플로, 언더플로, 자리올림, 계산상태, 인터럽트 등의 PSW를 저장하는 레지스터</li>
<li class="">프로그램 제어와 밀접한 관계</li>
</ul>
</li>
<li class=""><strong>MAR</strong> : 메모리 주소 레지스터, 데이터의 번지를 기억하는 레지스터</li>
<li class=""><strong>MBR</strong> : 메모리 버퍼 레지스터, 데이터가 잠시 기억되는 레지스터, CPU가 데이터를 처리하기 위해서 반드시 거처야한다.</li>
<li class="">Base Register : 명령이 시작되는 시작 번지를 기억하는 레지스터</li>
<li class="">Index Register : 주소의 변경, 서브루틴 연결 및 프로그램에서의 반복연산의 횟수를 세는 레지스터로 프로그래머가 내용을 변경할 수 있다.</li>
<li class="">Data Register : 연산에 사용될 데이터를 기억하는 레지스터</li>
<li class="">Shift Register : 저장된 값을 미는 연산을 하는 레지스터, 2배 길이 레지스터</li>
<li class="">Major Status Register : CPU의 현재상태(인출, 간접, 실행, 인터럽트)를 저장하고 있는 레지스터</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=버스>버스<a href=#버스 class=hash-link aria-label="버스에 대한 직접 링크" title="버스에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">CPU, 메모리, I/O장치와 상호 필요한 정보를 교환하기 위해 연결하는 전송선</li>
<li class="">내부회로에서 버스를 사용하는 목적은 결선의 수를 줄이기 위해서다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=종류>종류<a href=#종류 class=hash-link aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class=""><strong>제어 버스</strong> : Control Bus, <strong>양방향 전송선</strong>, 제어신호 전송</li>
<li class=""><strong>주소 버스</strong> : Address Bus, 번지 버스, <strong>단방향 전송선</strong>, 번지 지정</li>
<li class=""><strong>데이터 버스</strong> : Data Bus, 자료 버스, <strong>양방향 전송선</strong>, 데이터 전송</li>
<li class="">내부버스 : CPU 및 메모리에 구성된 버스</li>
<li class="">외부버스 : 주변 I/O장치에 구성된 버스</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=명령어>명령어<a href=#명령어 class=hash-link aria-label="명령어에 대한 직접 링크" title="명령어에 대한 직접 링크" translate=no>​</a></h2>
<p>OP code부, Mode부, Operand부로 구성</p>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=연산자부>연산자부<a href=#연산자부 class=hash-link aria-label="연산자부에 대한 직접 링크" title="연산자부에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Operation Code부 = OP Code</li>
<li class="">연산자부의 크기는 표현할 수 있는 명령의 종류를 나타내는 것</li>
<li class="">nBit일 때 최대 2^n의 명령어 표현 가능</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=모드부>모드부<a href=#모드부 class=hash-link aria-label="모드부에 대한 직접 링크" title="모드부에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Mode부</li>
<li class="">주소부의 유효 주소가 결정되는 방법을 지정</li>
<li class="">0이면 직접, 1이면 간접</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=자료부>자료부<a href=#자료부 class=hash-link aria-label="자료부에 대한 직접 링크" title="자료부에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Operand부 = 오퍼랜드부 = 주소필드</li>
<li class="">실제 데이터에 대한 정보를 표시하는 부분</li>
<li class="">주소, 레지스터 번호, 사용할 데이터 등을 표시</li>
<li class="">자료부의 크기는 메모리 용량과 관계가 있다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=설계시-고려사항>설계시 고려사항<a href=#설계시-고려사항 class=hash-link aria-label="설계시 고려사항에 대한 직접 링크" title="설계시 고려사항에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">연산자의 종류</li>
<li class="">명령어 형식</li>
<li class="">주소지정방식</li>
<li class="">데이터 구조</li>
<li class="">효율성 제고방안 : 기억공간, 사용빈도, 주소지정방식, 주기억장치의 대역폭 이용</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=기능>기능<a href=#기능 class=hash-link aria-label="기능에 대한 직접 링크" title="기능에 대한 직접 링크" translate=no>​</a></h3>
<p>함수 연산, 자료전달, 제어, 입출력 기능</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=함수-연산-기능>함수 연산 기능<a href=#함수-연산-기능 class=hash-link aria-label="함수 연산 기능에 대한 직접 링크" title="함수 연산 기능에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">산술연산 : ADD, SUB, MUL, DIV, 산술 Shift</li>
<li class="">논리연산 : NOT, AND, OR, XOR, 논리 Shift, Rotate, Complement, Clear</li>
<li class="">단항연산 : NOT, Complement, Shift, Rotate, Move</li>
<li class="">이항연산 : 사칙, AND, OR, XOR, XNOR</li>
<li class="">연산자 우선순위<!-- -->
<ol>
<li class="">산술연산자 : 거듭제곱 > 곱=나눔 > 덧,뺄</li>
<li class="">관계연산자</li>
<li class="">논리 연산자 : NOT > AND > OR</li>
</ol>
</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=자료-전달-기능>자료 전달 기능<a href=#자료-전달-기능 class=hash-link aria-label="자료 전달 기능에 대한 직접 링크" title="자료 전달 기능에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Load : 기억장치 => CPU</li>
<li class="">Store : CPU => 기억장치 저장</li>
<li class="">Move : 레지스터간 자료 전송</li>
<li class="">Push : 스택에 자료 저장</li>
<li class="">Pop : 스택에서 자료 꺼냄</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=제어-기능>제어 기능<a href=#제어-기능 class=hash-link aria-label="제어 기능에 대한 직접 링크" title="제어 기능에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">무조건 분기 : <code>GOTO, JMP (PC &lt;- X)</code></li>
<li class="">조건 분기 : IF, SPA, SNA, SZA<!-- -->
<ul>
<li class="">SPA : Skip if AC is Positive</li>
<li class="">SNA : Skip if AC is Negative</li>
<li class="">SZA : Skip if AC is Zero</li>
</ul>
</li>
<li class="">Call : 부 프로그램 호출</li>
<li class="">Return : 부 프로그램에서 복귀</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=입출력-기능>입출력 기능<a href=#입출력-기능 class=hash-link aria-label="입출력 기능에 대한 직접 링크" title="입출력 기능에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Input</li>
<li class="">Output</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=연산-1>연산<a href=#연산-1 class=hash-link aria-label="연산에 대한 직접 링크" title="연산에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=and>AND<a href=#and class=hash-link aria-label="AND에 대한 직접 링크" title="AND에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">특정 비트를 삭제(Clear)하는 연산</li>
<li class="">Masking 연산</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=or>OR<a href=#or class=hash-link aria-label="OR에 대한 직접 링크" title="OR에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">특정 비트를 1로 만드는 연산</li>
<li class="">Selective Set 연산</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=xor>XOR<a href=#xor class=hash-link aria-label="XOR에 대한 직접 링크" title="XOR에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">두 개의 데이터를 비교하거나 특정 비트를 반전시킬 때 사용</li>
<li class="">결과에 1Bit라도 1이 있으면 서로 다른 데이터</li>
<li class="">반전시킬 Bit를 1과 XOR</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=not>NOT<a href=#not class=hash-link aria-label="NOT에 대한 직접 링크" title="NOT에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">그냥 반전</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=논리-shift>논리 Shift<a href=#논리-shift class=hash-link aria-label="논리 Shift에 대한 직접 링크" title="논리 Shift에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">0을 삽입해 비트를 좌우로 한칸씩 민다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=rotate>Rotate<a href=#rotate class=hash-link aria-label="Rotate에 대한 직접 링크" title="Rotate에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Shift에서 밀려나간 비트를 반대편으로 가져와 입력하는 연산</li>
<li class=""><strong>문자 위치를 변환할 때</strong> 사용</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=산술-shift>산술 Shift<a href=#산술-shift class=hash-link aria-label="산술 Shift에 대한 직접 링크" title="산술 Shift에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">부호를 고려하여 자리를 이동시키는 연산</li>
<li class="">2^n으로 곱하거나 나눌 때 사용</li>
<li class="">왼쪽으로 Shift시 2^n을 곱한 값과 같음</li>
<li class="">오른쪽으로 Shift시 2^n을 나눈 값과 같음</li>
<li class="">홀수를 오른쪽으로 Shift시에 0.5의 오차 발생</li>
<li class="">정수 표현 방식에서만 사용 가능</li>
<li class="">정수 수치 표현 방법에 따라 Padding Bit 및 결과가 다름</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=shift-left>Shift Left<a href=#shift-left class=hash-link aria-label="Shift Left에 대한 직접 링크" title="Shift Left에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">부호화 절대치, 2의 보수법은 무조건 0</li>
<li class="">1의 보수법은 부호 비트와 같은 0, 1</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=shift-right>Shift Right<a href=#shift-right class=hash-link aria-label="Shift Right에 대한 직접 링크" title="Shift Right에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">부호화 절대치는 0</li>
<li class="">1의 보수법, 2의 보수법은 부호 비트와 같은 0, 1</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=명령어-형식>명령어 형식<a href=#명령어-형식 class=hash-link aria-label="명령어 형식에 대한 직접 링크" title="명령어 형식에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=3주소-명령어>3주소 명령어<a href=#3주소-명령어 class=hash-link aria-label="3주소 명령어에 대한 직접 링크" title="3주소 명령어에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Operand부가 세 개로 구성되는 명령어 형식</li>
<li class="">**GPR(범용 레지스터)**를 가진 컴퓨터에서 사용</li>
<li class="">연산의 결과는 Operand 1에 주로 기록 (컴퓨터에 따라 Operand 3에도 기록)</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=장점>장점<a href=#장점 class=hash-link aria-label="장점에 대한 직접 링크" title="장점에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">연산시 원래 자료를 파괴하지 않음</li>
<li class="">다른 형식의 명령어를 이용하는 것보다 프로그램 전체의 길이가 짧음</li>
<li class="">전체 프로그램 실행시 명령인출을 위해 주기억장치를 접근하는 횟수 감소</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=단점>단점<a href=#단점 class=hash-link aria-label="단점에 대한 직접 링크" title="단점에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">명령어 한 개의 길이가 너무 길어짐</li>
<li class="">하나의 명령을 수행하기 위해 최소한 4번 기억장소에 접근해야함</li>
<li class="">수행시간이 길다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=2주소-명령어>2주소 명령어<a href=#2주소-명령어 class=hash-link aria-label="2주소 명령어에 대한 직접 링크" title="2주소 명령어에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Operand가 두 개로 구성되는 일반적인 명령어 형식</li>
<li class="">여러 개의 **GPR(범용 레지스터)**를 가진 컴퓨터에서 사용</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=장점-1>장점<a href=#장점-1 class=hash-link aria-label="장점에 대한 직접 링크" title="장점에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">실행 속도가 빠르고 기억장소를 많이 차지하지 않음</li>
<li class="">3주소 명령에 비해 명령어의 길이가 짧음</li>
<li class="">계산결과가 기억장치에 기억되고 CPU에도 남아 있어 계산 결과를 시험할 때 시간이 절약된다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=단점-1>단점<a href=#단점-1 class=hash-link aria-label="단점에 대한 직접 링크" title="단점에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">연산 결과가 주로 Operand1에 저장되므로 원래 Operand1에 있던 자료는 파괴된다.</li>
<li class="">전체 프로그램의 길이가 길어진다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=1주소-명령어>1주소 명령어<a href=#1주소-명령어 class=hash-link aria-label="1주소 명령어에 대한 직접 링크" title="1주소 명령어에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Operand가 한 개로 구성된 명령어 형식</li>
<li class=""><strong>AC</strong>를 이용하여 명령어를 처리하므로 결과도 <strong>누산기</strong>에 저장된다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=0주소-명령어>0주소 명령어<a href=#0주소-명령어 class=hash-link aria-label="0주소 명령어에 대한 직접 링크" title="0주소 명령어에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Operand부 없이 OPCode만으로 구성</li>
<li class="">모든 연산은 Stack 메모리의 Stack Pointer가 가리키는 Operand를 이용하여 수행</li>
<li class="">스택 머신</li>
<li class="">인스트럭션 수행시간이 짧다.</li>
<li class="">기억공간 이용이 효율적</li>
<li class="">수식을 계산하기 위해선 Postfix 형태로 변경해야한다.</li>
<li class="">연산 결과를 다시 스택에 넣기 때문에 원래의 자료가 남지 않는다.</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=주소지정방식>주소지정방식<a href=#주소지정방식 class=hash-link aria-label="주소지정방식에 대한 직접 링크" title="주소지정방식에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=고려사항>고려사항<a href=#고려사항 class=hash-link aria-label="고려사항에 대한 직접 링크" title="고려사항에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">표현의 효율성 : 빠르게 접근가능하고, 주소지정에 적은 비트를 사용해야하며 다양항 Address 모드를 사용할 수 있어야한다.</li>
<li class="">사용의 편리성 : 프로그램 작업을 위해 포인터, 프로그램 리로케이션 등의 편의를 제공해야한다.</li>
<li class="">주소공간과 기억공간의 독립성 : 프로그램에서 사용한 주소를 변경 없이 실제 기억공간 내의 주소로 재배치할 수 있도록 서로 독립적이여야한다.<!-- -->
<ul>
<li class="">주소공간 : 보조기억장치 내의 기억공간</li>
<li class="">기억공간 : 주기억장치 내의 기억공간</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=암시적-주소지정방식>암시적 주소지정방식<a href=#암시적-주소지정방식 class=hash-link aria-label="암시적 주소지정방식에 대한 직접 링크" title="암시적 주소지정방식에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">명령 실행에 필요한 데이터의 위치를 지정하지 않고 누산기나 스택의 데이터를 묵시적으로 지정하여 사용</li>
<li class="">오퍼랜드가 없는 명령이나 오퍼랜드가 1개인 명령어 형식에 사용</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=즉시적-주소지정방식>즉시적 주소지정방식<a href=#즉시적-주소지정방식 class=hash-link aria-label="즉시적 주소지정방식에 대한 직접 링크" title="즉시적 주소지정방식에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">명령어 자체에 오퍼랜드를 가지고 있는 방식</li>
<li class="">별도의 기억장소를 액세스하지 않기 때문에 실행 속도가 빠르다.</li>
<li class="">데이터 값 범위가 제한적이다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=직접-주소지정방식>직접 주소지정방식<a href=#직접-주소지정방식 class=hash-link aria-label="직접 주소지정방식에 대한 직접 링크" title="직접 주소지정방식에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">오퍼렌드부에 표현된 주소를 이용해 실제 데이터가 기억된 기억장소에 직접 매핑</li>
<li class="">실제 사용할 데이터의 유효주소를 적기 때문에 주소 길이에 제약을 받음</li>
<li class="">nBit 오퍼랜드부 => 2^n 개의 주소 표현 가능</li>
<li class="">오퍼렌드부에 데이터를 가지고 있는 레지스터의 번호를 지정하면 레지스터 모드</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=간접-주소지정방식>간접 주소지정방식<a href=#간접-주소지정방식 class=hash-link aria-label="간접 주소지정방식에 대한 직접 링크" title="간접 주소지정방식에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">주기억장치를 두 번 이상 접근하여 데이터가 있는 기억장소에 도달</li>
<li class="">오퍼랜드부에 할당된 비트 수로 주소를 나타낼 수 없을 때 사용하는 방식</li>
<li class="">명령어의 길이가 짧고 제한되어도 긴 주소에 접근이 가능한 방식</li>
<li class="">레지스터 간접모드</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=계산에-의한-주소지정방식>계산에 의한 주소지정방식<a href=#계산에-의한-주소지정방식 class=hash-link aria-label="계산에 의한 주소지정방식에 대한 직접 링크" title="계산에 의한 주소지정방식에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">오퍼랜드부와 CPU의 특정 레지스터 값이 더해져서 유효주소를 계산하는 방식</li>
<li class="">약식 주소</li>
<li class="">상대주소 : 명령어 주소 + PC</li>
<li class="">베이스 레지스터 : 명령어 주소 + Base Register<!-- -->
<ul>
<li class="">명령어의 시작주소를 가지고 있는 레지스터</li>
<li class="">베이스 레지스터의 값과 명령어에 포함된 변위값을 더해 유효주소를 얻는 것을 재배치라고 한다.</li>
</ul>
</li>
<li class="">인덱스 레지스터 : 명령어 주소 + Index Register</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=마이크로-오퍼레이션>마이크로 오퍼레이션<a href=#마이크로-오퍼레이션 class=hash-link aria-label="마이크로 오퍼레이션에 대한 직접 링크" title="마이크로 오퍼레이션에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">인스트럭션을 수행하기 위해 CPU 내의 레지스터와 플래그가 의미있는 상태변환을 하도록하는 동작</li>
<li class="">레지스터에 저장된 데이터에 의해 이루어진다.</li>
<li class="">한 개의 클록펄스 동안 실행되는 기본 동작</li>
<li class="">모든 마이크로 오퍼레이션은 CPU의 클록펄스에 맞춰 실행된다.</li>
<li class="">순서를 결정하기 위해 제어장치가 발생하는 신호를 제어신호</li>
<li class="">제어워드 : 레지스어틔 선택과 산술논리연산장치의 역할을 결정하고 어떤 마이크로 연산을 할 지 결정하는 비트의 모임 = 마이크로 명령어</li>
<li class="">마이크로 프로그램 : 제어워드가 저장되 있을 때 마이크로 프로그램</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=마이크로-사이클-타임>마이크로 사이클 타임<a href=#마이크로-사이클-타임 class=hash-link aria-label="마이크로 사이클 타임에 대한 직접 링크" title="마이크로 사이클 타임에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">한 개의 마이크로 오퍼레이션을 수행하는데 걸리는 시간</li>
<li class="">CPU는 클록펄스에 의해 동기화되어 동작하는데 펄스를 CPU 클록이라하며 한 개의 마이크로 오퍼레이션은 CPU 클록 발생 주기의 간격 내에 실행된다.</li>
<li class="">CPU Cycle Time = CPU Clock Time</li>
<li class="">CPU 속도를 나타내는 척도</li>
<li class="">1us = 10^-6s, 1ns = 10^-9s</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=동기-고정식>동기 고정식<a href=#동기-고정식 class=hash-link aria-label="동기 고정식에 대한 직접 링크" title="동기 고정식에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">모든 마이크로 오퍼레이션 동작시간이 같다고 가정해 클록 주기를 마이크로 사이클 타임과 같도록 정의하는 방식</li>
<li class="">동작 시간이 가장 긴 마이크로 오퍼레이션의 동작시간을 마이크로 사이클 타임으로 정한다.</li>
<li class="">모든 마이크로 오퍼레이션 동작시간이 비슷할 때 유리하다.</li>
<li class="">CPU 낭비가 심하다.</li>
<li class="">구현이 쉽다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=동기-가변식>동기 가변식<a href=#동기-가변식 class=hash-link aria-label="동기 가변식에 대한 직접 링크" title="동기 가변식에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">수행시간이 유사한 마이크로 오퍼레이션끼리 그룹을 만들어 그룹별로 서로 다른 마이크로 사이클 타임을 정의하는 방식</li>
<li class="">수행시간이 현저한 차이를 나타낼 때 사용</li>
<li class="">CPU 시간 낭비를 줄일 수 있다.</li>
<li class="">구현이 복잡하다.</li>
<li class="">각 그룹(집합) 간 서로 다른 사이클 타임의 동기를 맞추기 위해 그룹간 마이크로 사이클 타임을 정수배가 되게 한다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=비동기식>비동기식<a href=#비동기식 class=hash-link aria-label="비동기식에 대한 직접 링크" title="비동기식에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">모든 마이크로 오퍼레이션이 서로 다른 마이크로 사이클 타임을 가진다.</li>
<li class="">시간 낭비는 없다.</li>
<li class="">구현이 매우 복잡하다.</li>
<li class="">실제로 거의 사용되지 않는다.</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=메이저-스테이트>메이저 스테이트<a href=#메이저-스테이트 class=hash-link aria-label="메이저 스테이트에 대한 직접 링크" title="메이저 스테이트에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">현재 CPU가 무엇을 하고 있는가를 나타내는 상태</li>
<li class="">Fetch, Indirect, Execute, Interrupt</li>
<li class="">Major Cycle = Machine Cycle</li>
<li class="">메이저 스테이트 레지스터를 통해 알 수 있다.</li>
<li class="">F와 R 플립플롭의 상태에 따라 메이저 스테이트 상태가 결정된다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=fetch-cycle>Fetch Cycle<a href=#fetch-cycle class=hash-link aria-label="Fetch Cycle에 대한 직접 링크" title="Fetch Cycle에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">인출단계</li>
<li class="">중앙처리장치의 명령 레지스터로 명령어를 가져와 해독하는 단계</li>
<li class="">가장 먼저 수행되는 동작</li>
<li class="">1Cycle 명령어면 수행 후 다시 Fetch Cycle로 변경됨</li>
<li class="">1Cycle 명령어가 아니면 모드 비트에 따라 직 간접 주소를 판단</li>
<li class="">모드가 0이면 직접주소 => Execute 단계로</li>
<li class="">모드가 1이면 간접주소 => Indirect 단계로</li>
</ul>
<table><thead><tr><th style=text-align:center>Click Pulse<th style=text-align:center>Micro Operation<th style=text-align:center>Description<tbody><tr><td style=text-align:center>C0t0<td style=text-align:center>MAR ← PC<td style=text-align:center>PC의 번지를 MAR으로 전송<tr><td style=text-align:center>C0t1<td style=text-align:center>MBR ← M[MAR]<br/>PC ← PC +1<td style=text-align:center>MAR의 지정하는 위치의 <strong>값을 MBR에 전송</strong> 후<br/>다음 시행할 명령 위치를 지정<tr><td style=text-align:center>C0t2<td style=text-align:center>IR ← MBR[OP]<br/>I ← MBR[I]<td style=text-align:center>명령어의 OPCode를 명령 레지스터에 전송<br/>명령어의 모드 비트를 플립플롭 I에 전송<tr><td style=text-align:center>C0t3<td style=text-align:center>F ← 1 OR R ← 1<td style=text-align:center>I에 따라 F나 R에 1 전송</table>
<blockquote>
<ul>
<li class="">PC : 다음 실행할 명령의 주소가 들어있음</li>
<li class="">MAR : 저장하거나 읽어올 주기억장치의 주소가 들어있음</li>
<li class="">MBR : 주기억장치에서 읽어오거나 저장할 데이터가 들어있음</li>
<li class="">M[MAR] : 메모리에서 MAR에 해당하는 실제 데이터</li>
<li class="">IR : 현재 실행하는 명령어가 들어있음</li>
<li class="">OP : 명령 코드 부분</li>
<li class="">I : 모드 비트</li>
<li class="">AD : 명령 주소 부분</li>
<li class="">F, R : 다음 상태를 지정하는 플립플롭</li>
</ul>
</blockquote>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=indirect-cycle>Indirect Cycle<a href=#indirect-cycle class=hash-link aria-label="Indirect Cycle에 대한 직접 링크" title="Indirect Cycle에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Fetch 단계에서 해석한 주소를 읽어온 후 간접주소이면 유효주소를 계산하기 위해 다시 Indirect 단계를 수행</li>
<li class="">직접주소인 경우 Execute 단계 또는 Fetch 단계로 이동<!-- -->
<ul>
<li class="">분기같은 1Cycle 명령이면 Fetch로</li>
<li class="">실행이면 Execute로</li>
</ul>
</li>
</ul>
<table><thead><tr><th style=text-align:center>Click Pulse<th style=text-align:center>Micro Operation<th style=text-align:center>Description<tbody><tr><td style=text-align:center>C1t0<td style=text-align:center>MAR ← MBR[AD]<td style=text-align:center>MBR에 있는 명령어의 주소를 MAR에 전송<tr><td style=text-align:center>C1t1<td style=text-align:center>MBR ← M[MAR]<td style=text-align:center>MAR이 지정하는 메모리의 실제 데이터를 MBR에 전송<tr><td style=text-align:center>C1t2<td style=text-align:center>-<td style=text-align:center>동작없음<tr><td style=text-align:center>C1t3<td style=text-align:center>F ← 1, R ← 0<td style=text-align:center>Execute 단계로 이동</table>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=execute-cycle>Execute Cycle<a href=#execute-cycle class=hash-link aria-label="Execute Cycle에 대한 직접 링크" title="Execute Cycle에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">해석된 명령을 실행하는 단계</li>
<li class="">플래그 레지스터의 상태를 검사하여 Interrupt 단계로 갈지 결정</li>
</ul>
<table><thead><tr><th style=text-align:center>Click Pulse<th style=text-align:center>Micro Operation<th style=text-align:center>Description<tbody><tr><td style=text-align:center>C2t0<td style=text-align:center>MAR ← MBR[AD]<td style=text-align:center>MBR에 있는 명령어의 주소를 MAR에 전송<tr><td style=text-align:center>C2t1<td style=text-align:center>MBR ← M[MAR]<td style=text-align:center>MAR이 지정하는 메모리의 실제 데이터를 MBR에 전송<tr><td style=text-align:center>C2t2<td style=text-align:center>AC ← AC + MBR<td style=text-align:center>누산기에 값과 MBR의 값을 더해 ADD 연산 실행<tr><td style=text-align:center>C2t3<td style=text-align:center>F ← 0 OR R ← 1<td style=text-align:center>F = 0이면 Fetch로, R = 1이면 Interrupt로</table>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=interrupt-cycle>Interrupt Cycle<a href=#interrupt-cycle class=hash-link aria-label="Interrupt Cycle에 대한 직접 링크" title="Interrupt Cycle에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">인터럽트 발생시 복귀주소를 저장시키고 인터럽트 처리 프로그램의 첫 번째 명령으로 제어순서를 옮긴다.</li>
<li class="">인터럽트 단계는 항상 Fetch 단계로 이동된다.</li>
<li class="">메모리의 인터럽트 주소는 0번지에 저장되고, 인터럽트 벡터는 인터럽트 처리 프로그램의 주소 번지를 말한다.</li>
<li class="">현재 상태를 저장하고 인터럽트가 처리된다.</li>
<li class="">인터럽트 처리시 다음 실행주소를 PC에 넣고 인터럽트 벡터로 이동한다.</li>
</ul>
<table><thead><tr><th style=text-align:center>Click Pulse<th style=text-align:center>Micro Operation<th style=text-align:center>Description<tbody><tr><td style=text-align:center>C3t0<td style=text-align:center>MBR[AD] ← PC<br/>PC ← 0<td style=text-align:center>다음 실행 명령 주소를 MBR의 주소로 전송<br/> 복귀주소를 저장할 0번지를 PC에 전송<tr><td style=text-align:center>C3t1<td style=text-align:center>MAR ← PC<br/>PC ← PC + 1<td style=text-align:center>PC가 가진 0값 번지를 MAR에 전송<br/>인터럽트 벡터 위치를 지정하기 위해 PC 값을 1로 세팅<tr><td style=text-align:center>C3t2<td style=text-align:center>M[MAR] ← MBR<br/>IEN ← 0<td style=text-align:center>MBR에 있는 다음 실행 명령 주소를 0번지에 저장<br/>다른 인터럽트가 발생하지 않게 IEN에 0 전송<tr><td style=text-align:center>C3t3<td style=text-align:center>F ← 0, R ← 0<td style=text-align:center>항상 Fetch로</table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=주요-마이크로-오퍼레이션>주요 마이크로 오퍼레이션<a href=#주요-마이크로-오퍼레이션 class=hash-link aria-label="주요 마이크로 오퍼레이션에 대한 직접 링크" title="주요 마이크로 오퍼레이션에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=and-1>AND<a href=#and-1 class=hash-link aria-label="AND에 대한 직접 링크" title="AND에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">AC와 메모리의 내용을 AND 연산해서 AC에 저장</li>
<li class="">논리곱 연산</li>
<li class="">AC ← AC ∧ MBR</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=add>ADD<a href=#add class=hash-link aria-label="ADD에 대한 직접 링크" title="ADD에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">AC와 메모리의 내용을 더해서 AC에 저장</li>
<li class="">AC ← AC +MBR</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=lda>LDA<a href=#lda class=hash-link aria-label="LDA에 대한 직접 링크" title="LDA에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">메모리의 내용을 AC로 Load하는 명령</li>
<li class="">AC에 0을 전송하여 AC를 초기화하는 부분이 있어야함</li>
<li class=""><strong>AC ← 0</strong></li>
<li class="">AC ← AC + MBR</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=sta>STA<a href=#sta class=hash-link aria-label="STA에 대한 직접 링크" title="STA에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">AC의 내용을 메모리에 저장</li>
<li class="">M[MAR] ← MBR</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=bun>BUN<a href=#bun class=hash-link aria-label="BUN에 대한 직접 링크" title="BUN에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">실행 명령의 위치를 변경하는 무조건 분기</li>
<li class="">Branch UNconditionally</li>
<li class="">PC ← MBR[AD]</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=bsa>BSA<a href=#bsa class=hash-link aria-label="BSA에 대한 직접 링크" title="BSA에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">복귀주소를 저장하고 부 프로그램을 호출하는 명령</li>
<li class="">Branch and Save Return Address</li>
</ul>
<table><thead><tr><th style=text-align:center>Click Pulse<th style=text-align:center>Micro Operation<th style=text-align:center>Description<tbody><tr><td style=text-align:center>C2t0<td style=text-align:center>MAR ← MBR[AD]<br/>MBR[AD] ← PC<br/>PC ← MBR[AD]<td style=text-align:center>복귀주소를 MAR에 전송<br/>PC의 값을 MBR의 주소로 전송<br/>부프로그램 호출직전 MBR의 주소를 PC로 전송<tr><td style=text-align:center>C2t1<td style=text-align:center>M[MAR] ← MBR[AD]<td style=text-align:center>부프로그램 호출직전 복귀주소 저장<tr><td style=text-align:center>C2t2<td style=text-align:center>PC ← PC + 1<td style=text-align:center>부 프로그램 시작<tr><td style=text-align:center>C2t3<td style=text-align:center>F ← 0 OR R ← 1<td style=text-align:center>Fetch 또는 Interrupt</table>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=isz>ISZ<a href=#isz class=hash-link aria-label="ISZ에 대한 직접 링크" title="ISZ에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">메모리의 값을 읽고 값을 1 증가 시킨 후 그 값이 0이면 현재 명령을 건너 뛰고 다음으로 이동</li>
<li class="">IF(MBR=0) THEN ← PC + 1</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=제어기>제어기<a href=#제어기 class=hash-link aria-label="제어기에 대한 직접 링크" title="제어기에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=제어데이터>제어데이터<a href=#제어데이터 class=hash-link aria-label="제어데이터에 대한 직접 링크" title="제어데이터에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">제어장치가 제어신호를 발생하기 위한 자료</li>
<li class="">CPU가 특정한 메이저 상태와 타이밍 상태에 있을 때 제어 자료에 따른 제어 규칙에 의해 발생한다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=종류-1>종류<a href=#종류-1 class=hash-link aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">메이저 스테이트 사이의 변천을 제어하는 데이터</li>
<li class="">중앙처리장치의 제어점을 제어하는 데이터</li>
<li class="">인스트럭션의 수행 순서를 결정하는데 필요한 제어데이터</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=단계>단계<a href=#단계 class=hash-link aria-label="단계에 대한 직접 링크" title="단계에 대한 직접 링크" translate=no>​</a></h4>
<table><thead><tr><th style=text-align:center>구분<th style=text-align:center>State간 변이<th style=text-align:center>제어점 제어<th style=text-align:center>수행 순서제어<tbody><tr><td style=text-align:center><strong>Fetch</strong><td style=text-align:center>명령어의 주소지정방식<td style=text-align:center>명령어<td style=text-align:center>PC<tr><td style=text-align:center><strong>Indirect</strong><td style=text-align:center>주소지정방식<td style=text-align:center>유효주소<td style=text-align:center>-<tr><td style=text-align:center><strong>Execute</strong><td style=text-align:center>인터럽트 요청<td style=text-align:center>명령어 연산자<td style=text-align:center>PC<tr><td style=text-align:center><strong>Interrupt</strong><td style=text-align:center>-<td style=text-align:center>Interrupt따라 다름<td style=text-align:center>Interrupt따라 다름</table>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=구현>구현<a href=#구현 class=hash-link aria-label="구현에 대한 직접 링크" title="구현에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">하드웨어적 고정배선제어장치</li>
<li class="">소프트웨어적 마이크로 프로그래밍 기법</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=고정배선-제어장치>고정배선 제어장치<a href=#고정배선-제어장치 class=hash-link aria-label="고정배선 제어장치에 대한 직접 링크" title="고정배선 제어장치에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">독립 제어점에 제어신호를 가해야 할 조건들을 제어 데이터와 제어기의 상태로 표현한 후 이를 만족하는 조합논리회로를 설계하여 해당 제어점에 연결하는 방식</li>
<li class="">하드웨어적 구성방법</li>
<li class="">속도 빠름</li>
<li class="">비싸다.</li>
<li class="">RISC구조를 기본으로 하는 컴퓨터에서 주로 사용</li>
<li class="">한 번 만들어진 명령어 세트를 변경할 수 없음</li>
<li class="">회로 구성이 복잡</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=마이크로-프로그래밍>마이크로 프로그래밍<a href=#마이크로-프로그래밍 class=hash-link aria-label="마이크로 프로그래밍에 대한 직접 링크" title="마이크로 프로그래밍에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">내부 제어 신호를 지정하는 여러가지 마이크로 인스트럭션으로 작성하는 것</li>
<li class="">소프트웨어적 구성방법</li>
<li class="">펌웨어를 이용하는 방식</li>
<li class="">마이크로 프로그램된 제어장치를 사용하는 컴퓨터는 주 메모리 외에 마이크로 프로그램이 저장되는 제어메모리(ROM)이 필요하다.</li>
<li class="">명령어 세트를 쉽게 변경할 수 있다.</li>
<li class="">다양한 어드레스 모드를 갖음</li>
<li class="">속도 느림</li>
<li class="">유지보수 및 수정 용이</li>
<li class="">복잡한 명령 세트를 가진 시스템에 적합</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=제어-메모리-번지-결정>제어 메모리 번지 결정<a href=#제어-메모리-번지-결정 class=hash-link aria-label="제어 메모리 번지 결정에 대한 직접 링크" title="제어 메모리 번지 결정에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">제어 주소 레지스터(CAR) : 값을 1 증가<!-- -->
<ul>
<li class="">매핑의 결과값</li>
<li class="">주소 필드</li>
<li class="">서브루틴 레지스터 데이터</li>
</ul>
</li>
<li class="">명령 레지스터(IR) : 지정하는 번지로 무조건 분기, 주소 필드로부터 제어 메모리의 주소로 매핑</li>
<li class="">상태 레지스터(SR) : 조건에 따른 분기</li>
<li class="">서브루틴의 호출(call)과 복귀(return)</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=형식>형식<a href=#형식 class=hash-link aria-label="형식에 대한 직접 링크" title="형식에 대한 직접 링크" translate=no>​</a></h3>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=수평-마이크로-명령>수평 마이크로 명령<a href=#수평-마이크로-명령 class=hash-link aria-label="수평 마이크로 명령에 대한 직접 링크" title="수평 마이크로 명령에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Horizontal Micro Instruction</li>
<li class="">한 비트가 한 개의 마이크로 동작을 관할하는 명령</li>
<li class="">마이크로 오퍼레이션 부가 nBit일 때 n개의 마이크로 동작 표현 가능</li>
<li class="">제어 비트를 디코딩 할 필요가 없다.</li>
<li class="">마이크로 명령 한 개로 여러 개의 하드웨어를 동시에 동작시킬 수 있다.</li>
<li class="">제어 워드의 길이가 길어진다.</li>
<li class="">비트가 충분히 활용되지 못함.</li>
<li class="">비용이 많이 든다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=수직-마이크로-명령>수직 마이크로 명령<a href=#수직-마이크로-명령 class=hash-link aria-label="수직 마이크로 명령에 대한 직접 링크" title="수직 마이크로 명령에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Vertical Micro Instruction</li>
<li class="">제어 메모리 외부에서 디코딩 회로를 필요로 하는 마이크로 명령</li>
<li class="">디코더의 출력을 제어신호로 사용</li>
<li class="">한 개의 마이크로 동작만 제어 가능</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=나노-명령>나노 명령<a href=#나노-명령 class=hash-link aria-label="나노 명령에 대한 직접 링크" title="나노 명령에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Nano Instruction</li>
<li class="">나노메모리(낮은 레벨의 메모리)에 저장된 마이크로 명령</li>
<li class="">수직 마이크로 명령을 수행하는 제어기에서 디코더를 ROM(나노메모리)로 바꿔 두 메모리 레벨로 구성</li>
<li class="">제어 메모리의 각 워드는 나노 메모리의 번지를 저장</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=제어장치-구현방식>제어장치 구현방식<a href=#제어장치-구현방식 class=hash-link aria-label="제어장치 구현방식에 대한 직접 링크" title="제어장치 구현방식에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">상태 플리플롭 제어</li>
<li class="">PLA (Programmable Logic Array)</li>
<li class="">마이크로 프로그램 제어</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=입출력장치>입출력장치<a href=#입출력장치 class=hash-link aria-label="입출력장치에 대한 직접 링크" title="입출력장치에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=입출력-제어장치>입출력 제어장치<a href=#입출력-제어장치 class=hash-link aria-label="입출력 제어장치에 대한 직접 링크" title="입출력 제어장치에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">입출력장치와 컴퓨터 사이의 자료 전송을 제어하는 장치</li>
<li class="">데이터 버퍼 레지스터를 이용하여 두 장치간의 속도 차를 조절 = 데이터 버퍼링</li>
<li class="">제어 신호의 논리적, 물리적 변환 및 오류를 제어</li>
<li class="">DMA, 채널, 입출력 프로세서, 입출력 컴퓨터가 포함된다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=입출력-인터페이스>입출력 인터페이스<a href=#입출력-인터페이스 class=hash-link aria-label="입출력 인터페이스에 대한 직접 링크" title="입출력 인터페이스에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">동작방식이나 데이터 형식이 다른 컴퓨터 내부의 장치끼리 2진 데이터를 원활하게 전송하기 위함</li>
<li class="">CPU와 주변장치의 전송속도, 동작방식, 워드형식의 차이 제어</li>
<li class="">동작방식이 다른 주변장치끼리의 차이 제어</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=입출력-버스>입출력 버스<a href=#입출력-버스 class=hash-link aria-label="입출력 버스에 대한 직접 링크" title="입출력 버스에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">주기억장치와 입출력장치 사이의 데이터 전송을 위해 <strong>모든 주변장치의 인터페이스에 공통으로 연결된 버스</strong></li>
<li class="">구성<!-- -->
<ul>
<li class="">데이터 버스</li>
<li class="">주소 버스</li>
<li class="">제어 버스</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=기억장치와-입출력장치의-차이>기억장치와 입출력장치의 차이<a href=#기억장치와-입출력장치의-차이 class=hash-link aria-label="기억장치와 입출력장치의 차이에 대한 직접 링크" title="기억장치와 입출력장치의 차이에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">기억장치 : 전자적, 빠르다, 타율, 오류 적음, Word단위</li>
<li class="">입출력장치 : 기계적, 느리다, 자타율, 오류 많음, Byte(문자)단위</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=비동기-데이터-전송>비동기 데이터 전송<a href=#비동기-데이터-전송 class=hash-link aria-label="비동기 데이터 전송에 대한 직접 링크" title="비동기 데이터 전송에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">비동기 데이터 전송을 하기 위해선 데이터 전송시각을 알기 위한 제어신호를 서로 교환하여 송수신 상태를 서로 맞춰야한다.</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=스트로브-펄스>스트로브 펄스<a href=#스트로브-펄스 class=hash-link aria-label="스트로브 펄스에 대한 직접 링크" title="스트로브 펄스에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Strobe Pulse</li>
<li class="">데이터 버스와 한 개의 제어선</li>
<li class="">스트로브 신호 : 두 개의 독립적인 장치 사이의 비동기적인 데이터 전송을 하기 위해 전송 시각을 알리는 제어 신호</li>
<li class="">메모리와 CPU 사이의 정보를 교환할 때 사용</li>
<li class="">수신장치가 데이터를 받았는지는 모름</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=핸드쉐이킹>핸드쉐이킹<a href=#핸드쉐이킹 class=hash-link aria-label="핸드쉐이킹에 대한 직접 링크" title="핸드쉐이킹에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">데이터 전송시 송신측과 수신측에서 입출력의 준비나 완료를 나타내는 신호를 사용하여 서로의 동작을 확인하면서 데이터를 전송</li>
<li class="">전송을 시작한 장치에 응답하는 제 2의 제어신호를 전송</li>
<li class="">높은 융통성과 신뢰성</li>
<li class="">병렬 입출력 데이터 전송방식의 기본으로 많이 사용</li>
<li class="">2~3개의 제어선 사용</li>
<li class="">RDY, STB 신호 사용</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=스풀링>스풀링<a href=#스풀링 class=hash-link aria-label="스풀링에 대한 직접 링크" title="스풀링에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">다중 프로그래밍 환경 아래에서 용량이 크고 신속한 액세스가 가능한 디스크를 이용해 각 사용자 프로그램이 입출력할 데이터를 직접 입출력장치로 보내지 않고 디스크에 모았다가 한꺼번에 입출력 시키는 방법</li>
<li class="">입출력장치의 공유 및 느린 처리속도를 보완</li>
<li class="">디스크의 일부를 매우 큰 버퍼로 사용한다.</li>
<li class="">큐 방식의 입출력을 수행</li>
<li class="">Simultaneous Peripheral Operation OnLine</li>
<li class="">보조기억장치에 저장</li>
<li class="">다중 작업</li>
<li class="">소프트웨어 구현</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=버퍼링>버퍼링<a href=#버퍼링 class=hash-link aria-label="버퍼링에 대한 직접 링크" title="버퍼링에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">입출력 장치와 CPU의 속도차를 해결하기 위해 사용</li>
<li class="">주기억 장치에 저장</li>
<li class="">단일 작업</li>
<li class="">하드웨어 구현</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=입출력-제어방식>입출력 제어방식<a href=#입출력-제어방식 class=hash-link aria-label="입출력 제어방식에 대한 직접 링크" title="입출력 제어방식에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">입출력 처리 능력 순서 : 프로그램 &lt; 인터럽트 &lt; DMA &lt; 채널</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=programmed-io>Programmed I/O<a href=#programmed-io class=hash-link aria-label="Programmed I/O에 대한 직접 링크" title="Programmed I/O에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">폴링</li>
<li class="">원하는 I/O가 완료되었는지 여부를 검사하기 위해 CPU의 Status Flag를 계속 조사해 I/O가 완료되었으면 MDR(MBR)과 AC사이의 자료 전송도 CPU가 직접 처리하는 방식</li>
<li class="">입출력의 대부분을 CPU가 해준다.</li>
<li class="">MDR(MBR), Flag(PSW), 장치번호 디코더로 구성</li>
<li class="">CPU가 계속 I/O에 관여해야되기 때문에 비효율적</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=interrupt-io>Interrupt I/O<a href=#interrupt-io class=hash-link aria-label="Interrupt I/O에 대한 직접 링크" title="Interrupt I/O에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">데이터 전송 준비가 되면 입출력 인터페이스가 컴퓨터에게 알려 I/O가 이루어지는 방식</li>
<li class="">입출력 인터페이스가 CPU에게 인터럽트 신호를 전송</li>
<li class="">수행중인 프로그램의 <strong>인스트럭션을 끝내고</strong> I/O 처리후 다시 복귀</li>
<li class="">대량 자료 전송시 CPU에 부담</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=dma-io>DMA I/O<a href=#dma-io class=hash-link aria-label="DMA I/O에 대한 직접 링크" title="DMA I/O에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Direct Memory Access</li>
<li class="">입출력장치가 직접 주기억장치를 접근하여 데이터 블록을 입출력하는 방식</li>
<li class="">I/O가 CPU를 경유하지 않음</li>
<li class="">CPU는 I/O에 필요한 정보를 DMA 제어기에 전달해 I/O동작만을 개시하고 끝<!-- -->
<ul>
<li class="">I/O 장치의 주소</li>
<li class="">데이터 있는 주기억장치의 시작 주소</li>
<li class="">DMA 시작 명령</li>
<li class="">I/O 데이터 양</li>
<li class="">입력 또는 출력을 결정하는 명령</li>
</ul>
</li>
<li class="">빠른 데이터 전송 가능</li>
<li class="">DMA는 인터럽트 신호를 발생해 CPU에게 I/O 종료를 알림</li>
<li class="">블록으로 대용량 데이터 전송 가능</li>
<li class="">CPU의 <strong>Cycle Steal</strong> 해 메모리를 접근하여 I/O 데이터를 전송<!-- -->
<ul>
<li class="">데이터 채널과 CPU가 주기억장치를 동시에 접근할 때 우선순위를 전자에게 줌</li>
<li class="">CPU는 그동안 메모리 참조가 필요없는 오퍼레이션을 계속 진행</li>
<li class="">CPU의 상태 보존이 필요 없음</li>
</ul>
</li>
<li class="">CPU와 DMA 제어기는 메모리와 버스를 공유</li>
<li class="">명령 받고 => 버스 사용 요구 => 버스 사용 허가 => 데이터 전송 => 인터럽트 전송</li>
<li class="">한 개의 인스트럭션에 의해 한 개의 블록을 입출력</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=구성>구성<a href=#구성 class=hash-link aria-label="구성에 대한 직접 링크" title="구성에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">인터페이스 회로</li>
<li class="">주소 레지스터 및 주소 라인</li>
<li class="">워드 카운트 레지스터 = 단어 계수기</li>
<li class="">제어 레지스터</li>
<li class="">데이터 레지스터</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=channel-io>Channel I/O<a href=#channel-io class=hash-link aria-label="Channel I/O에 대한 직접 링크" title="Channel I/O에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">I/O 프로세서</li>
<li class="">I/O를 위한 특별한 명령어를 I/O 프로세서에게 수행토록 하여 CPU 관여 없이 주기억장치와 입출력장치 사이에서 I/O를 하는 전용 프로세서</li>
<li class="">DMA의 한계를 극복하기 위해 고안</li>
<li class="">DMA의 방법으로 입출력을 수행하지만 확장된 개념</li>
<li class="">채널 제어기는 채널 명령어로 작성된 채널 프로그램을 해독하고 실행하여 I/O 처리</li>
<li class="">CPU로 I/O 명령어를 받으면 CPU와는 독립적으로 동작</li>
<li class="">주기억장치에 저장된 채널 프로그램의 수행과 데이터 전송을 위해 주기억장치에 직접 접근</li>
<li class="">I/O 장치는 제어장치를 통해 채널과 연결</li>
<li class="">I/O 채널은 CPU의 I/O 명령을 수행하지 않고 I/O 채널 내의 특별한 명령어를 수행</li>
<li class="">CPU와는 인터럽트로 통신</li>
<li class="">한 개의 인스트럭션에 의해 여러 개의 블록을 입출력</li>
<li class="">입출력장치와 주기억장치를 연결하는 중개자</li>
<li class="">입출력 전담장치</li>
<li class="">입출력 장치와 CPU사이의 존재하는 현저한 속도차를 극복하기 위한 장치</li>
<li class="">CPU의 명령을 받고 입출력을 시작하면 CPU와는 독립적으로 조작하는 장치</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=채널-명령어>채널 명령어<a href=#채널-명령어 class=hash-link aria-label="채널 명령어에 대한 직접 링크" title="채널 명령어에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">명령코드</li>
<li class="">데이터 주소</li>
<li class="">플래그</li>
<li class="">워드 카운터</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=종류-2>종류<a href=#종류-2 class=hash-link aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Selector Channel<!-- -->
<ul>
<li class="">선택 채널</li>
<li class="">고속 입출력장치(자기로 시작하는 친구들)와 입출력하기 위해 사용</li>
<li class="">특정 한 개의 장치를 독점해서 입출력</li>
</ul>
</li>
<li class="">MultiPlexer Channel<!-- -->
<ul>
<li class="">다중채널</li>
<li class="">저속 입출력장치(카드리터, 프린터)를 제어하는 채널</li>
<li class="">동시에 여러 개의 입출력장치 제어</li>
</ul>
</li>
<li class="">Block Multiplexer Channel<!-- -->
<ul>
<li class="">고속 입출력장치를 제어</li>
<li class="">동시에 여러 개의 입출력장치 제어</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=인터럽트>인터럽트<a href=#인터럽트 class=hash-link aria-label="인터럽트에 대한 직접 링크" title="인터럽트에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">프로그램 실행 도중 예기치 않은 상황이 발생하는 경우 현재 작업을 즉시 중단하고 발생된 상황을 우선 처리 후 실행 중인 작업으로 복귀</li>
<li class="">내부 인터럽트는 CPU의 하드웨어 신호에 의해 발생</li>
<li class="">소프트웨어 인터럽트는 명령어의 수행에 의해 발생</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=외부-인터럽트>외부 인터럽트<a href=#외부-인터럽트 class=hash-link aria-label="외부 인터럽트에 대한 직접 링크" title="외부 인터럽트에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">입출력장치, 타이밍장치, 전원 등 외부 요인에 의해 발생</li>
<li class="">전원 이상 인터럽트 : 정전이거나 정원이상</li>
<li class="">기게 착오 인터럽트 : CPU의 기능적인 오류 동작 발생</li>
<li class="">외부 신호 인터럽트<!-- -->
<ul>
<li class="">Time Slice 를 알림</li>
<li class="">인터럽트 키를 누른 경우 (Ctrl + Alt + Del)</li>
<li class="">외부 장치로부터 인터럽트 요청이 있는 경우</li>
</ul>
</li>
<li class="">입출력 인터럽트<!-- -->
<ul>
<li class="">입출력 데이터의 오류나 이상현상 발생</li>
<li class="">입출력장치가 데이터 전송을 요구하거나 전송이 끝났을 때</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=내부-인터럽트>내부 인터럽트<a href=#내부-인터럽트 class=hash-link aria-label="내부 인터럽트에 대한 직접 링크" title="내부 인터럽트에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">잘못된 명령이나 데이터를 사용할 때 발생</li>
<li class=""><strong>트랩</strong></li>
<li class="">프로그램 검사 인터럽트<!-- -->
<ul>
<li class="">0으로 나누기</li>
<li class="">오버플로 또는 언더플로</li>
<li class="">프로그램에서 명령어 잘못 사용</li>
<li class="">부당한 기억장소의 참조</li>
<li class="">프로그램상 오류</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=소프트웨어-인터럽트>소프트웨어 인터럽트<a href=#소프트웨어-인터럽트 class=hash-link aria-label="소프트웨어 인터럽트에 대한 직접 링크" title="소프트웨어 인터럽트에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">프로그램 처리중 <strong>명령의 요청에 의해 발생</strong></li>
<li class=""><strong>SVC 인터럽트</strong>
<ul>
<li class="">제어 프로그램 호출 인터럽트 = SuperVisor Call</li>
<li class="">사용자가 SVC 명령을 써서 의도적으로 호출한 경우</li>
<li class="">복잡한 입출력 처리를 해야하는 경우</li>
<li class="">기억장치 할당 및 오퍼레이터와 대화를 해야하는 경우</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=인터럽트시-cpu확인-요소>인터럽트시 CPU확인 요소<a href=#인터럽트시-cpu확인-요소 class=hash-link aria-label="인터럽트시 CPU확인 요소에 대한 직접 링크" title="인터럽트시 CPU확인 요소에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">프로그램 카운터 내용</li>
<li class="">사용한 모든 레지스터의 내용</li>
<li class="">상태 조건의 내용 = PSW = Status Register</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=동작-원리>동작 원리<a href=#동작-원리 class=hash-link aria-label="동작 원리에 대한 직접 링크" title="동작 원리에 대한 직접 링크" translate=no>​</a></h3>
<ol>
<li class="">인터럽트 요청 신호 발생</li>
<li class="">현재 인스트럭션까지 실행 후 프로그램 실행 중단</li>
<li class="">현재 프로그램 상태 보존</li>
<li class="">인터럽트 처리 루틴 실행</li>
<li class="">인터럽트 서비스(취급) 루틴 실행</li>
</ol>
<ul>
<li class="">처리기 상태 복구</li>
<li class="">인터럽트 원인 결정</li>
<li class="">처리기 레지스터의 상태 보존</li>
<li class="">상대적으로 낮은 레벨의 마스크 레지스터 클리어</li>
</ul>
<ol start=6>
<li class="">상태 복구</li>
<li class="">중단된 프로그램 실행 재개</li>
</ol>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=인터럽트-우선순위>인터럽트 우선순위<a href=#인터럽트-우선순위 class=hash-link aria-label="인터럽트 우선순위에 대한 직접 링크" title="인터럽트 우선순위에 대한 직접 링크" translate=no>​</a></h2>
<ol>
<li class="">전원 이상 = Power Fail</li>
<li class="">기계 착오 = Machine Check</li>
<li class="">외부 신호 = External</li>
<li class="">입출력 = I/O</li>
<li class="">명령어 잘못</li>
<li class="">프로그램 = Program Check</li>
<li class="">SVC = Supervisor Call</li>
</ol>
<ul>
<li class="">Non Maskable Interrupt : 마스크 불가능 인터럽트로 0순위</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=폴링>폴링<a href=#폴링 class=hash-link aria-label="폴링에 대한 직접 링크" title="폴링에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">소프트웨어적 인터럽트 우선순위 판별 방식</li>
<li class="">우선순위가 높은 인터럽트 자원의 인터럽트 요청 플래그를 검사해 해당하는 인터럽트 서비스 루틴을 수행</li>
<li class="">우선순위 변경이 쉽다.</li>
<li class="">자기디스크와 같이 속도가 빠른 장치에 높은 등급 부여</li>
<li class="">회로가 간단하고 융통성이 있음</li>
<li class="">별도의 하드웨어가 필요 없어 경제적</li>
<li class="">많은 인터럽트가 있을 때 모두 조사해야하므로 반응시간이 느림</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=벡터-인터럽트>벡터 인터럽트<a href=#벡터-인터럽트 class=hash-link aria-label="벡터 인터럽트에 대한 직접 링크" title="벡터 인터럽트에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">하드웨어적인 인터럽트 판별 방식</li>
<li class="">CPU와 인터럽트를 요청할 수 있는 장치 사이에 장치 번호에 해당하는 버스를 연결하여 요청 장치의 번호를 CPU에게 알리는 방식</li>
<li class="">인터럽트를 발생한 장치가 프로세서에게 분기할 곳에 대한 정보를 제공</li>
<li class="">인터럽트 벡터 : 인터럽트 처리 루틴으로 분기하는 명령어만을 기억하는 기억장치의 특정 영역으로 분기번지가 저장됨</li>
<li class="">별도의 프로그램 루틴이 없어 응답속도가 빠름</li>
<li class="">회로가 복잡하고 융통성이 없음</li>
<li class="">추가 하드웨어가 필요하므로 비경제적</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=직렬-우선순위>직렬 우선순위<a href=#직렬-우선순위 class=hash-link aria-label="직렬 우선순위에 대한 직접 링크" title="직렬 우선순위에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class=""><strong>데이지 체인 방식</strong></li>
<li class="">모든 장치를 한 개의 회선에 <strong>직렬</strong>로 연결</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=병렬-우선순위>병렬 우선순위<a href=#병렬-우선순위 class=hash-link aria-label="병렬 우선순위에 대한 직접 링크" title="병렬 우선순위에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">인터럽트가 발생하는 각 장치를 개별적인 회선으로 연결</li>
<li class="">각 비트를 개별적으로 세트할 수 있는 <strong>Mask Register</strong> 사용</li>
<li class="">마스크 레지스터는 인터럽트 요청의 허락이 가능하다.</li>
<li class="">우선순위는 마스크 레지스터의 비트 위치에 의해서 결정</li>
<li class="">우선순위가 높은 것이 서비스 받고 있을 때 우선순위가 낮은 것을 비활성화시킬 수 있다.</li>
<li class="">높은 우선순위의 인터럽트는 낮은 인터럽트가 처리되는 중에도 우선 처리된다.</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=기억장치>기억장치<a href=#기억장치 class=hash-link aria-label="기억장치에 대한 직접 링크" title="기억장치에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">주기억장치 : 시스템 프로그램영역과 사용자 프로그램영역으로 구성<!-- -->
<ul>
<li class="">반도체 : RAM, ROM</li>
<li class="">자기 : 자기 코어</li>
</ul>
</li>
<li class="">보조기억장치<!-- -->
<ul>
<li class="">DASD : 자기 디스크, 자기 드럼, 하드 디스크, 광디스크</li>
<li class="">SASD : 자기테이프</li>
</ul>
</li>
<li class="">특수기억장치 : 복수 모듈 기억장치, 연관기억장치, 캐시기억장치, 가상기억장치</li>
<li class="">광디스크의 종류 : 블루레이, DVD, Compact</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=계층구조>계층구조<a href=#계층구조 class=hash-link aria-label="계층구조에 대한 직접 링크" title="계층구조에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">특수기억장치 : 레지스터, 캐시, 연관</li>
<li class="">주기억장치 : RAM, ROM, 자기코어</li>
<li class="">보조기억장치 : 자기디스크, 자기테이프</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=특성-결정-요소>특성 결정 요소<a href=#특성-결정-요소 class=hash-link aria-label="특성 결정 요소에 대한 직접 링크" title="특성 결정 요소에 대한 직접 링크" translate=no>​</a></h3>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=기억-용량>기억 용량<a href=#기억-용량 class=hash-link aria-label="기억 용량에 대한 직접 링크" title="기억 용량에 대한 직접 링크" translate=no>​</a></h4>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=access-time>Access Time<a href=#access-time class=hash-link aria-label="Access Time에 대한 직접 링크" title="Access Time에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">기억장치에 읽기 요청이 발생한 시간부터 요구한 정보를 꺼내서 사용 가능할 때까지의 시간</li>
<li class="">한 Word의 단위 정보를 읽거나 기록하는데 걸리는 시간</li>
<li class="">Access Time = Seek Time + Latency Time(Search Time) + Transmission Time</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=cycle-time>Cycle Time<a href=#cycle-time class=hash-link aria-label="Cycle Time에 대한 직접 링크" title="Cycle Time에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">기억장치에 읽기 신호를 보낸 후 다시 읽기 신호를 보낼 수 있을 때까지의 시간 간격</li>
<li class="">Cycle Time ≥ Access Time</li>
<li class="">DRAM : Cycle Time = Access Time + Refresh Time</li>
<li class="">자기코어 : Cycle Time = Access Time + Restoration Time</li>
<li class=""><strong>기타 모든 장치</strong> : Cycle Time = Access Time</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=bandwitdh>Bandwitdh<a href=#bandwitdh class=hash-link aria-label="Bandwitdh에 대한 직접 링크" title="Bandwitdh에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">대역폭 = 전송률 = 밴드폭</li>
<li class="">메모리에서 또는 메모리까지 1초동안 전송되는 최대한의 정보량</li>
<li class="">기억장치의 자료 처리 속도를 나타내는 단위</li>
<li class="">하드웨어 특성상 주기억장치가 제공할 수 있는 정보 전달능력의 한계를 의미</li>
<li class="">메모리 워드의 길이가 작을수록 대역폭이 좋음</li>
<li class="">전송단위 : bps = Baud = 보</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=구분>구분<a href=#구분 class=hash-link aria-label="구분에 대한 직접 링크" title="구분에 대한 직접 링크" translate=no>​</a></h3>
<table><thead><tr><th style=text-align:center>구분방식<th>내용<tbody><tr><td style=text-align:center>내용보존여부<td>파괴성 메모리 : 읽으면 내용이 파괴되므로 재저장시간이 필요<br/> 비파괴성 메모리<tr><td style=text-align:center>전원차단시<br/>내용소멸여부<td>휘발성메모리 : RAM<br/> 비휘발성 메모리 : ROM, 자기코어, 보조기억장치<tr><td style=text-align:center>재충전 여부<td>정적메모리(SRAM) : 전원이 공급되면 내용이 계속 유지<br/> 전원이 공급되도 일정시간 후 내용 지워져 재충전필요<tr><td style=text-align:center>접근 방식<td>순차접근 : 자기테이프<br/> 직접접근 : 자기테이프 제외 모든장치</table>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=주기억장치>주기억장치<a href=#주기억장치 class=hash-link aria-label="주기억장치에 대한 직접 링크" title="주기억장치에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=rom>ROM<a href=#rom class=hash-link aria-label="ROM에 대한 직접 링크" title="ROM에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Read Only Memory</li>
<li class="">읽기전용</li>
<li class="">비휘발성 메모리</li>
<li class="">BIOS, 자가진단프로그램 등 변경 가능성이 거의 없는 시스템 소프트웨어 탑재</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=종류-3>종류<a href=#종류-3 class=hash-link aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Mask ROM : 제조 공장에서 프로그램되어 나옴, 내용 변경 불가</li>
<li class="">PROM : Programmable ROM, 한 번만 쓰기 가능</li>
<li class="">EPROM : Erasable PROM, 자외선을 사용해 내용을 지울 수 있음</li>
<li class="">EAROM : Erasable Alterable ROM, 전기적 특성을 이용하여 기록된 정보 일부를 바꿀 수 있는 ROM</li>
<li class="">EEPROM : Electonic EPROM, 전기를 이용해 내용 수정 가능</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=ram>RAM<a href=#ram class=hash-link aria-label="RAM에 대한 직접 링크" title="RAM에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Random Access Memory, Read Write Memory</li>
<li class="">현재 사용중인 프로그램이나 데이터가 저장</li>
<li class="">휘발성 메모리 = Volatile Memory</li>
<li class="">정보가 저장된 위치는 주소로 구분</li>
</ul>
<table><thead><tr><th style=text-align:center>구분<th style=text-align:center>동적 램<th style=text-align:center>정적 램<tbody><tr><td style=text-align:center>구성<td style=text-align:center>콘덴서<td style=text-align:center>플리플롭<tr><td style=text-align:center>특징<td style=text-align:center>방전되므로주기적인 재충전<td style=text-align:center>전원 공급시에 계속 유지<tr><td style=text-align:center>소모전력<td style=text-align:center>적음<td style=text-align:center>많음<tr><td style=text-align:center>속도<td style=text-align:center>느림<td style=text-align:center>빠름<tr><td style=text-align:center>집적도<td style=text-align:center>높음<td style=text-align:center>낮음<tr><td style=text-align:center>가격<td style=text-align:center>저가<td style=text-align:center>고가<tr><td style=text-align:center>용도<td style=text-align:center>일반적<td style=text-align:center>캐시메모리</table>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=자기-코어>자기 코어<a href=#자기-코어 class=hash-link aria-label="자기 코어에 대한 직접 링크" title="자기 코어에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">전류 일치 기술에 의하여 기억장소를 선별</li>
<li class="">데이터를 읽으면 내용이 지워지는 <strong>파괴 메모리</strong></li>
<li class="">Dectructive Read Out Memory</li>
<li class="">내용을 읽은 후 지워진 내용을 기록하기 위한 재저장 시간 필요</li>
<li class="">현재 거의 사용되지 않음</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=구성-1>구성<a href=#구성-1 class=hash-link aria-label="구성에 대한 직접 링크" title="구성에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">구동선 : X,Y축 번지 선택선 2개</li>
<li class="">센스선 : 자기 코어의 상태를 검출하는 선 1개</li>
<li class="">금지선 : 불필요하게 자화되었을 때 금지 전류를 흘려 자화를 소진시키는 선 1개</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=반도체-기억소자-구성>반도체 기억소자 구성<a href=#반도체-기억소자-구성 class=hash-link aria-label="반도체 기억소자 구성에 대한 직접 링크" title="반도체 기억소자 구성에 대한 직접 링크" translate=no>​</a></h3>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=ram-1>RAM<a href=#ram-1 class=hash-link aria-label="RAM에 대한 직접 링크" title="RAM에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">CS1, CS2 : 칩 선택선</li>
<li class="">RD : 입력 신호선</li>
<li class="">WR : 출력 신호선</li>
<li class=""><strong>AD</strong> : 주소선<!-- -->
<ul>
<li class="">MAR과 PC의 수와 같음</li>
<li class="">주소선이 n개이면 2^n개의 워드 지정 가능</li>
</ul>
</li>
<li class="">Data Bus : 워드의 크기<!-- -->
<ul>
<li class="">MBR = IR = 단어의 크기</li>
<li class="">버스가 10Bit이면 워드의 크기가 10Bit</li>
</ul>
</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=rom-1>ROM<a href=#rom-1 class=hash-link aria-label="ROM에 대한 직접 링크" title="ROM에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">CS1, CS2 : 칩 선택선</li>
<li class=""><strong>AD</strong> : 주소선</li>
<li class="">Data Bus : 워드의 크기</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=보조기억장치>보조기억장치<a href=#보조기억장치 class=hash-link aria-label="보조기억장치에 대한 직접 링크" title="보조기억장치에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">주기억 장치의 단점 보완</li>
<li class="">속도는 느리지만 전원이 차단되도 내용 유지</li>
<li class="">저장용량이 큼</li>
<li class="">CPU와 직접 자료교환이 불가능</li>
<li class="">주기억장치에 데이터를 저장할 때 DMA를 사용</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=자기-테이프>자기 테이프<a href=#자기-테이프 class=hash-link aria-label="자기 테이프에 대한 직접 링크" title="자기 테이프에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">순차처리 = SASD</li>
<li class="">블록단위로 데이터를 전송</li>
<li class="">블록 사이에는 데이터를 기록할 수 없는 공간인 <strong>갭</strong>이 있다.</li>
<li class="">BOT : Beginning Of Tape</li>
<li class="">EOT : End Of Tape</li>
<li class="">BPI : Byte Per Inch, 1인치에 기억할 수 있는 바이트 수</li>
<li class="">IRG : Inter Record Gap, 레코드와 레코드 사이의 갭</li>
<li class="">IBG : Inter Block Gap, 블록과 블록 사이의 갭</li>
<li class="">Block : 한 개 이상의 논리 레코드의 집합 = 물리 레코드</li>
<li class="">블로킹 : 한 개 이상의 논리적 레코드를 묶어서 테이프에 기록하는 방식<!-- -->
<ul>
<li class="">IRG가 줄어든다.</li>
<li class="">기억공간 낭비 감소</li>
<li class="">Access Time 감소</li>
<li class="">입출력 횟수 감소</li>
</ul>
</li>
<li class="">Blocking Factor : 하나의 블록을 구성하는 논리 레코드의 갯수</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=자기-디스크>자기 디스크<a href=#자기-디스크 class=hash-link aria-label="자기 디스크에 대한 직접 링크" title="자기 디스크에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">DASD</li>
<li class="">회전축에 여러장의 디스크를 연결하고, 디스크 상하면마다 R/W Head를 액세스암에 연결하여 구성</li>
<li class="">가장 윗면과 가장 아랫면은 사용하지 않는다.</li>
<li class="">트랙 : 디스크 표면에서 회전푹을 중심으로 데이터가 기록되는 동심원</li>
<li class="">섹터 : 트랙들을 일정한 크기로 구분한 부분이며 정보 기록의 기본 단위</li>
<li class="">실린더 : 서로 다른 면들에 있는 동일 위치의 트랙들의 모임</li>
<li class="">Random Access와 Sequential Access 방식을 모두 사용</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=디스크의-3요소>디스크의 3요소<a href=#디스크의-3요소 class=hash-link aria-label="디스크의 3요소에 대한 직접 링크" title="디스크의 3요소에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">디스크</li>
<li class="">액세스암</li>
<li class="">헤드</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=access-time-1>Access Time<a href=#access-time-1 class=hash-link aria-label="Access Time에 대한 직접 링크" title="Access Time에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Access Time = Seek Time + Latency Time + Transmission Time</li>
<li class="">Seek Time : 탐색시간으로 R/W Head가 특정 트랙까지 이동하는데 걸리는 시간</li>
<li class="">Latency Time : R/W Head가 특정 트랙까지 이동한 후 디스크가 회전하여 트랙에 포함되어 있는 특정 섹터가 R/W Head까지 도달하는데 걸리는 시간<!-- -->
<ul>
<li class="">Search Time = Rotational Delay Time</li>
</ul>
</li>
<li class="">Transmission Time : 전송시간으로 R/W Head가 액세스한 섹터와 주기억장치 간의 자료전송에 걸리는 시간</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=자기-드럼>자기 드럼<a href=#자기-드럼 class=hash-link aria-label="자기 드럼에 대한 직접 링크" title="자기 드럼에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">각 트랙마다 고정된 R/W Head를 두고 있다.</li>
<li class="">DASD</li>
<li class="">Access Time = Latency Time + Transmission Time</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=연관기억장치>연관기억장치<a href=#연관기억장치 class=hash-link aria-label="연관기억장치에 대한 직접 링크" title="연관기억장치에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">기억장치에서 기억된 내용의 일부를 이용하여 액세스하는 자료를 찾는 기억장치</li>
<li class="">CAM = Content Addressable Memory = 연상기억장치</li>
<li class="">정보 검색 빠름</li>
<li class="">캐시 메모리나 가상 메모리 관리기법에서 사용하는 <strong>매핑 테이블에 사용</strong></li>
<li class="">외부 인자와 내용을 비교하기 위한 병렬 판독 논리회로를 가지고 있음</li>
<li class="">하드웨어 비용 증가</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=구조>구조<a href=#구조 class=hash-link aria-label="구조에 대한 직접 링크" title="구조에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">데이터 레지스터 : 인수 레지스터, 찾고자 하는 내용의 일부를 기억하는 레지스터</li>
<li class="">키 레지스터 : 마스크 레지스터, 검색에 사용할 비트를 결정하는 레지스터</li>
<li class="">매치 레지스터 : 일치 지시기, 데이터를 찾은 경우 찾았다고 표시하기 위해 사용</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=복수모듈기억장치>복수모듈기억장치<a href=#복수모듈기억장치 class=hash-link aria-label="복수모듈기억장치에 대한 직접 링크" title="복수모듈기억장치에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">독자적으로 데이터를 저장할 수 있는 기억장치 모듈을 여러 개 가진 기억장치</li>
<li class="">주기억장치와 CPU의 속도 차이 문제점을 개선</li>
<li class="">기억장치의 버스를 시분할하여 사용</li>
<li class="">각각의 기억장치는 자체 어드레스 레지스터와 버퍼 레지스터를 가지고 독자적으로 데이터를 저장</li>
<li class="">인터리빙 기법에 의해 기억장치를 구성하는 모듈 수만큼 단어(워드)들에 동시 접근 가능</li>
<li class="">버스가 많으면 모든 모듈 동시 병렬 접근 가능</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=메모리-인터리빙>메모리 인터리빙<a href=#메모리-인터리빙 class=hash-link aria-label="메모리 인터리빙에 대한 직접 링크" title="메모리 인터리빙에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">Memory Interleaving = 디스크 인터리빙</li>
<li class="">여러 개의 독립 모듈로 이루어진 복수 모듈 메모리와 CPU 간의 주소 버스가 한 개로만 구성되어 있으면 같은 시각에 CPU로부터 여러 모듈로 동시에 주소를 전달할 수 없다.</li>
<li class="">CPU가 각 모듈로 전송할 주소를 교대로 배치한 후 차례대로 전송하여 여러 모듈을 병행 접근하는 기법</li>
<li class="">중앙처리장치와 기억장치 사이의 실질적인 대역폭 효율을 높일 수 있다.</li>
<li class="">캐시 기억장치, 고속 DMA에서 사용</li>
<li class="">CPU 유휴시간 감소</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=캐시-메모리>캐시 메모리<a href=#캐시-메모리 class=hash-link aria-label="캐시 메모리에 대한 직접 링크" title="캐시 메모리에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">CPU와 주기억장치의 속도차를 줄이기 위해 사용</li>
<li class="">고속 Buffer Memory</li>
<li class="">자주 사용하는 프로그램과 데이터를 기억</li>
<li class="">메모리 계층에서 가장 빠른 소자</li>
<li class="">캐시 주소표는 검색 시간을 단축시키기 위해 연관기억장치(CAM)을 사용</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=설계-고려사항>설계 고려사항<a href=#설계-고려사항 class=hash-link aria-label="설계 고려사항에 대한 직접 링크" title="설계 고려사항에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">캐시 크기</li>
<li class="">전송 블록 크기</li>
<li class="">교체 알고리즘</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=매핑-프로세스>매핑 프로세스<a href=#매핑-프로세스 class=hash-link aria-label="매핑 프로세스에 대한 직접 링크" title="매핑 프로세스에 대한 직접 링크" translate=no>​</a></h3>
<p>주기억장치로부터 캐시 메모리로 데이터를 전송하는 방법</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=직접-매핑>직접 매핑<a href=#직접-매핑 class=hash-link aria-label="직접 매핑에 대한 직접 링크" title="직접 매핑에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Direct Mapping</li>
<li class="">주기억장치의 블록들이 지정된 한 개의 캐시 라인으로만 매핑되는 방법</li>
<li class="">간단하고 구현 비용이 적다</li>
<li class="">적중률이 낮다</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=어소시에이티브-매핑>어소시에이티브 매핑<a href=#어소시에이티브-매핑 class=hash-link aria-label="어소시에이티브 매핑에 대한 직접 링크" title="어소시에이티브 매핑에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Assciative Mapping = 연관 매핑</li>
<li class="">직접 매핑의 단점 보완</li>
<li class="">모든 태그를 병렬로 검사하기 때문에 복잡하고 비용이 높음</li>
<li class="">거의 사용안함</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=세트-어소시에이티브-매핑>세트-어소시에이티브 매핑<a href=#세트-어소시에이티브-매핑 class=hash-link aria-label="세트-어소시에이티브 매핑에 대한 직접 링크" title="세트-어소시에이티브 매핑에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">직접 매핑과 연관 매핑의 장점만 취함</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=쓰기-정책>쓰기 정책<a href=#쓰기-정책 class=hash-link aria-label="쓰기 정책에 대한 직접 링크" title="쓰기 정책에 대한 직접 링크" translate=no>​</a></h3>
<p>저장되어 있는 데이터 수정이 발생할 때 수정된 내용을 주기억장치에 갱신하기 위해 시기와 방법을 결정하는 것</p>
<ul>
<li class="">Wirte-Through : 캐시에 쓰기 동작이 이루어질 때마다 캐시 메모리와 주기억장치의 내용을 동시 갱신</li>
<li class="">Write-Back : 캐시에 쓰기 동작이 이루어지는 동안은 캐시의 내용만이 갱신, 캐시의 내용이 캐시로부터 제거될 때 주기억장치에 복사</li>
<li class="">Write-Once : 캐시에 쓰기 동작이 이루어질 때 한 번만 기록하고 이후의 기록은 모두 무시</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=적중률>적중률<a href=#적중률 class=hash-link aria-label="적중률에 대한 직접 링크" title="적중률에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">캐시메모리에 접근하는 경우 원하는 정보가 캐시 메모리에 기억되어 있을 때 적중되었다고 함</li>
<li class="">캐시 기억장치가 있는 컴퓨터의 성능을 나타네내는 척도</li>
<li class="">적중률 = 적중횟수 / 총 접근 횟수</li>
<li class="">미스율 = 1 - 적중률</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=가상기억장치>가상기억장치<a href=#가상기억장치 class=hash-link aria-label="가상기억장치에 대한 직접 링크" title="가상기억장치에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class=""><strong>기억 용량이 작은 주기억장치를 큰 용량을 가진 것</strong>처럼 사용할 수 있는 기법</li>
<li class="">보조기억장치를 이용한 주기억장치의 용량 확보</li>
<li class="">소프트웨어적 방법으로 구현</li>
<li class="">프로그램을 여러 블록으로 나눠서 보조기억장치에 보관하고 프로그램 실행시 필요 부분만 주기억장치에 적재</li>
<li class=""><strong>오버레이 문제가 자동적으로 해결</strong></li>
<li class="">보조기억장치 접근이 빈번하면 시스템 처리 효율이 저하</li>
<li class="">DASD에만 가능</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=주소>주소<a href=#주소 class=hash-link aria-label="주소에 대한 직접 링크" title="주소에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">가상주소 : 논리주소로 보조기억장치 상의 주소</li>
<li class="">실기억주소 : 물리적주소로 주기억장치 상의 주소</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=관리>관리<a href=#관리 class=hash-link aria-label="관리에 대한 직접 링크" title="관리에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">페이징 기법 : OS가 보조기억장치에 있는 프로그램을 동일한 크기의 블록으로 나눠서 관리</li>
<li class="">세그먼트 기법 : 사용자가 보조기억장치에 있는 프로그램을 가변적인 크기의 블록으로 나눠서 관리</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=관리전략>관리전략<a href=#관리전략 class=hash-link aria-label="관리전략에 대한 직접 링크" title="관리전략에 대한 직접 링크" translate=no>​</a></h3>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=반입-전략>반입 전략<a href=#반입-전략 class=hash-link aria-label="반입 전략에 대한 직접 링크" title="반입 전략에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Fetch</li>
<li class="">보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인가?</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=배치-전략>배치 전략<a href=#배치-전략 class=hash-link aria-label="배치 전략에 대한 직접 링크" title="배치 전략에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Placement</li>
<li class="">새로 반입되는 포르개림이나 데이터를 주기억장치 어디에 위치시킬 것인가를 결정</li>
<li class="">최초, 최적, 최악접합이 있음</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=교체-전략>교체 전략<a href=#교체-전략 class=hash-link aria-label="교체 전략에 대한 직접 링크" title="교체 전략에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Replacement</li>
<li class="">주기억장치의 영역이 이미 사용중인 상태에서 새로운 프로그램을 주기억장치에 배치할 때 어떤 방식을 사용할지 결정하는 전략</li>
<li class="">FIFO, OPT, LRU, NUR, LFU, MFU 등</li>
<li class="">Page Fault 발생시 교체할 페이지를 결정해서 보조기억장치의 이전 위치에 기억시키고 새 페이지를 교체한 페이지의 위치에 놓는 것을 스테이징이라 한다</li>
<li class="">스테이징 : 느린 장치에서 바른 장치로 옮겨가는 것</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=주소-매핑>주소 매핑<a href=#주소-매핑 class=hash-link aria-label="주소 매핑에 대한 직접 링크" title="주소 매핑에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">가상주소를 실 기억주소로 변환하는 작업</li>
<li class="">가상주소 형식 : 페이지 번호와 변위값</li>
<li class="">실기억주소 형식 : 페이지 프레임과 변위값</li>
<li class="">페이지 맵 테이블 : 디스크 페이지 번호와 페이지 프레임 번호, 상태 비트</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=변환-순서>변환 순서<a href=#변환-순서 class=hash-link aria-label="변환 순서에 대한 직접 링크" title="변환 순서에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">페이지 번호에 해당하는 페이지 프레임 번호와 가상주소의 변위 주소값을 이용해 실 기억주소를 만듦</li>
<li class="">실기억주소를 이용하여 주기억장치를 액세스</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=병렬-컴퓨터>병렬 컴퓨터<a href=#병렬-컴퓨터 class=hash-link aria-label="병렬 컴퓨터에 대한 직접 링크" title="병렬 컴퓨터에 대한 직접 링크" translate=no>​</a></h2>
<ul>
<li class="">I/O 채널 또는 프로세서와 같은 다수의 프로세서에서 동시에 여러 프로세스를 처리하는 것</li>
<li class="">일부 하드웨어 오류가 발생해도 전체 시스템은 동작</li>
<li class="">처리 속도가 빠름</li>
<li class="">프로그램 작성이 어려움</li>
<li class="">기억장치 공유</li>
<li class="">특수한 업무에 적용 : 예보, 인공지능, 역학계산, 모의실험, 유도탄 등</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=flynn의-분류>Flynn의 분류<a href=#flynn의-분류 class=hash-link aria-label="Flynn의 분류에 대한 직접 링크" title="Flynn의 분류에 대한 직접 링크" translate=no>​</a></h3>
<p>플린의 분류, 명령 흐름과 자료 흐름을 고려하여 분류</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=sisd>SISD<a href=#sisd class=hash-link aria-label="SISD에 대한 직접 링크" title="SISD에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Single Instruction stream Single Data stream</li>
<li class="">현재 보통 컴퓨터 구조</li>
<li class="">명령 하나가 자료 하나를 처리</li>
<li class="">파이프라인에 의한 시간적 병렬 처리 가능</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=simd>SIMD<a href=#simd class=hash-link aria-label="SIMD에 대한 직접 링크" title="SIMD에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Single Instruction stream Multi Data Stream</li>
<li class="">한 개의 명령으로 여러 데이터를 동시에 처리하는 구조</li>
<li class="">배열 처리기에 의한 동기적 병렬처리가 가능</li>
<li class="">다수의 처리기가 한 개의 제어장치에 의해 제어</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=misd>MISD<a href=#misd class=hash-link aria-label="MISD에 대한 직접 링크" title="MISD에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Multi Instruction stream Single Data stream</li>
<li class="">다수의 처리기에 의해 각각의 명령들이 하나의 데이터를 처리하는 구조</li>
<li class=""><strong>실제로 사용되지 않음</strong></li>
<li class="">파이프라인에 의한 비동기적 병렬처리 가능</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=mimd>MIMD<a href=#mimd class=hash-link aria-label="MIMD에 대한 직접 링크" title="MIMD에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Multi Instruction stream Multi Data stream</li>
<li class="">다수의 처리기가 각각 다른 명령 흐름과 자료 흐름을 가지고 여러 개의 자료를 처리하는 구조</li>
<li class="">각 처리기 사이에에서 상호작용(Interaction)이 일어남</li>
<li class="">멀티 프로세서에 의한 비동기적 병렬처리 가능</li>
<li class="">Tightly Coupled System = 다중 처리기</li>
<li class="">Loosely Coupled System = 분산 처리 시스템</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=feng의-분류>Feng의 분류<a href=#feng의-분류 class=hash-link aria-label="Feng의 분류에 대한 직접 링크" title="Feng의 분류에 대한 직접 링크" translate=no>​</a></h3>
<p>팽은 병렬 수행 정도에 따라 분류</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=wsbs>WSBS<a href=#wsbs class=hash-link aria-label="WSBS에 대한 직접 링크" title="WSBS에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Word-Serial, Bit-Serial</li>
<li class="">한 번에 한 비트씩 처리하는 방식 (초기 컴퓨터)</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=wpbs>WPBS<a href=#wpbs class=hash-link aria-label="WPBS에 대한 직접 링크" title="WPBS에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Word-Parallel, Bit-Serial</li>
<li class="">단어를 묶어서 그 중 한 개의 비트 슬라이스 단위를 순차적으로 처리</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=wsbp>WSBP<a href=#wsbp class=hash-link aria-label="WSBP에 대한 직접 링크" title="WSBP에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Word-Sreial, Bit-Parallel</li>
<li class="">한 번에 한 단어씩 병렬로 처리</li>
<li class="">현재의 컴퓨터</li>
</ul>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=wpbp>WPBP<a href=#wpbp class=hash-link aria-label="WPBP에 대한 직접 링크" title="WPBP에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">Word-Parallel, Bit-Parellel</li>
<li class="">단어별 병렬, 비트별 병렬 처리</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id=병렬-처리-기법>병렬 처리 기법<a href=#병렬-처리-기법 class=hash-link aria-label="병렬 처리 기법에 대한 직접 링크" title="병렬 처리 기법에 대한 직접 링크" translate=no>​</a></h2>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=파이프라인-프로세서>파이프라인 프로세서<a href=#파이프라인-프로세서 class=hash-link aria-label="파이프라인 프로세서에 대한 직접 링크" title="파이프라인 프로세서에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">CPU 처리속도를 높이기 위해 여러개의 인스트럭션을 동시에 병렬처리하는 장치</li>
<li class="">시간적 병렬처리</li>
<li class="">명령인출 => 명령 해독 => 오퍼랜드 인출 => 명령 실행</li>
<li class="">스칼라 프로세서를 이용하는 기법</li>
<li class="">파이프라인이 차고 나면 연산속도가 빠르다.</li>
<li class="">같은 연산이 반복되면 효율적이지만 아니면 구조가 복잡하고 시간이 오래 걸린다.</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=벡터-프로세서>벡터 프로세서<a href=#벡터-프로세서 class=hash-link aria-label="벡터 프로세서에 대한 직접 링크" title="벡터 프로세서에 대한 직접 링크" translate=no>​</a></h3>
<p>산술 및 논리연산, 비교, 내적연산, 최대, 최소값 구하기 등 벡터 연산 명령을 효율적으로 수행하도록 구성된 처리기</p>
<h4 class="anchor anchorTargetStickyNavbar_Vzrq" id=시스톨릭-프로세서>시스톨릭 프로세서<a href=#시스톨릭-프로세서 class=hash-link aria-label="시스톨릭 프로세서에 대한 직접 링크" title="시스톨릭 프로세서에 대한 직접 링크" translate=no>​</a></h4>
<ul>
<li class="">데이터 흐름과 제어 흐름이 규칙적인 특징을 갖는 시스톨릭 알고리즘을 이용하여 수행하는 처리기</li>
<li class="">파이프라인화 된 벡터 프로세서와 배열 프로세서의 특징을 결합한 것</li>
<li class="">초고밀도 직접회로(VLSI) 기법을 이용하여 구현</li>
<li class="">응용의 한계성과 프로그래밍의 어려움이 있음</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=배열-프로세서>배열 프로세서<a href=#배열-프로세서 class=hash-link aria-label="배열 프로세서에 대한 직접 링크" title="배열 프로세서에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">배열처리기는 PE(Processing Element)라 불리는 다수의 연산기를 갖는 <strong>동기적 병렬 처리기</strong></li>
<li class="">명령 해독 및 제어는 제어장치가 하고, PE들는 명령 해독 능력이 결여된 수동적 장치로 명령처리만 한다.</li>
<li class="">PE를 중복 이용해서 공간적 병렬성을 얻는다.</li>
<li class="">벡터 계산이나 행렬 계산에 적합</li>
</ul>
<h3 class="anchor anchorTargetStickyNavbar_Vzrq" id=데이터-플로우-컴퓨터>데이터 플로우 컴퓨터<a href=#데이터-플로우-컴퓨터 class=hash-link aria-label="데이터 플로우 컴퓨터에 대한 직접 링크" title="데이터 플로우 컴퓨터에 대한 직접 링크" translate=no>​</a></h3>
<ul>
<li class="">데이터 흐름 컴퓨터는 PC(Program Counter)가 필요 없다.</li>
<li class="">제어 흐름 컴퓨터와는 반대되는 개념</li>
<li class="">인스트럭션의 필요한 피연산자가 모두 준비되었을 때 인스트럭션을 수행하고 결과를 필요로하는 인스트럭션에 보내주는 방식</li>
</ul></div><footer class=docusaurus-mt-lg><div class="row margin-top--sm theme-blog-footer-edit-meta-row"><div class=col><b>태그:</b><ul class="tags_jXut padding--none margin-left--sm"><li class=tag_QGVx><a rel=tag title="Engineer Information Processing" class="tag_zVej tagRegular_sFm0" href=/tags/정보처리/>정보처리</a></ul></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href=/2017/02/01/Nginx-for-Windows/><div class=pagination-nav__sublabel>이전 게시물</div><div class=pagination-nav__label>Nginx for Windows - 1. Setup</div></a><a class="pagination-nav__link pagination-nav__link--next" href=/2017/01/23/database-정리/><div class=pagination-nav__sublabel>다음 게시물</div><div class=pagination-nav__label>Database 정리</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#불-대수 class="table-of-contents__link toc-highlight">불 대수</a><ul><li><a href=#기본-공식 class="table-of-contents__link toc-highlight">기본 공식</a><li><a href=#카르노-맵 class="table-of-contents__link toc-highlight">카르노 맵</a></ul><li><a href=#논리-게이트 class="table-of-contents__link toc-highlight">논리 게이트</a><li><a href=#조합논리회로 class="table-of-contents__link toc-highlight">조합논리회로</a><ul><li><a href=#반가산기 class="table-of-contents__link toc-highlight">반가산기</a><li><a href=#전가산기 class="table-of-contents__link toc-highlight">전가산기</a><li><a href=#병렬가산기 class="table-of-contents__link toc-highlight">병렬가산기</a><li><a href=#반감산기 class="table-of-contents__link toc-highlight">반감산기</a><li><a href=#디코더 class="table-of-contents__link toc-highlight">디코더</a><li><a href=#인코더 class="table-of-contents__link toc-highlight">인코더</a><li><a href=#멀티플렉서 class="table-of-contents__link toc-highlight">멀티플렉서</a><li><a href=#디멀티플렉서 class="table-of-contents__link toc-highlight">디멀티플렉서</a></ul><li><a href=#순서논리회로 class="table-of-contents__link toc-highlight">순서논리회로</a><ul><li><a href=#플리플롭 class="table-of-contents__link toc-highlight">플리플롭</a></ul><li><a href=#자료-구성-단위 class="table-of-contents__link toc-highlight">자료 구성 단위</a><ul><li><a href=#비트 class="table-of-contents__link toc-highlight">비트</a><li><a href=#니블 class="table-of-contents__link toc-highlight">니블</a><li><a href=#바이트 class="table-of-contents__link toc-highlight">바이트</a><li><a href=#워드 class="table-of-contents__link toc-highlight">워드</a><li><a href=#필드 class="table-of-contents__link toc-highlight">필드</a><li><a href=#레코드 class="table-of-contents__link toc-highlight">레코드</a><li><a href=#블록 class="table-of-contents__link toc-highlight">블록</a><li><a href=#파일 class="table-of-contents__link toc-highlight">파일</a><li><a href=#데이터베이스 class="table-of-contents__link toc-highlight">데이터베이스</a></ul><li><a href=#진법 class="table-of-contents__link toc-highlight">진법</a><ul><li><a href=#2진수 class="table-of-contents__link toc-highlight">2진수</a><li><a href=#8진수 class="table-of-contents__link toc-highlight">8진수</a><li><a href=#16진수 class="table-of-contents__link toc-highlight">16진수</a></ul><li><a href=#보수 class="table-of-contents__link toc-highlight">보수</a><ul><li><a href=#뺄셈 class="table-of-contents__link toc-highlight">뺄셈</a></ul><li><a href=#고정-소수점 class="table-of-contents__link toc-highlight">고정 소수점</a><ul><li><a href=#2진연산 class="table-of-contents__link toc-highlight">2진연산</a><li><a href=#10진연산 class="table-of-contents__link toc-highlight">10진연산</a></ul><li><a href=#부동소수점 class="table-of-contents__link toc-highlight">부동소수점</a><ul><li><a href=#ieee-표준 class="table-of-contents__link toc-highlight">IEEE 표준</a><li><a href=#연산 class="table-of-contents__link toc-highlight">연산</a></ul><li><a href=#자료-표현 class="table-of-contents__link toc-highlight">자료 표현</a><ul><li><a href=#bcd class="table-of-contents__link toc-highlight">BCD</a><li><a href=#ascii class="table-of-contents__link toc-highlight">ASCII</a><li><a href=#ebcdic class="table-of-contents__link toc-highlight">EBCDIC</a><li><a href=#bcd-코드 class="table-of-contents__link toc-highlight">BCD 코드</a><li><a href=#excess3-코드 class="table-of-contents__link toc-highlight">Excess3 코드</a><li><a href=#gray-코드 class="table-of-contents__link toc-highlight">Gray 코드</a><li><a href=#패리티-코드 class="table-of-contents__link toc-highlight">패리티 코드</a><li><a href=#해밍-코드 class="table-of-contents__link toc-highlight">해밍 코드</a><li><a href=#코드-분류 class="table-of-contents__link toc-highlight">코드 분류</a></ul><li><a href=#중앙처리장치 class="table-of-contents__link toc-highlight">중앙처리장치</a><ul><li><a href=#제어장치 class="table-of-contents__link toc-highlight">제어장치</a><li><a href=#연산장치 class="table-of-contents__link toc-highlight">연산장치</a><li><a href=#레지스터 class="table-of-contents__link toc-highlight">레지스터</a><li><a href=#버스 class="table-of-contents__link toc-highlight">버스</a></ul><li><a href=#명령어 class="table-of-contents__link toc-highlight">명령어</a><ul><li><a href=#연산자부 class="table-of-contents__link toc-highlight">연산자부</a><li><a href=#모드부 class="table-of-contents__link toc-highlight">모드부</a><li><a href=#자료부 class="table-of-contents__link toc-highlight">자료부</a><li><a href=#설계시-고려사항 class="table-of-contents__link toc-highlight">설계시 고려사항</a><li><a href=#기능 class="table-of-contents__link toc-highlight">기능</a></ul><li><a href=#연산-1 class="table-of-contents__link toc-highlight">연산</a><ul><li><a href=#and class="table-of-contents__link toc-highlight">AND</a><li><a href=#or class="table-of-contents__link toc-highlight">OR</a><li><a href=#xor class="table-of-contents__link toc-highlight">XOR</a><li><a href=#not class="table-of-contents__link toc-highlight">NOT</a><li><a href=#논리-shift class="table-of-contents__link toc-highlight">논리 Shift</a><li><a href=#rotate class="table-of-contents__link toc-highlight">Rotate</a><li><a href=#산술-shift class="table-of-contents__link toc-highlight">산술 Shift</a></ul><li><a href=#명령어-형식 class="table-of-contents__link toc-highlight">명령어 형식</a><ul><li><a href=#3주소-명령어 class="table-of-contents__link toc-highlight">3주소 명령어</a><li><a href=#2주소-명령어 class="table-of-contents__link toc-highlight">2주소 명령어</a><li><a href=#1주소-명령어 class="table-of-contents__link toc-highlight">1주소 명령어</a><li><a href=#0주소-명령어 class="table-of-contents__link toc-highlight">0주소 명령어</a></ul><li><a href=#주소지정방식 class="table-of-contents__link toc-highlight">주소지정방식</a><ul><li><a href=#고려사항 class="table-of-contents__link toc-highlight">고려사항</a><li><a href=#암시적-주소지정방식 class="table-of-contents__link toc-highlight">암시적 주소지정방식</a><li><a href=#즉시적-주소지정방식 class="table-of-contents__link toc-highlight">즉시적 주소지정방식</a><li><a href=#직접-주소지정방식 class="table-of-contents__link toc-highlight">직접 주소지정방식</a><li><a href=#간접-주소지정방식 class="table-of-contents__link toc-highlight">간접 주소지정방식</a><li><a href=#계산에-의한-주소지정방식 class="table-of-contents__link toc-highlight">계산에 의한 주소지정방식</a></ul><li><a href=#마이크로-오퍼레이션 class="table-of-contents__link toc-highlight">마이크로 오퍼레이션</a><ul><li><a href=#마이크로-사이클-타임 class="table-of-contents__link toc-highlight">마이크로 사이클 타임</a></ul><li><a href=#메이저-스테이트 class="table-of-contents__link toc-highlight">메이저 스테이트</a><ul><li><a href=#fetch-cycle class="table-of-contents__link toc-highlight">Fetch Cycle</a><li><a href=#indirect-cycle class="table-of-contents__link toc-highlight">Indirect Cycle</a><li><a href=#execute-cycle class="table-of-contents__link toc-highlight">Execute Cycle</a><li><a href=#interrupt-cycle class="table-of-contents__link toc-highlight">Interrupt Cycle</a></ul><li><a href=#주요-마이크로-오퍼레이션 class="table-of-contents__link toc-highlight">주요 마이크로 오퍼레이션</a><ul><li><a href=#and-1 class="table-of-contents__link toc-highlight">AND</a><li><a href=#add class="table-of-contents__link toc-highlight">ADD</a><li><a href=#lda class="table-of-contents__link toc-highlight">LDA</a><li><a href=#sta class="table-of-contents__link toc-highlight">STA</a><li><a href=#bun class="table-of-contents__link toc-highlight">BUN</a><li><a href=#bsa class="table-of-contents__link toc-highlight">BSA</a><li><a href=#isz class="table-of-contents__link toc-highlight">ISZ</a></ul><li><a href=#제어기 class="table-of-contents__link toc-highlight">제어기</a><ul><li><a href=#제어데이터 class="table-of-contents__link toc-highlight">제어데이터</a><li><a href=#구현 class="table-of-contents__link toc-highlight">구현</a><li><a href=#제어-메모리-번지-결정 class="table-of-contents__link toc-highlight">제어 메모리 번지 결정</a><li><a href=#형식 class="table-of-contents__link toc-highlight">형식</a><li><a href=#제어장치-구현방식 class="table-of-contents__link toc-highlight">제어장치 구현방식</a></ul><li><a href=#입출력장치 class="table-of-contents__link toc-highlight">입출력장치</a><ul><li><a href=#입출력-제어장치 class="table-of-contents__link toc-highlight">입출력 제어장치</a><li><a href=#입출력-인터페이스 class="table-of-contents__link toc-highlight">입출력 인터페이스</a><li><a href=#입출력-버스 class="table-of-contents__link toc-highlight">입출력 버스</a><li><a href=#기억장치와-입출력장치의-차이 class="table-of-contents__link toc-highlight">기억장치와 입출력장치의 차이</a><li><a href=#비동기-데이터-전송 class="table-of-contents__link toc-highlight">비동기 데이터 전송</a><li><a href=#스풀링 class="table-of-contents__link toc-highlight">스풀링</a><li><a href=#버퍼링 class="table-of-contents__link toc-highlight">버퍼링</a></ul><li><a href=#입출력-제어방식 class="table-of-contents__link toc-highlight">입출력 제어방식</a><ul><li><a href=#programmed-io class="table-of-contents__link toc-highlight">Programmed I/O</a><li><a href=#interrupt-io class="table-of-contents__link toc-highlight">Interrupt I/O</a><li><a href=#dma-io class="table-of-contents__link toc-highlight">DMA I/O</a><li><a href=#channel-io class="table-of-contents__link toc-highlight">Channel I/O</a></ul><li><a href=#인터럽트 class="table-of-contents__link toc-highlight">인터럽트</a><ul><li><a href=#외부-인터럽트 class="table-of-contents__link toc-highlight">외부 인터럽트</a><li><a href=#내부-인터럽트 class="table-of-contents__link toc-highlight">내부 인터럽트</a><li><a href=#소프트웨어-인터럽트 class="table-of-contents__link toc-highlight">소프트웨어 인터럽트</a><li><a href=#인터럽트시-cpu확인-요소 class="table-of-contents__link toc-highlight">인터럽트시 CPU확인 요소</a><li><a href=#동작-원리 class="table-of-contents__link toc-highlight">동작 원리</a></ul><li><a href=#인터럽트-우선순위 class="table-of-contents__link toc-highlight">인터럽트 우선순위</a><ul><li><a href=#폴링 class="table-of-contents__link toc-highlight">폴링</a><li><a href=#벡터-인터럽트 class="table-of-contents__link toc-highlight">벡터 인터럽트</a></ul><li><a href=#기억장치 class="table-of-contents__link toc-highlight">기억장치</a><ul><li><a href=#계층구조 class="table-of-contents__link toc-highlight">계층구조</a><li><a href=#특성-결정-요소 class="table-of-contents__link toc-highlight">특성 결정 요소</a><li><a href=#구분 class="table-of-contents__link toc-highlight">구분</a></ul><li><a href=#주기억장치 class="table-of-contents__link toc-highlight">주기억장치</a><ul><li><a href=#rom class="table-of-contents__link toc-highlight">ROM</a><li><a href=#ram class="table-of-contents__link toc-highlight">RAM</a><li><a href=#자기-코어 class="table-of-contents__link toc-highlight">자기 코어</a><li><a href=#반도체-기억소자-구성 class="table-of-contents__link toc-highlight">반도체 기억소자 구성</a></ul><li><a href=#보조기억장치 class="table-of-contents__link toc-highlight">보조기억장치</a><ul><li><a href=#자기-테이프 class="table-of-contents__link toc-highlight">자기 테이프</a><li><a href=#자기-디스크 class="table-of-contents__link toc-highlight">자기 디스크</a><li><a href=#자기-드럼 class="table-of-contents__link toc-highlight">자기 드럼</a></ul><li><a href=#연관기억장치 class="table-of-contents__link toc-highlight">연관기억장치</a><ul><li><a href=#구조 class="table-of-contents__link toc-highlight">구조</a></ul><li><a href=#복수모듈기억장치 class="table-of-contents__link toc-highlight">복수모듈기억장치</a><ul><li><a href=#메모리-인터리빙 class="table-of-contents__link toc-highlight">메모리 인터리빙</a></ul><li><a href=#캐시-메모리 class="table-of-contents__link toc-highlight">캐시 메모리</a><ul><li><a href=#설계-고려사항 class="table-of-contents__link toc-highlight">설계 고려사항</a><li><a href=#매핑-프로세스 class="table-of-contents__link toc-highlight">매핑 프로세스</a><li><a href=#쓰기-정책 class="table-of-contents__link toc-highlight">쓰기 정책</a><li><a href=#적중률 class="table-of-contents__link toc-highlight">적중률</a></ul><li><a href=#가상기억장치 class="table-of-contents__link toc-highlight">가상기억장치</a><ul><li><a href=#주소 class="table-of-contents__link toc-highlight">주소</a><li><a href=#관리 class="table-of-contents__link toc-highlight">관리</a><li><a href=#관리전략 class="table-of-contents__link toc-highlight">관리전략</a><li><a href=#주소-매핑 class="table-of-contents__link toc-highlight">주소 매핑</a></ul><li><a href=#병렬-컴퓨터 class="table-of-contents__link toc-highlight">병렬 컴퓨터</a><ul><li><a href=#flynn의-분류 class="table-of-contents__link toc-highlight">Flynn의 분류</a><li><a href=#feng의-분류 class="table-of-contents__link toc-highlight">Feng의 분류</a></ul><li><a href=#병렬-처리-기법 class="table-of-contents__link toc-highlight">병렬 처리 기법</a><ul><li><a href=#파이프라인-프로세서 class="table-of-contents__link toc-highlight">파이프라인 프로세서</a><li><a href=#벡터-프로세서 class="table-of-contents__link toc-highlight">벡터 프로세서</a><li><a href=#배열-프로세서 class="table-of-contents__link toc-highlight">배열 프로세서</a><li><a href=#데이터-플로우-컴퓨터 class="table-of-contents__link toc-highlight">데이터 플로우 컴퓨터</a></ul></ul></div></div></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class=footer__title>Support Me</div><ul class="footer__items clean-list"><li class=footer__item><a href=https://www.buymeacoffee.com/LOUB2kN target=_blank rel="noopener noreferrer" style="cursor: pointer;">
                <img src=https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png style="height: auto !important;width: auto !important;">
              </a></ul></div><div class="theme-layout-footer-column col footer__col"><div class=footer__title>Feeds</div><ul class="footer__items clean-list"><li class=footer__item><a href=https://gracefullight.dev/rss.xml target=_blank rel="noopener noreferrer" class=footer__link-item>RSS<svg width=13.5 height=13.5 aria-label="(opens in new tab)" class=iconExternalLink_nPIU><use href=#theme-svg-external-link /></svg></a><li class=footer__item><a href=https://gracefullight.dev/atom.xml target=_blank rel="noopener noreferrer" class=footer__link-item>Atom<svg width=13.5 height=13.5 aria-label="(opens in new tab)" class=iconExternalLink_nPIU><use href=#theme-svg-external-link /></svg></a></ul></div></div><div class="footer__bottom text--center"><div class=footer__copyright>Copyright © 2016-2026 Eunkwang Shin.</div></div></div></footer></div></body>