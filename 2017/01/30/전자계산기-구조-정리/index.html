<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.0">
<title data-rh="true">전자계산기 구조 정리 | gracefullight.dev</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://gracefullight.dev/2017/01/30/전자계산기-구조-정리/"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" name="google-site-verification" content="gcY9SiftHgQoJjBZ7IgwNNN5_atLPAX6kWb1nFVfa6E"><meta data-rh="true" name="msvalidate.01" content="65AD1E28C0D057CEB3C68FBC0293E55B"><meta data-rh="true" name="naver-site-verification" content="d024c2837887f72dc7b3792b958be74d69ba9593"><meta data-rh="true" name="yandex-verification" content="6672f93d837354fb"><meta data-rh="true" name="baidu-site-verification" content="yZEdU1ABcR"><meta data-rh="true" name="facebook-domain-verification" content="uelupjqqsm5egzlhy1aev2rfxow5yt"><meta data-rh="true" property="og:title" content="전자계산기 구조 정리 | gracefullight.dev"><meta data-rh="true" name="description" content="- 영국 수학자 불에 의해 개발"><meta data-rh="true" property="og:description" content="- 영국 수학자 불에 의해 개발"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2017-01-30T00:35:16.000Z"><meta data-rh="true" property="article:author" content="https://github.com/gracefullight"><meta data-rh="true" property="article:tag" content="정보처리"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://gracefullight.dev/2017/01/30/전자계산기-구조-정리/"><link data-rh="true" rel="alternate" href="https://gracefullight.dev/2017/01/30/전자계산기-구조-정리/" hreflang="ko"><link data-rh="true" rel="alternate" href="https://gracefullight.dev/en/2017/01/30/전자계산기-구조-정리/" hreflang="en"><link data-rh="true" rel="alternate" href="https://gracefullight.dev/2017/01/30/전자계산기-구조-정리/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://RFS69RSYOJ-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/rss.xml" title="gracefullight.dev RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="gracefullight.dev Atom Feed">
<link rel="alternate" type="application/json" href="/feed.json" title="gracefullight.dev JSON Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E99DNE7S05"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-E99DNE7S05",{})</script>


<link rel="search" type="application/opensearchdescription+xml" title="gracefullight.dev" href="/opensearch.xml">
<link rel="icon" href="/img/favicon-32x32.png">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#f28913">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f28913">
<link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
<link rel="preconnect" href="https://pagead2.googlesyndication.com">
<script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3004788392777865" async crossorigin="anonymous"></script>
<link rel="preconnect" href="https://www.clarity.ms">
<script>!function(t,e,n,a,c,i,r){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(i=e.createElement(a)).async=1,i.src="https://www.clarity.ms/tag/aongv9xgi6",(r=e.getElementsByTagName(a)[0]).parentNode.insertBefore(i,r)}(window,document,"clarity","script")</script>
<link rel="preconnect" href="https://wcs.naver.net">
<script src="https://wcs.naver.net/wcslog.js" async></script>
<script>if(!wcs_add)var wcs_add={};wcs_add.wa="156bc73a81e3bd0",window.wcs&&wcs_do()</script>
<link rel="preconnect" href="https://cdn.channel.io">
<script>!function(){var n=window;if(n.ChannelIO)return(window.console.error||window.console.log||function(){})("ChannelIO script included twice.");var e=function(){e.c(arguments)};function t(){if(!n.ChannelIOInitialized){n.ChannelIOInitialized=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://cdn.channel.io/plugin/ch-plugin-web.js",e.charset="UTF-8";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}}e.q=[],e.c=function(n){e.q.push(n)},n.ChannelIO=e,"complete"===document.readyState?t():window.attachEvent?window.attachEvent("onload",t):(window.addEventListener("DOMContentLoaded",t,!1),window.addEventListener("load",t,!1))}(),ChannelIO("boot",{pluginKey:"0fd130ba-a1a6-4b7e-802a-e82a885a7fd8"})</script>
<link rel="preconnect" href="https://static.cloudflareinsights.com">
<script src="https://static.cloudflareinsights.com/beacon.min.js" defer="defer" data-cf-beacon="{&quot;token&quot;:&quot;c0899829e72b45e98dff77241127252c&quot;}"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.72124e84.css">
<script src="/assets/js/runtime~main.11c5daf6.js" defer="defer"></script>
<script src="/assets/js/main.7213c416.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"dark")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_yvB4" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon-32x32.png" alt="gracefullight.dev blog logo" class="themedComponent_r477 themedComponent--light_iiro"><img src="/img/favicon-32x32.png" alt="gracefullight.dev blog logo" class="themedComponent_r477 themedComponent--dark_K95Z"></div><b class="navbar__title text--truncate">gracefullight.dev</b></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_cg1t"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>한국어</a><ul class="dropdown__menu"><li><a href="/2017/01/30/전자계산기-구조-정리/" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="ko">한국어</a></li><li><a href="/en/2017/01/30/전자계산기-구조-정리/" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li></ul></div><a class="navbar__item navbar__link" href="/archive/">Archives</a><a class="navbar__item navbar__link" href="/tags/">Tags</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/gracefullight" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lTcV"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a href="https://www.linkedin.com/in/gracefullight" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lTcV"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbarSearchContainer_OLl6"><button type="button" class="DocSearch DocSearch-Button" aria-label="검색"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">검색</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_UwkV"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_RLT_ thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_iuYP margin-bottom--md">최근 포스트</div><ul class="sidebarItemList_CfIz clean-list"><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/11/16/ielts-speaking-tests/">IELTS Speacking 기출</a></li><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/11/11/professional-engineer-database/">기술사 - 데이터베이스</a></li><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/11/11/professional-engineer-information-security/">기술사 - 정보보안</a></li><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/10/28/professional-engineer-sw-engineering/">기술사 - 소프트웨어 공학</a></li><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/10/22/professional-engineer-project-management/">기술사 - 프로젝트관리</a></li><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/10/18/ielts-listening/">IELTS Listening</a></li><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/10/14/professional-engineer-it-conversence/">기술사 - 융합 IT</a></li><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/10/09/ielts-speaking/">IELTS Speaking</a></li><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/10/09/ielts-writing/">IELTS Writing</a></li><li class="sidebarItem_RkFl"><a class="sidebarItemLink_eUsF" href="/2023/10/07/professional-engineer-it-governance/">기술사 - IT경영</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="https://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="https://schema.org/BlogPosting"><meta itemprop="description" content="- 영국 수학자 불에 의해 개발"><header><h1 class="title_EZbs" itemprop="headline">전자계산기 구조 정리</h1><div class="container_bfCu margin-vert--md"><time datetime="2017-01-30T00:35:16.000Z" itemprop="datePublished">2017년 1월 30일</time> · <!-- -->약 91분</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_y8eo"><div class="avatar margin-bottom--sm"><a href="https://github.com/gracefullight" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/11773683?v=4" alt="Eunkwang Shin" itemprop="image"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/gracefullight" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Eunkwang Shin</span></a></div><small class="avatar__subtitle" itemprop="description">Owner</small></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><ul>
<li>영국 수학자 불에 의해 개발</li>
<li>AND : 입력 값이 모두 1일 때 1 출력</li>
<li>OR : 입력 값이 하나라도 1일 때 1 출력</li>
<li>NOT : 부정</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="기본-공식">기본 공식<a href="#기본-공식" class="hash-link" aria-label="기본 공식에 대한 직접 링크" title="기본 공식에 대한 직접 링크">​</a></h2>
<ul>
<li><strong>합의 곱을 곱의 합으로 변환</strong></li>
<li>분배법칙 예외 : A ＋(B×C) = (A ＋ B)(B ＋ C)</li>
<li>드모르강<!-- -->
<ul>
<li>(A ＋ B)` = A`×B`</li>
<li>(A×B)` = A`＋ B`</li>
</ul>
</li>
<li>멱등<!-- -->
<ul>
<li>A ＋ A = A</li>
<li>A×A = A</li>
</ul>
</li>
<li>보수<!-- -->
<ul>
<li>A ＋ A` = 1</li>
<li>A×A` = 0</li>
</ul>
</li>
<li>항등<!-- -->
<ul>
<li>A ＋ 0 = A</li>
<li>A ＋ 1 = 1</li>
<li>A×0 = 0</li>
<li>A×1 = A</li>
</ul>
</li>
<li>콘센서스<!-- -->
<ul>
<li>AB ＋ BC ＋ CA` = AB ＋ CA`</li>
<li>(A ＋ B)(B ＋ C)(C ＋ A`) = (A ＋ B)(C ＋ A`)</li>
</ul>
</li>
<li>복원 : A`` = A</li>
<li>기타<!-- -->
<ul>
<li>A ＋ A`B = A ＋ B</li>
<li>A ＋ AB = A</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="카르노-맵">카르노 맵<a href="#카르노-맵" class="hash-link" aria-label="카르노 맵에 대한 직접 링크" title="카르노 맵에 대한 직접 링크">​</a></h2>
<ul>
<li>설계된 논리식을 도표로 표현하여 최소화 하는 방법</li>
<li>Karnaugh map = K-map = 카노맵</li>
</ul>
<p><img loading="lazy" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg/275px-K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg.png" alt="카르노 맵" class="img_lJOJ">
AB와 CD의 위치를 바꾸어 계산하는게 쉽다.</p>
<table><thead><tr><th></th><th><strong>00</strong></th><th><strong>01</strong></th><th><strong>11</strong></th><th><strong>10</strong></th></tr></thead><tbody><tr><td><strong>00</strong></td><td>0</td><td>1</td><td>3</td><td>2</td></tr><tr><td><strong>01</strong></td><td>4</td><td>5</td><td>7</td><td>6</td></tr><tr><td><strong>11</strong></td><td>12</td><td>13</td><td>15</td><td>14</td></tr><tr><td><strong>10</strong></td><td>8</td><td>9</td><td>11</td><td>10</td></tr></tbody></table>
<h1>논리 게이트</h1>
<ul>
<li>BUFFER : 입력된 정보를 그대로 출력</li>
<li>NAND : NOT + AND</li>
<li>NOR : NOT + OR</li>
<li>XOR : 입력이 같으면 0, 다르면 1<!-- -->
<ul>
<li>X = A⊕B</li>
<li>X = A`B + AB`</li>
<li>X = (A + B)(A` + B`)</li>
</ul>
</li>
<li>XNOR : NOT + XOR<!-- -->
<ul>
<li>X = A⊙B</li>
<li>X = (A⊕B)`</li>
<li>X = AB + A`B`</li>
</ul>
</li>
</ul>
<h1>조합논리회로</h1>
<p>반가산기, 전가산기, 병렬가산기, 반감산기, 전감산기, 디코더, 인코더, 멀티플렉서, 디멀티플렉서, 다수결회로, 비교기 등</p>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="반가산기">반가산기<a href="#반가산기" class="hash-link" aria-label="반가산기에 대한 직접 링크" title="반가산기에 대한 직접 링크">​</a></h2>
<p>2진수 두 개를 더한 합과 자리올림수를 구하는 조합논리회로</p>
<ul>
<li>합은 S, 자리올림(캐리)는 C</li>
<li>C = AB</li>
<li>S = A`B + AB` = A⊕B</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="전가산기">전가산기<a href="#전가산기" class="hash-link" aria-label="전가산  기에 대한 직접 링크" title="전가산기에 대한 직접 링크">​</a></h2>
<p>1bit 2진수 3자리를 더하여 합과 자리올림수를 구하는 조합논리회로</p>
<ul>
<li>두 개의 반가산기와 한 개의 OR GATE로 구성</li>
<li>합은 S, 자리올림(캐리)는 C</li>
<li>C = (A⊕B)C + AB</li>
<li>S = (A⊕B)⊕C</li>
<li>3 × 8 디코더 1개 + 4 입력 OR 게이트 2개로 구성가능</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="병렬가산기">병렬가산기<a href="#병렬가산기" class="hash-link" aria-label="병렬가산기에 대한 직접 링크" title="병렬가산기에 대한 직접 링크">​</a></h2>
<p>n bit로 된 2진수 A, B에 대한 덧셈을 n개의 전가산기를 이용하여 구현한 실질적인 가산기</p>
<ul>
<li>전파지연을 줄이기 위해 Carry Look Ahead 사용</li>
<li>전파지연 : ALU Path에서 가장 긴 Delay</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="반감산기">반감산기<a href="#반감산기" class="hash-link" aria-label="반감산기에 대한 직접 링크" title="반감산기에 대한 직접 링크">​</a></h2>
<p>1bit 2진수 2자리에 대한 감산을 하는 조합논리회로</p>
<ul>
<li>차는 D, 빌려온 수는 B</li>
<li>B = A`B</li>
<li>D = A`B + A`B = A⊕B</li>
<li>2 × 4 디코더 1개 + 3 입력 OR 게이트 1개로 구성가능</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="디코더">디코더<a href="#디코더" class="hash-link" aria-label="디코더에 대한 직접 링크" title="디코더에 대한 직접 링크">​</a></h2>
<p>n bit의 코드화된 정보를 그 코드의 각 bit 조합에 따라 2^n개의 출력으로 번역하는 조합논리회로</p>
<ul>
<li><strong>n개의 입력을 2^n개의 출력으로</strong></li>
<li>명령어의 명령부나 번지를 해독할 때 사용</li>
<li>주로 AND 게이트로 구성</li>
<li>부호화된 데이터에서 정보를 찾아냄</li>
<li>n × 2^n 디코더의 AND 게이트 수 : 2^n 개<!-- -->
<ul>
<li>5 × 8 디코더 : 8개</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="인코더">인코더<a href="#인코더" class="hash-link" aria-label="인코더에 대한 직접 링크" title="인코더에 대한 직접 링크">​</a></h2>
<p>2^n개의 입력선으로 입력된 값을 n개의 출력선으로 코드화해서 출력하는 조합논리회로</p>
<ul>
<li><strong>2^n개의 입력을 n개의 출력으로</strong>
<ul>
<li>16개의 입력선일 경우 4개의 출력선 필요 (2^4)</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="멀티플렉서">멀티플렉서<a href="#멀티플렉서" class="hash-link" aria-label="멀티플렉서에 대한 직접 링크" title="멀티플렉서에 대한 직접 링크">​</a></h2>
<p>2^n개의 입력선 중 1개를 <strong>선택</strong>하여 그 선에서 입력되는 값을 1개의 출력선으로 출력하는 조합논리회로</p>
<ul>
<li>2^n개의 입력선 중 1개의 선을 선택하기 위해 <strong>n개의 선택선 이용</strong>
<ul>
<li>16개의 입력선일 경우 4개의 선택선 필요 (2^4)</li>
<li><strong>출력선은 하나</strong></li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="디멀티플렉서">디멀티플렉서<a href="#디멀티플렉서" class="hash-link" aria-label="디멀티플렉서에 대한 직접 링크" title="디멀티플렉서에 대한 직접 링크">​</a></h2>
<p>1개의 입력선으로 들어오는 데이터를 2^n개의 출력선 중 1개를 선택하여 출력하는 회로</p>
<ul>
<li>2^n개의 출력선 중 1개의 선을 선택하기 위해 <strong>n개의 선택선 이용</strong></li>
<li>16개의 출력선일 경우 4개의 선택선 필요 (2^4)</li>
<li><strong>입력선은 하나</strong></li>
</ul>
<h1>순서논리회로</h1>
<ul>
<li>외부의 입력과 현재 상태에 따라 출력이 결정</li>
<li>논리 게이트 외에 메모리 요소와 피드백 기능을 포함</li>
<li>기억기능 존재</li>
<li>출력이 일정한 값을 갖지 않음</li>
<li><strong>플리플롭과 논리 게이트로 구성</strong></li>
<li>동기식과 비동기식으로 나뉨</li>
<li><strong>플리플롭, 카운터, 레지스터, RAM, CPU</strong> 등</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="플리플롭">플리플롭<a href="#플리플롭" class="hash-link" aria-label="플리플롭에 대한 직접 링크" title="플리플롭에 대한 직접 링크">​</a></h2>
<ul>
<li>전원이 공급되는한 상태의 변화를 위한 외부신호가 발생할 때까지 현재의 상태를 그대로 유지하는 논리회로</li>
<li>레지스터, 카운터, 반도체메모리(RAM)의 기본 구성요소</li>
<li>2진수 1bit를 저장 가능</li>
<li>두 개의 NAND 또는 두 개의 NOR 게이트를 이용하여 구성</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="특성표">특성표<a href="#특성표" class="hash-link" aria-label="특성표에 대한 직접 링크" title="특성표에 대한 직접 링크">​</a></h3>
<p>순서논리회로의 기능을 나타내는 표로 입력선의 값에 따라 현재 상태가 다음 상태로 어떻게 변하여 저장되는지를 나타낸다.</p>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="여기표">여기표<a href="#여기표" class="hash-link" aria-label="여기표에 대한 직접 링크" title="여기표에 대한 직접 링크">​</a></h3>
<p>특성표 대신 순서논리회로의 기능을 표로 나타낸 것, 현재 상태 값을 새로운 값으로 변경시키려면 입력선으로 어떤 값을 입력해야 하는가를 나타낸다.
출력을 이용하여 입력을 알아내는 것.</p>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="rs-플립플롭">RS 플립플롭<a href="#rs-플립플롭" class="hash-link" aria-label="RS 플립플롭에 대한 직접 링크" title="RS 플립플롭에 대한 직접 링크">​</a></h3>
<ul>
<li>Reset-Set FF</li>
<li>특성표</li>
</ul>
<table><thead><tr><th style="text-align:center">S</th><th style="text-align:center">R</th><th style="text-align:center">Q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">無</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">不可</td></tr></tbody></table>
<ul>
<li>여기표는 특성표를 떠올리면 구할 수 있다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="d-플립플롭">D 플립플롭<a href="#d-플립플롭" class="hash-link" aria-label="D 플립플롭에 대한 직접 링크" title="D 플립플롭에 대한 직접 링크">​</a></h3>
<ul>
<li>RS 플리플롭의 R선에 인버터(NOT 연산자)를 추가하여 S선과 하나로 묶어서 입력선을 하나만 구성한 플립플롭</li>
<li>입력값을 그대로 저장하는 기능을 수행</li>
<li>특성표</li>
</ul>
<table><thead><tr><th style="text-align:center">D</th><th style="text-align:center">Q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="jk-플립플롭">JK 플립플롭<a href="#jk-플립플롭" class="hash-link" aria-label="JK 플립플롭에 대한 직접 링크" title="JK 플립플롭에 대한 직접 링크">​</a></h3>
<ul>
<li>RS에서 S=1, R=1일 때 동작하지 않는 점을 보완한 플립플롭</li>
<li>RS 플립플롭의 입력선 S와 R에 <strong>AND 게이트 2개</strong>를 추가하여 JK 플립플롭의 입력선 J와 K로 사용한다.</li>
<li>모든 플립플롭의 기능을 포함한다.</li>
<li>플립플롭의 네가지 기능을 모두 갖춘 것을 찾으라는 문제가 나오면 RS가   있으면 RS, JK가 있으면 JK</li>
<li>특성표</li>
</ul>
<table><thead><tr><th style="text-align:center">S</th><th style="text-align:center">R</th><th style="text-align:center">Q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">無</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">보수</td></tr></tbody></table>
<ul>
<li>여기표는 특성표를 떠올리면 구할 수 있다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="t-플립플롭">T 플립플롭<a href="#t-플립플롭" class="hash-link" aria-label="T 플립플롭에 대한 직접 링크" title="T 플립플롭에 대한 직접 링크">​</a></h3>
<ul>
<li>JK 플립플롭의 두 입력선을 묶어서 한 개의 입력선으로 구성한 플립플롭</li>
<li>T=1인 경우 현재 상태를 토글한다. <strong>보수가 출력</strong>된다.</li>
<li>카운터에 이용</li>
</ul>
<table><thead><tr><th style="text-align:center">T</th><th style="text-align:center">Q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">無</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">보수</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="ms-플립플롭">M/S 플립플롭<a href="#ms-플립플롭" class="hash-link" aria-label="M/S 플립플롭에 대한 직접 링크" title="M/S 플립플롭에 대한 직접 링크">​</a></h3>
<ul>
<li>마스터-슬레이브 플립플롭</li>
<li>출력 측의 일부가 입력 측에 피드백되어 유발되는 레이스 현상을 없애기 위해 고안된 플립플롭</li>
<li>두 개의 플립플롭으로 구성</li>
<li>레이스 현  상 : 입력이 되는 조합회로의 출력을 플리플롭이 받는 동안 플리플롭의 내부 상태가 변하고 있으면 그 상태값이 피드백통로를 통해 조합회로로 전달되므로 회로가 불안정해지는 현상</li>
</ul>
<h1>자료 구성 단위</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="비트">비트<a href="#비트" class="hash-link" aria-label="비트에 대한 직접 링크" title="비트에 대한 직접 링크">​</a></h2>
<ul>
<li>자료, 정보 표현의 최소 단위</li>
<li>0과 1을 표시하는 2진수 1자리</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="니블">니블<a href="#니블" class="hash-link" aria-label="니블에 대한 직접 링크" title="니블에 대한 직접 링크">​</a></h2>
<ul>
<li>4bit가 모여 구성</li>
<li>16진수 1자리를 표현하기에 적합</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="바이트">바이트<a href="#바이트" class="hash-link" aria-label="바이트에 대한 직접 링크" title="바이트에 대한 직접 링크">​</a></h2>
<ul>
<li><strong>문자를 표현하는 최소 단위</strong></li>
<li>8bit가 모여 1Byte</li>
<li>1Byte는 256가지의 정보를 표현(2^8bit)</li>
<li>Alphanumeric은 1Byte, 한글한자는 2Byte</li>
<li>KB = 2의 10승, MB = 2의 20승...</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="워드">워드<a href="#워드" class="hash-link" aria-label="워드에 대한 직접 링크" title="워드에 대한 직접 링크">​</a></h2>
<ul>
<li>컴퓨터가 한 번에 처리할 수 있는 명령 단위</li>
<li><strong>전워드 : 4Byte</strong> (full word)</li>
<li>하프워드 : 2Byte (반워드)</li>
<li>더블워드 : 8Byte</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="필드">필드<a href="#필드" class="hash-link" aria-label="필드에 대한 직접 링크" title="필드에 대한 직접 링크">​</a></h2>
<ul>
<li>파일 구성의 최소 단위</li>
<li>의미 있는 정보를 표현하는 최소 단 위</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="레코드">레코드<a href="#레코드" class="hash-link" aria-label="레코드에 대한 직접 링크" title="레코드에 대한 직접 링크">​</a></h2>
<ul>
<li>하나 이상의 관련된 필드가 모여서 구성</li>
<li>컴퓨터 내부 자료 처리 단위</li>
<li><strong>논리 레코드</strong>를 의미</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="블록">블록<a href="#블록" class="hash-link" aria-label="블록에 대한 직접 링크" title="블록에 대한 직접 링크">​</a></h2>
<ul>
<li><strong>물리 레코드</strong></li>
<li>하나 이상의 논리 레코드가 모여서 구성</li>
<li>각종 저장 매체와의 입출력 단위를 의미</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="파일">파일<a href="#파일" class="hash-link" aria-label="파일에 대한 직접 링크" title="파일에 대한 직접 링크">​</a></h2>
<ul>
<li>프로그램 구성의 기본 단위</li>
<li>같은 종류의 여러 레코드가 모여서 구성</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="데이터베이스">데이터베이스<a href="#데이터베이스" class="hash-link" aria-label="데이터베이스에 대한 직접 링크" title="데이터베이스에 대한 직접 링크">​</a></h2>
<ul>
<li>여러 개의 관련된 파일의 집합</li>
<li>관계형, 계층형, 망형 DB</li>
</ul>
<h1>진법</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="2진수">2진수<a href="#2진수" class="hash-link" aria-label="2진수에 대한 직접 링크" title="2진수에 대한 직접 링크">​</a></h2>
<p>정수는 나누고 소숫점은 곱하고</p>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="8진수">8진수<a href="#8진수" class="hash-link" aria-label="8진수에 대한 직접 링크" title="8진수에 대한 직접 링크">​</a></h2>
<p>2진수를 구하고 3자리씩 묶고</p>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="16진수">16진수<a href="#16진수" class="hash-link" aria-label="16진수에 대한 직접 링크" title="16진수에 대한 직접 링크">​</a></h2>
<p>2진수를 구하고 4자리씩 묶고</p>
<h1>보수</h1>
<ul>
<li>덧셈회로를 이용하여 뺄셈을 수행하기 위해 사용</li>
<li>1의 보수 : 그냥 반전</li>
<li>2의 보수<!-- -->
<ul>
<li>1의 보수를 구한 뒤 1을 더함</li>
<li>뒤에서부터 1이 나올때까지는 그냥쓰고 나머지는 반전</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="뺄셈">뺄셈<a href="#뺄셈" class="hash-link" aria-label="뺄셈에 대한 직접 링크" title="뺄셈에 대한 직접 링크">​</a></h2>
<ul>
<li>1의 보수 이용 : 자리올림이 발생하면 결과에 자리올림수를 더한다.</li>
<li>2의 보수 이용 : 자리올림이 발생하면 버린다.</li>
</ul>
<h1>고정 소수점</h1>
<p>정수 데이터 표현 및 연산에 사용하는 방법</p>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="2진연산">2진연산<a href="#2진연산" class="hash-link" aria-label="2진연산에 대한 직접 링크" title="2진연산에 대한 직접 링크">​</a></h2>
<ul>
<li>정수값을 2진수로 변환하여 표현하는 방식</li>
<li>표현할 수 있는 범위가 작음</li>
<li>연산속도 빠름</li>
<li>맨처음 1bit는 부호비트로 사용</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="음수연산">음수연산<a href="#음수연산" class="hash-link" aria-label="음수연산에 대한 직접 링크" title="음수연산에 대한 직접 링크">​</a></h3>
<ul>
<li>부호화 절대치법 : 양수 표현에 대해 부호비트만 바꾼다.</li>
<li>부호화 1의 보수법 : 양수 표현에 대해 1의 보수를 구한다.</li>
<li>부호화 2의 보수법 : 양수 표현에 대해 2의 보수를 구한다.<!-- -->
<ul>
<li>1의 보수 표현법에 비해 음수 1개를 더 표현할 수 있다.</li>
<li>자리올림을 무시하므로 1의 보수 표현에 비해 연산이 간단하다.</li>
<li>0이 하나만 존재한다.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>부호화 2진 표현을 10진수로 변경시</strong></p>
<ol>
<li>부호 비트를 빼고 2의 보수 연산</li>
<li>부호를 대입</li>
</ol>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="10진연산">10진연산<a href="#10진연산" class="hash-link" aria-label="10진연산에 대한 직접 링크" title="10진연산에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="언팩연산">언팩연산<a href="#언팩연산" class="hash-link" aria-label="언팩연산에 대한 직접 링크" title="언팩연산에 대한 직접 링크">​</a></h3>
<ul>
<li>존형 10진연산 = Zone Decimal</li>
<li><strong>연산이 불가능</strong>하다.</li>
<li><strong>데이터 입출력에 사용</strong></li>
<li>1Byte로 10진수 1자리를 표현</li>
<li>4개의 존 비트와 4개의 숫자 비트를 사용</li>
<li><strong>최하위 바이트의 존 부분을 부호로 사용</strong></li>
<li>Zone = F, Digit = 4Bit 2진수</li>
<li>Sign = 양수 C, 음수 D, 부호 없는 양수 F</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="팩연산">팩연산<a href="#팩연산" class="hash-link" aria-label="팩연산에 대한 직접 링크" title="팩연산에 대한 직접 링크">​</a></h3>
<ul>
<li><strong>연산이 가능</strong></li>
<li><strong>데이터 입출력 불가능</strong></li>
<li>1Byte로 10진수 2자리를 표현</li>
<li><strong>최하위 바이트의 마지막 4Bit를 부호로 사용</strong></li>
<li>Digit = 4Bit 2진수</li>
<li>Sign = 양수 C, 음수 D, 부호 없는 양수 F</li>
</ul>
<h1>부동소수점</h1>
<ul>
<li>매우 크거나 작은 수, 매우 정밀한 수를 적은 비트로 표현 가능</li>
<li>연산시간이 느림</li>
<li>부동 소수점의 연산 수행횟수를 FLOPS로 표시<!-- -->
<ul>
<li><strong>FLOPS</strong> : FLoating point Operations Per Second, 컴퓨터 연산속도의 단위</li>
</ul>
</li>
<li>지수부와 가 수부를 분리하는 <strong>정규화</strong> 과정 필요
<strong>정규화</strong> : <code>0.1 &lt;= 가수부분 &lt; 1</code> 을 만족시키게 변경</li>
<li>4Byte를 사용하는 단정도와 8Byte를 사용하는 배정도 표현법</li>
<li>지수부에는 정규화해서 분리한 지수값을 <strong>64Bias</strong>법으로 표현<!-- -->
<ul>
<li>64Bias : 지수 7Bit에 100 0000이 입력되어 있고 2^n의 n만큼을 더하고 뺴서 지수를 표현하는 방식</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="ieee-표준">IEEE 표준<a href="#ieee-표준" class="hash-link" aria-label="IEEE 표준에 대한 직접 링크" title="IEEE 표준에 대한 직접 링크">​</a></h2>
<ul>
<li>IEEE 754 표준</li>
<li>정규화시 가수부가 1이되게 정규화</li>
<li><strong>127Bais</strong>를 사용해 지수 8Bit에 0111 1111이 들어있음</li>
</ul>
<table><thead><tr><th style="text-align:center">구분</th><th style="text-align:center">크기</th><th style="text-align:center">부호</th><th style="text-align:center">지수</th><th style="text-align:center">가수</th></tr></thead><tbody><tr><td style="text-align:center">single</td><td style="text-align:center"><strong>32</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>8</strong></td><td style="text-align:center">23</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center"><strong>64</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">52</td></tr><tr><td style="text-align:center">extended</td><td style="text-align:center">80</td><td style="text-align:center">1</td><td style="text-align:center">11</td><td style="text-align:center">68</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="연산">연산<a href="#연산" class="hash-link" aria-label="연산에 대한 직접 링크" title="연산에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="덧셈-및-뺄셈">덧셈 및 뺄셈<a href="#덧셈-및-뺄셈" class="hash-link" aria-label="덧셈 및 뺄셈에 대한 직접 링크" title="덧셈 및 뺄셈에 대한 직접 링크">​</a></h3>
<ol>
<li>0인지 확인</li>
<li>지수가 큰쪽에 수를 맞추어 정규화</li>
<li>연산</li>
<li>결과 정규화</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="곱셈">곱셈<a href="#곱셈" class="hash-link" aria-label="곱셈에 대한 직접 링크" title="곱셈에 대한 직접 링크">​</a></h3>
<ol>
<li>0인지 확인</li>
<li>지수 덧셈</li>
<li>가수 곱셈</li>
<li>결과 정규화</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="나눗셈">나눗셈<a href="#나눗셈" class="hash-link" aria-label="나눗셈에 대한 직접 링크" title="나눗셈에 대한 직접 링크">​</a></h3>
<ol>
<li>0인지 확인</li>
<li>레지스터 초기화</li>
<li>부호 결정</li>
<li>나눠지는 수가 나누는 수보다 작게 나눠지는 수를 정규화</li>
<li>지수 뺄셈</li>
<li>가수 나눗셈</li>
</ol>
<h1>자료 표현</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="bcd">BCD<a href="#bcd" class="hash-link" aria-label="BCD에 대한 직접 링크" title="BCD에 대한 직접 링크">​</a></h2>
<ul>
<li>2진화 10진코드 = Binary Coded Decimal</li>
<li>6Bit 코드로 IBM에서 개발</li>
<li>1개의 문자를 2개의 Zone Bit와 4개의 Digit Bit로 표현</li>
<li>6Bit이므로 64개 문자 표현 가능</li>
<li>1Bit의 Parity Bit를 추가해 <strong>7Bit로 사용</strong></li>
<li><strong>영소문자 표현 불가</strong></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="ascii">ASCII<a href="#ascii" class="hash-link" aria-label="ASCII에 대한 직접 링크" title="ASCII에 대한 직접 링크">​</a></h2>
<ul>
<li>American Standard Code for Information Interchange</li>
<li>7Bit 코드로 미국 표준협회에서 개발</li>
<li>7Bit이므로 128개의 문자 표현 가능</li>
<li>1Bit 의 Parity Bit를 추가해 <strong>8Bit로 사용</strong></li>
<li><strong>영대소문자, 숫자, 제어문자, 특수문자 등 표현 가능</strong></li>
<li>통신 제어용 및 마이크로 컴퓨터의 기본코드로 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="ebcdic">EBCDIC<a href="#ebcdic" class="hash-link" aria-label="EBCDIC에 대한 직접 링크" title="EBCDIC에 대한 직접 링크">​</a></h2>
<ul>
<li>8Bit 코드로 IBM에서 개발</li>
<li>1개의 문자를 4개의 Zone Bit와 4개의 Digit Bit로 표현</li>
<li>8Bit이므로 256개의 문자 표현 가능</li>
<li>1Bit의 Parity Bit를 추가해 <strong>9Bit로 사용</strong></li>
<li><strong>특수문자, 영대소문자, 숫자 등 표현 가능</strong></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="bcd-코드">BCD 코드<a href="#bcd-코드" class="hash-link" aria-label="BCD 코드에 대한 직접 링크" title="BCD 코드에 대한 직접 링크">​</a></h2>
<ul>
<li>10진수 1자리를 2진수 4Bit로 표현</li>
<li><strong>8421 코드</strong></li>
<li><strong>가중치 코드</strong>
<ul>
<li>2진수 각 자리가 고유한 값을 가지는 코드</li>
</ul>
</li>
<li>BCD에서 Zone을 생략한 형태</li>
<li>10진수 입출력이 간편</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="excess3-코드">Excess3 코드<a href="#excess3-코드" class="hash-link" aria-label="Excess3 코드에 대한 직접 링크" title="Excess3 코드에 대한 직접 링크">​</a></h2>
<ul>
<li>BCD 코드에 3을 더하여 만든 코드</li>
<li>모든 비트가 동시에 0이 되는 경우가 없다.</li>
<li><strong>3 초과 코드</strong></li>
<li><strong>자기보수 코드</strong></li>
<li><strong>비가중치 코드</strong></li>
<li>10진수를 표현하기 위함이다.</li>
<li>보수를 구하기 편해 산술연산에 좋다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="gray-코드">Gray 코드<a href="#gray-코드" class="hash-link" aria-label="Gray 코드  에 대한 직접 링크" title="Gray 코드에 대한 직접 링크">​</a></h2>
<ul>
<li>BCD 코드의 인접하는 Bit를 XOR 연산하여 만든 코드</li>
<li>코드 변환이 용이</li>
<li>입출력장치, A/D변환기, 주변장치 등에서 숫자를 표현할 때 사용</li>
<li>1Bit만 변화시켜 다음 수치로 증가시키기 때문에 하드웨어 오류가 적다.</li>
<li>2진수를 Gray로 변경시 : n자 모양으로 연산<!-- -->
<ul>
<li>첫번째 그레이 비트는 2진수 첫번째 비트 그대로</li>
<li>2진수 비트를 앞뒤로 XOR 연산</li>
</ul>
</li>
<li>Gray를 2진수로 변경시 : h자 모양으로 연산<!-- -->
<ul>
<li>첫번째 2진수는 그레이 비트 그대로</li>
<li>두번째부턴 왼쪽 변경된 2진수와 변경할 우측 그레이 비트를 XOR 연산</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="패리티-코드">패리티 코드<a href="#패리티-코드" class="hash-link" aria-label="패리티 코드에 대한 직접 링크" title="패리티 코드에 대한 직접 링크">​</a></h2>
<ul>
<li>전송된 코드의 오류를 검사하기 위해 데이터 비트 외에 1Bit의 패리티 체크 비트를 추가하는 것</li>
<li>1Bit의 오류만 검출 가능</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="홀수-패리티">홀수 패리티<a href="#홀수-패리티" class="hash-link" aria-label="홀수 패리티에 대한 직접 링크" title="홀수 패리티에 대한 직접 링크">​</a></h3>
<ul>
<li>Odd Parity = 기수 패리티</li>
<li>1의 갯수가 홀수가 되도록 0이나 1을 마지막에 추가</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="짝수-패리티">짝수 패리티<a href="#짝수-패리티" class="hash-link" aria-label="짝수 패리티에 대한 직접 링크" title="짝수 패리티에 대한 직접 링크">​</a></h3>
<ul>
<li>Even Parity = 우수 패리티</li>
<li>1의 갯수가 짝수가 되도록 0이나 1을 마지막에 추가</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="해밍-코드">해밍 코드<a href="#해밍-코드" class="hash-link" aria-label="해밍 코드에 대한 직접 링크" title="해밍 코드에 대한 직접 링크">​</a></h2>
<ul>
<li>오류를 검출하고 교정이 가능한 코드</li>
<li>2Bit의 오류를 검출할 수 있고 1Bit를 교정 가능</li>
<li>잉여비트가 많이 필요</li>
<li>1, 2, 4, 8, ... <strong>2^n번째 Bit는 오류 검출을 위한 패리티 비트</strong></li>
<li>패리티 비트 결정시<!-- -->
<ul>
<li>1번 Bit는 1, 3, 5, 7...</li>
<li>2번 Bit는 2, 3, 6, 7, 10, 11... 2Bit씩 건너 뛰면서</li>
<li>4번 Bit는 4, 5, 6, 7, 12, 13, 14, 15... 4Bit씩 건너 뛰면서</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="코드-분류">코드 분류<a href="#코드-분류" class="hash-link" aria-label="코드 분류에 대한 직접 링크" title="코드 분류에 대한 직접 링크">​</a></h2>
<p>가중치코드는 일반적으로 숫자로 이루어져 있다.</p>
<table><thead><tr><th style="text-align:center">분류</th><th style="text-align:center">코드종류</th></tr></thead><tbody><tr><td style="text-align:center">가중치</td><td style="text-align:center">BCD(8421), 2421, 84-2-1, Biquinary, 51111, RingCounter</td></tr><tr><td style="text-align:center">비가중치</td><td style="text-align:center">3초과(Excess3), Gray, Jonson, 2outof5, 3outof5</td></tr><tr><td style="text-align:center">자기보수</td><td style="text-align:center">3초과(Excess3), 2421, 51111, 84-2-1</td></tr><tr><td style="text-align:center">오류검출</td><td style="text-align:center">해밍, 패리티, Biquinary, RingCounter, 2outof5, 3outof5</td></tr></tbody></table>
<h1>중앙처리장치</h1>
<p><strong>제어장치, 연산장치, 레지스터, 버스</strong>로 구성</p>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="제어장치">제어장치<a href="#제어장치" class="hash-link" aria-label="제어장치에 대한 직접 링크" title="제어장치에 대한  직접 링크">​</a></h2>
<ul>
<li>컴퓨터의 모든 장치에 대한 동작을 지시하고 제어</li>
<li>명령 레지스터에서 읽어들인 명령어를 해독해 장치에 제어신호를 보내 명령을 수행하도록 지시</li>
<li>제어장치에 입력되는 항목<!-- -->
<ul>
<li>명령어 레지스터</li>
<li>플래그</li>
<li>클록</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="구성요소">구성요소<a href="#구성요소" class="hash-link" aria-label="구성요소에 대한 직접 링크" title="구성요소에 대한 직접 링크">​</a></h3>
<ul>
<li>명령 레지스터 : 현재 실행중인 명령어 내용 기억</li>
<li>명령 해독기(디코더) : 명령 레지스터에 있는 명령어를 해독</li>
<li>제어 발생기(인코더) : 해독된 명령에 따라 각 장치로 본래 제어 신호 생성</li>
<li>제어 주소 레지스터(CAR) : 다음에 실행할 마이크로 명령어의 주소를 저장하는 레지스터<!-- -->
<ul>
<li>매핑의 결과값, 주소필드, 서브루틴 레지스터의 내용이 기록</li>
</ul>
</li>
<li>제어 버퍼 레지스터(CBR) : 제어 기억장치로부터 읽혀진 마이크로명령어를 일시적으로 저장하는 레지스터</li>
<li>제어 기억장치 : 마이크로 프로그램을 저장하는 내부 기억장치</li>
<li>순서 제어모듈 : 마이크로 명령어의 실행 순서를 결정하는 회로집합</li>
<li>순차 카운터 : 디코더에 의해 선택된 번호에 해당하는 타이밍 신호를 생성</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="연산장치">연산장치<a href="#연산장치" class="hash-link" aria-label="연산장치에 대한 직접 링크" title="연산장치에 대한 직접 링크">​</a></h2>
<ul>
<li>제어장치에 명령에 따라 실제로 연산을 수행하는 장치</li>
<li>산술연산, 논리연산, 관계연산, Shift 등</li>
<li>가산기, 누산기(AC), 보수기(Complementor), 데이터레지스터, 오버플로 검출기, 시프트 레지스터 등</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="레지스터">레지스터<a href="#레지스터" class="hash-link" aria-label="레지스터에 대한 직접 링크" title="레지스터에 대한 직접 링크">​</a></h2>
<ul>
<li>CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소</li>
<li>플리플롭이나 래치들을 병렬로 연결하여 구성</li>
<li>메모리 중에서 속도가 가장 빠르다.</li>
<li>레지스터의 크기는 워드를 구성하는 비트 개수만큼의 플립플롭으로 구성<!-- -->
<ul>
<li>워드의 크기가 16Bit =&gt; 레지스터는 16개의 플립플롭이나 래치로 구성</li>
</ul>
</li>
<li>저장값을 0으로 하는 것을 설정해제(CLR)</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="자료전송">자료전송<a href="#자료전송" class="hash-link" aria-label="자료전송에 대한 직접 링크" title="자료전송에 대한 직접 링크">​</a></h3>
<ul>
<li>직렬 전송 : 직렬 시프트 마이크로 오퍼레이션, 느림</li>
<li>병렬 전송 : 하나의 클록펄스 동안 워드가 동시에 전송</li>
<li>버스 전송 : 모든 레지스터가 공통으로 이용하는 경로, 병렬에 비해 결선의 수를 줄일 수 있다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="주요-레지스터">주요 레지스터<a href="#주요-레지스터" class="hash-link" aria-label="주요 레지스터에 대한 직접 링크" title="주요 레지스터에 대한 직접 링크">​</a></h3>
<ul>
<li><strong>PC</strong> : 프로그램 카운터, 다음번 실행할 명령어의 번지를 기억하는 레지스터로 분기 명령이 실행되는 경우 그 목적지 주소로 갱신</li>
<li><strong>IR</strong> : 명령레지스터, 현재 실행중인 명령의 내용을 기억하는 레지스터</li>
<li><strong>AC</strong> : 누산기, 연산된 결과를 일시적으로 저장하는 레지스터</li>
<li><strong>PSWR</strong> : <strong>Status Register, Program Status Word Register, Flag Regiester</strong>
<ul>
<li>시스템 내부의 순간 상태가 기록된 정보를 PSW라 한다.</li>
<li>오버플로, 언더플로, 자리올림, 계산상태, 인터럽트 등의 PSW를 저장하는 레지스터</li>
<li>프로그램 제어와 밀접한 관계</li>
</ul>
</li>
<li><strong>MAR</strong> : 메모리 주소 레지스터, 데이터의 번지를 기억하는 레지스터</li>
<li><strong>MBR</strong> : 메모리 버퍼 레지스터, 데이터가 잠시 기억되는 레지스터, CPU가 데이터를 처리하기 위해서 반드시 거처야한다.</li>
<li>Base Register : 명령이 시작되는 시작 번지를 기억하는 레지스터</li>
<li>Index Register : 주소의 변경, 서브루틴 연결 및 프로그램에서의 반복연산의 횟수를 세는 레지스터로 프로그래머가 내용을 변경할 수 있다.</li>
<li>Data Register : 연산에 사용될 데이터를 기억하는 레지스터</li>
<li>Shift Register : 저장된 값을 미는 연산을 하는 레지스터, 2배 길이 레지스터</li>
<li>Major Status Register : CPU의 현재상태(인출, 간접, 실행, 인터럽트)를 저장하고 있는 레지스터</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="버스">버스<a href="#버스" class="hash-link" aria-label="버스에 대한 직접 링크" title="버스에 대한 직접 링크">​</a></h2>
<ul>
<li>CPU, 메모리, I/O장치와 상호 필요한 정보를 교환하기 위해 연결하는 전송선</li>
<li>내부회로에서 버스를 사용하는 목적은 결선의 수를 줄이기 위해서다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="종류">종류<a href="#종류" class="hash-link" aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크">​</a></h3>
<ul>
<li><strong>제어 버스</strong> : Control Bus, <strong>양방향 전송선</strong>, 제어신호 전송</li>
<li><strong>주소 버스</strong> : Address Bus, 번지 버스, <strong>단방향 전송선</strong>, 번지 지정</li>
<li><strong>데이터 버스</strong> : Data Bus, 자료 버스, <strong>양방향 전송선</strong>, 데이터 전송</li>
<li>내부버스 : CPU 및 메모리에 구성된 버스</li>
<li>외부버스 : 주변 I/O장치에 구성된 버스</li>
</ul>
<h1>명령어</h1>
<p>OP code부, Mode부, Operand부로 구성</p>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="연산자부">연산자부<a href="#연산자부" class="hash-link" aria-label="연산자부에 대한 직접 링크" title="연산자부에 대한 직접 링크">​</a></h2>
<ul>
<li>Operation Code부 = OP Code</li>
<li>연산자부의 크기는 표현할 수 있는 명령의 종류를 나타내는 것</li>
<li>nBit일 때 최대 2^n의 명령어 표현 가능</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="모드부">모드부<a href="#모드부" class="hash-link" aria-label="모드부에 대한 직접 링크" title="모드부에 대한 직접 링크">​</a></h2>
<ul>
<li>Mode부</li>
<li>주소부의 유효 주소가 결정되는 방법을 지정</li>
<li>0이면 직접, 1이면 간접</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="자료부">자료부<a href="#자료부" class="hash-link" aria-label="자료부에 대한 직접 링크" title="자료부에 대한 직접 링크">​</a></h2>
<ul>
<li>Operand부 = 오퍼랜드부 = 주소필드</li>
<li>실제 데이터에 대한 정보를 표시하는 부분</li>
<li>주소, 레지스터 번호, 사용할 데이터 등을 표시</li>
<li>자료부의 크기는 메모리 용량과 관계가 있다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="설계시-고려사항">설계시 고려사항<a href="#설계시-고려사항" class="hash-link" aria-label="설계시 고려사항에 대한 직접 링크" title="설계시 고려사항에 대한 직접 링크">​</a></h2>
<ul>
<li>연산자의 종류</li>
<li>명령어 형식</li>
<li>주소지정방식</li>
<li>데이터 구조</li>
<li>효율성 제고방안 : 기억공간, 사용빈도, 주소지정방식, 주기억장치의 대역폭 이용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="기능">기능<a href="#기능" class="hash-link" aria-label="기능에 대한 직접 링크" title="기능에 대한 직접 링크">​</a></h2>
<p>함수 연산, 자료전달, 제어, 입출력 기능</p>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="함수-연산-기능">함수 연산 기능<a href="#함수-연산-기능" class="hash-link" aria-label="함수 연산 기능에 대한 직접 링크" title="함수 연산 기능에 대한 직접 링크">​</a></h3>
<ul>
<li>산술연산 : ADD, SUB, MUL, DIV, 산술 Shift</li>
<li>논리연산 : NOT, AND, OR, XOR, 논리 Shift, Rotate, Complement, Clear</li>
<li>단항연산 : NOT, Complement, Shift, Rotate, Move</li>
<li>이항연산 : 사칙, AND, OR, XOR, XNOR</li>
<li>연산자 우선순위<!-- -->
<ol>
<li>산술연산자 : 거듭제곱 &gt; 곱=나눔 &gt; 덧,뺄</li>
<li>관계연산자</li>
<li>논리 연산자 : NOT &gt; AND &gt; OR</li>
</ol>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="자료-전달-기능">자료 전달 기능<a href="#자료-전달-기능" class="hash-link" aria-label="자료 전달 기능에 대한 직접 링크" title="자료 전달 기능에 대한 직접 링크">​</a></h3>
<ul>
<li>Load : 기억장치 =&gt; CPU</li>
<li>Store : CPU =&gt; 기억장치 저장</li>
<li>Move : 레지스터간 자료 전송</li>
<li>Push : 스택에 자료 저장</li>
<li>Pop : 스택에서 자료 꺼냄</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="제어-기능">제어 기능<a href="#제어-기능" class="hash-link" aria-label="제어 기능에 대한 직접 링크" title="제어 기능에 대한 직접 링크">​</a></h3>
<ul>
<li>무조건 분기 : <code>GOTO, JMP (PC &lt;- X)</code></li>
<li>조건 분기 : IF, SPA, SNA, SZA<!-- -->
<ul>
<li>SPA : Skip if AC is Positive</li>
<li>SNA : Skip if AC is Negative</li>
<li>SZA : Skip if AC is Zero</li>
</ul>
</li>
<li>Call : 부 프로그램 호출</li>
<li>Return : 부 프로그램에서 복귀</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="입출력-기능">입출력 기능<a href="#입출력-기능" class="hash-link" aria-label="입출력 기능에 대한 직접 링크" title="입출력 기능에 대한 직접 링크">​</a></h3>
<ul>
<li>Input</li>
<li>Output</li>
</ul>
<h1>연산</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="and">AND<a href="#and" class="hash-link" aria-label="AND에 대한 직접 링크" title="AND에 대한 직접 링크">​</a></h2>
<ul>
<li>특정 비트를 삭제(Clear)하는 연산</li>
<li>Masking 연산</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="or">OR<a href="#or" class="hash-link" aria-label="OR에 대한 직접 링크" title="OR에 대한 직접 링크">​</a></h2>
<ul>
<li>특정 비트를 1로 만드는 연산</li>
<li>Selective Set 연산</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="xor">XOR<a href="#xor" class="hash-link" aria-label="XOR에 대한 직접 링크" title="XOR에 대한 직접 링크">​</a></h2>
<ul>
<li>두 개의 데이터를 비교하거나 특정 비트를 반전시킬 때 사용</li>
<li>결과에 1Bit라도 1이 있으면 서로 다른 데이터</li>
<li>반전시킬 Bit를 1과 XOR</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="not">NOT<a href="#not" class="hash-link" aria-label="NOT에 대한 직접 링크" title="NOT에 대한 직접 링크">​</a></h2>
<ul>
<li>그냥 반전</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="논리-shift">논리 Shift<a href="#논리-shift" class="hash-link" aria-label="논리 Shift에 대한 직접 링크" title="논리 Shift에 대한 직접 링크">​</a></h2>
<ul>
<li>0을 삽입해 비트를 좌우로 한칸씩 민다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="rotate">Rotate<a href="#rotate" class="hash-link" aria-label="Rotate에 대한 직접 링크" title="Rotate에 대한 직접   링크">​</a></h2>
<ul>
<li>Shift에서 밀려나간 비트를 반대편으로 가져와 입력하는 연산</li>
<li><strong>문자 위치를 변환할 때</strong> 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="산술-shift">산술 Shift<a href="#산술-shift" class="hash-link" aria-label="산술 Shift에 대한 직접 링크" title="산술 Shift에 대한 직접 링크">​</a></h2>
<ul>
<li>부호를 고려하여 자리를 이동시키는 연산</li>
<li>2^n으로 곱하거나 나눌 때 사용</li>
<li>왼쪽으로 Shift시 2^n을 곱한 값과 같음</li>
<li>오른쪽으로 Shift시 2^n을 나눈 값과 같음</li>
<li>홀수를 오른쪽으로 Shift시에 0.5의 오차 발생</li>
<li>정수 표현 방식에서만 사용 가능</li>
<li>정수 수치 표현 방법에 따라 Padding Bit 및 결과가 다름</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="shift-left">Shift Left<a href="#shift-left" class="hash-link" aria-label="Shift Left에 대한 직접 링크" title="Shift Left에 대한 직접 링크">​</a></h3>
<ul>
<li>부호화 절대치, 2의 보수법은 무조건 0</li>
<li>1의 보수법은 부호 비트와 같은 0, 1</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="shift-right">Shift Right<a href="#shift-right" class="hash-link" aria-label="Shift Right에 대한 직접 링크" title="Shift Right에 대한 직접 링크">​</a></h3>
<ul>
<li>부호화 절대치는 0</li>
<li>1의 보수법, 2의 보수법은 부호 비트와 같은 0, 1</li>
</ul>
<h1>명령어 형식</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="3주소-명령어">3주소 명령어<a href="#3주소-명령어" class="hash-link" aria-label="3주소 명령어에 대한 직접 링크" title="3주소 명령어에 대한 직접 링크">​</a></h2>
<ul>
<li>Operand부가 세 개로 구성되는 명령어 형식</li>
<li>**GPR(범용 레지스터)**를 가진 컴퓨터에서 사용</li>
<li>연산의 결과는 Operand 1에 주로 기록 (컴퓨터에 따라 Operand 3에  도 기록)</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="장점">장점<a href="#장점" class="hash-link" aria-label="장점에 대한 직접 링크" title="장점에 대한 직접 링크">​</a></h3>
<ul>
<li>연산시 원래 자료를 파괴하지 않음</li>
<li>다른 형식의 명령어를 이용하는 것보다 프로그램 전체의 길이가 짧음</li>
<li>전체 프로그램 실행시 명령인출을 위해 주기억장치를 접근하는 횟수 감소</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="단점">단점<a href="#단점" class="hash-link" aria-label="단점에 대한 직접 링크" title="단점에 대한 직접 링크">​</a></h3>
<ul>
<li>명령어 한 개의 길이가 너무 길어짐</li>
<li>하나의 명령을 수행하기 위해 최소한 4번 기억장소에 접근해야함</li>
<li>수행시간이 길다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="2주소-명령어">2주소 명령어<a href="#2주소-명령어" class="hash-link" aria-label="2주소 명령어에 대한 직접 링크" title="2주소 명령어에 대한 직접 링크">​</a></h2>
<ul>
<li>Operand가 두 개로 구성되는 일반적인 명령어 형식</li>
<li>여러 개의 **GPR(범용 레지스터)**를 가진 컴퓨터에서 사용</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="장점-1">장점<a href="#장점-1" class="hash-link" aria-label="장점에 대한 직접 링크" title="장점에 대한 직접 링크">​</a></h3>
<ul>
<li>실행 속도가 빠르고 기억장소를 많이 차지하지 않음</li>
<li>3주소 명령에 비해 명령어의 길이가 짧음</li>
<li>계산결과가 기억장치에 기억되고 CPU에도 남아 있어 계산 결과를 시험할 때 시간이 절약된다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="단점-1">단점<a href="#단점-1" class="hash-link" aria-label="단점에 대한 직접 링크" title="단점에 대한 직접 링크">​</a></h3>
<ul>
<li>연산 결과가 주로 Operand1에  저장되므로 원래 Operand1에 있던 자료는 파괴된다.</li>
<li>전체 프로그램의 길이가 길어진다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="1주소-명령어">1주소 명령어<a href="#1주소-명령어" class="hash-link" aria-label="1주소 명령어에 대한 직접 링크" title="1주소 명령어에 대한 직접 링크">​</a></h2>
<ul>
<li>Operand가 한 개로 구성된 명령어 형식</li>
<li><strong>AC</strong>를 이용하여 명령어를 처리하므로 결과도 <strong>누산기</strong>에 저장된다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="0주소-명령어">0주소 명령어<a href="#0주소-명령어" class="hash-link" aria-label="0주소 명령어에 대한 직접 링크" title="0주소 명령어에 대한 직접 링크">​</a></h2>
<ul>
<li>Operand부 없이 OPCode만으로 구성</li>
<li>모든 연산은 Stack 메모리의 Stack Pointer가 가리키는 Operand를 이용하여 수행</li>
<li>스택 머신</li>
<li>인스트럭션 수행시간이 짧다.</li>
<li>기억공간 이용이 효율적</li>
<li>수식을 계산하기 위해선 Postfix 형태로 변경해야한다.</li>
<li>연산 결과를 다시 스택에 넣기 때문에 원래의 자료가 남지 않는다.</li>
</ul>
<h1>주소지정방식</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="고려사항">고려사항<a href="#고려사항" class="hash-link" aria-label="고려사항에 대한 직접 링크" title="고려사항에 대한 직접 링크">​</a></h2>
<ul>
<li>표현의 효율성 : 빠르게 접근가능하고, 주소지정에 적은 비트를 사용해야하며 다양항 Address 모드를 사용할 수 있어야한다.</li>
<li>사용의 편리성 : 프로그램 작업을 위해 포인터, 프로그램 리로케이션 등의 편의를 제공해야한다.</li>
<li>주소공간과 기억공간의 독립성 : 프로그램에서 사용한 주소를 변경 없이 실제 기억공간 내의 주소로 재배치할 수 있도록 서로 독립적이 여야한다.<!-- -->
<ul>
<li>주소공간 : 보조기억장치 내의 기억공간</li>
<li>기억공간 : 주기억장치 내의 기억공간</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="암시적-주소지정방식">암시적 주소지정방식<a href="#암시적-주소지정방식" class="hash-link" aria-label="암시적 주소지정방식에 대한 직접 링크" title="암시적 주소지정방식에 대한 직접 링크">​</a></h2>
<ul>
<li>명령 실행에 필요한 데이터의 위치를 지정하지 않고 누산기나 스택의 데이터를 묵시적으로 지정하여 사용</li>
<li>오퍼랜드가 없는 명령이나 오퍼랜드가 1개인 명령어 형식에 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="즉시적-주소지정방식">즉시적 주소지정방식<a href="#즉시적-주소지정방식" class="hash-link" aria-label="즉시적 주소지정방식에 대한 직접 링크" title="즉시적 주소지정방식에 대한 직접 링크">​</a></h2>
<ul>
<li>명령어 자체에 오퍼랜드를 가지고 있는 방식</li>
<li>별도의 기억장소를 액세스하지 않기 때문에 실행 속도가 빠르다.</li>
<li>데이터 값 범위가 제한적이다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="직접-주소지정방식">직접 주소지정방식<a href="#직접-주소지정방식" class="hash-link" aria-label="직접 주소지정방식에 대한 직접 링크" title="직접 주소지정방식에 대한 직접 링크">​</a></h2>
<ul>
<li>오퍼렌드부에 표현된 주소를 이용해 실제 데이터가 기억된 기억장소에 직접 매핑</li>
<li>실제 사용할 데이터의 유효주소를 적기 때문에 주소 길이에 제약을 받음</li>
<li>nBit 오퍼랜드부 =&gt; 2^n 개의 주소 표현 가능</li>
<li>오퍼렌드부에 데이터를 가지고 있는 레지스터의 번호를 지정하면 레지스터 모드</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="간접-주소지정방식">간접 주소지정방식<a href="#간접-주소지정방식" class="hash-link" aria-label="간접 주소지정방식에 대한 직접 링크" title="간접 주소지정방식에 대한 직접 링크">​</a></h2>
<ul>
<li>주기억장치를 두 번 이상 접근하여 데이터가 있는 기억장소에 도달</li>
<li>오퍼랜드부에 할당된 비트 수로 주소를 나타낼 수 없을 때 사용하는 방식</li>
<li>명령어의 길이가 짧고 제한되어도 긴 주소에 접근이 가능한 방식</li>
<li>레지스터 간접모드</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="계산에-의한-주소지정방식">계산에 의한 주소지정방식<a href="#계산에-의한-주소지정방식" class="hash-link" aria-label="계산에 의한 주소지정방식에 대한 직접 링크" title="계산에 의한 주소지정방식에 대한 직접 링크">​</a></h2>
<ul>
<li>오퍼랜드부와 CPU의 특정 레지스터 값이 더해져서 유효주소를 계산하는 방식</li>
<li>약식 주소</li>
<li>상대주소 : 명령어 주소 + PC</li>
<li>베이스 레지스터 : 명령어 주소 + Base Register<!-- -->
<ul>
<li>명령어의 시작주소를 가지고 있는 레지스터</li>
<li>베이스 레지스터의 값과 명령어에 포함된 변위값을 더해 유효주소를 얻는 것을 재배치라고 한다.</li>
</ul>
</li>
<li>인덱스 레지스터 : 명령어 주소 + Index Register</li>
</ul>
<h1>마이크로 오퍼레이션</h1>
<ul>
<li>인스트럭션을 수행하기 위해 CPU 내의 레지스터와 플래그가 의미있는 상태변환을 하도록하는 동작</li>
<li>레지스터에 저장된 데이터에 의해 이루어진다.</li>
<li>한 개의 클록펄스 동안 실행되는 기본 동작</li>
<li>모든 마이크로 오퍼레이션은 CPU의 클록펄스에 맞춰 실행된다.</li>
<li>순서를 결정하기 위해 제어장치가 발생하는 신호를 제어신호</li>
<li>제어워드 : 레지스어틔 선택과 산술논리연산장치의 역  할을 결정하고 어떤 마이크로 연산을 할 지 결정하는 비트의 모임 = 마이크로 명령어</li>
<li>마이크로 프로그램 : 제어워드가 저장되 있을 때 마이크로 프로그램</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="마이크로-사이클-타임">마이크로 사이클 타임<a href="#마이크로-사이클-타임" class="hash-link" aria-label="마이크로 사이클 타임에 대한 직접 링크" title="마이크로 사이클 타임에 대한 직접 링크">​</a></h2>
<ul>
<li>한 개의 마이크로 오퍼레이션을 수행하는데 걸리는 시간</li>
<li>CPU는 클록펄스에 의해 동기화되어 동작하는데 펄스를 CPU 클록이라하며 한 개의 마이크로 오퍼레이션은 CPU 클록 발생 주기의 간격 내에 실행된다.</li>
<li>CPU Cycle Time = CPU Clock Time</li>
<li>CPU 속도를 나타내는 척도</li>
<li>1us = 10^-6s, 1ns = 10^-9s</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="동기-고정식">동기 고정식<a href="#동기-고정식" class="hash-link" aria-label="동기 고정식에 대한 직접 링크" title="동기 고정식에 대한 직접 링크">​</a></h3>
<ul>
<li>모든 마이크로 오퍼레이션 동작시간이 같다고 가정해 클록 주기를 마이크로 사이클 타임과 같도록 정의하는 방식</li>
<li>동작 시간이 가장 긴 마이크로 오퍼레이션의 동작시간을 마이크로 사이클 타임으로 정한다.</li>
<li>모든 마이크로 오퍼레이션 동작시간이 비슷할 때 유리하다.</li>
<li>CPU 낭비가 심하다.</li>
<li>구현이 쉽다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="동기-가변식">동기 가변식<a href="#동기-가변식" class="hash-link" aria-label="동기 가변식에 대한 직접 링크" title="동기 가변식에 대한 직접 링크">​</a></h3>
<ul>
<li>수행시간이 유사한 마이크로 오퍼레이션끼리 그룹을 만들어 그룹별로 서로 다른 마이크로 사이클 타  임을 정의하는 방식</li>
<li>수행시간이 현저한 차이를 나타낼 때 사용</li>
<li>CPU 시간 낭비를 줄일 수 있다.</li>
<li>구현이 복잡하다.</li>
<li>각 그룹(집합) 간 서로 다른 사이클 타임의 동기를 맞추기 위해 그룹간 마이크로 사이클 타임을 정수배가 되게 한다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="비동기식">비동기식<a href="#비동기식" class="hash-link" aria-label="비동기식에 대한 직접 링크" title="비동기식에 대한 직접 링크">​</a></h3>
<ul>
<li>모든 마이크로 오퍼레이션이 서로 다른 마이크로 사이클 타임을 가진다.</li>
<li>시간 낭비는 없다.</li>
<li>구현이 매우 복잡하다.</li>
<li>실제로 거의 사용되지 않는다.</li>
</ul>
<h1>메이저 스테이트</h1>
<ul>
<li>현재 CPU가 무엇을 하고 있는가를 나타내는 상태</li>
<li>Fetch, Indirect, Execute, Interrupt</li>
<li>Major Cycle = Machine Cycle</li>
<li>메이저 스테이트 레지스터를 통해 알 수 있다.</li>
<li>F와 R 플립플롭의 상태에 따라 메이저 스테이트 상태가 결정된다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="fetch-cycle">Fetch Cycle<a href="#fetch-cycle" class="hash-link" aria-label="Fetch Cycle에 대한 직접 링크" title="Fetch Cycle에 대한 직접 링크">​</a></h2>
<ul>
<li>인출단계</li>
<li>중앙처리장치의 명령 레지스터로 명령어를 가져와 해독하는 단계</li>
<li>가장 먼저 수행되는 동작</li>
<li>1Cycle 명령어면 수행 후 다시 Fetch Cycle로 변경됨</li>
<li>1Cycle 명령어가 아니면 모드 비트에 따라 직 간접 주소를 판단</li>
<li>모드가 0이면 직접주소 =&gt; Execute 단계로</li>
<li>모드가 1이면 간접주소 =&gt; Indirect 단계로</li>
</ul>
<table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C0t0</td><td style="text-align:center">MAR ← PC</td><td style="text-align:center">PC의 번지를 MAR으로 전송</td></tr><tr><td style="text-align:center">C0t1</td><td style="text-align:center">MBR ← M[MAR]<br>PC ← PC +1</td><td style="text-align:center">MAR의 지정하는 위치의 <strong>값을 MBR에 전송</strong> 후<br>다음 시행할 명령 위치를 지정</td></tr><tr><td style="text-align:center">C0t2</td><td style="text-align:center">IR ← MBR[OP]<br>I ← MBR[I]</td><td style="text-align:center">명령어의 OPCode를 명령 레지스터에 전송<br>명령어의 모드 비트를 플립플롭 I에 전송</td></tr><tr><td style="text-align:center">C0t3</td><td style="text-align:center">F ← 1 OR R ← 1</td><td style="text-align:center">I에 따라 F나 R에 1 전송</td></tr></tbody></table>
<blockquote>
<ul>
<li>PC : 다음 실행할 명령의 주소가 들어있음</li>
<li>MAR : 저장하거나 읽어올 주기억장치의 주소가 들어있음</li>
<li>MBR : 주기억장치에서 읽어오거나 저장할 데이터가 들어있음</li>
<li>M[MAR] : 메모리에서 MAR에 해당하는 실제 데이터</li>
<li>IR : 현재 실행하는 명령어가 들어있음</li>
<li>OP : 명령 코드 부분</li>
<li>I : 모드 비트</li>
<li>AD : 명령 주소 부분</li>
<li>F, R : 다음 상태를 지정하는 플립플롭</li>
</ul>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="indirect-cycle">Indirect Cycle<a href="#indirect-cycle" class="hash-link" aria-label="Indirect Cycle에 대한 직접 링크" title="Indirect Cycle에 대한 직접 링크">​</a></h2>
<ul>
<li>Fetch 단계에서 해석한 주소를 읽어온 후 간접주소이면 유효주소를 계산하기 위해 다시 Indirect 단계를 수행</li>
<li>직접주소인 경우 Execute 단계 또는 Fetch 단계로 이동<!-- -->
<ul>
<li>분기같은 1Cycle 명령이면 Fetch로</li>
<li>실행이면 Execute로</li>
</ul>
</li>
</ul>
<table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C1t0</td><td style="text-align:center">MAR ← MBR[AD]</td><td style="text-align:center">MBR에 있는 명령어의 주소를 MAR에 전송</td></tr><tr><td style="text-align:center">C1t1</td><td style="text-align:center">MBR ← M[MAR]</td><td style="text-align:center">MAR이 지정하는 메모리의 실제 데이터를 MBR에 전송</td></tr><tr><td style="text-align:center">C1t2</td><td style="text-align:center">-</td><td style="text-align:center">동작없음</td></tr><tr><td style="text-align:center">C1t3</td><td style="text-align:center">F ← 1, R ← 0</td><td style="text-align:center">Execute 단계로 이동</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="execute-cycle">Execute Cycle<a href="#execute-cycle" class="hash-link" aria-label="Execute Cycle에 대한 직접 링크" title="Execute Cycle에 대한 직접 링크">​</a></h2>
<ul>
<li>해석된 명령을 실행하는 단계</li>
<li>플래그 레지스터의 상태를 검사하여 Interrupt 단계로 갈지 결정</li>
</ul>
<table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C2t0</td><td style="text-align:center">MAR ← MBR[AD]</td><td style="text-align:center">MBR에 있는 명령어의 주소를 MAR에 전송</td></tr><tr><td style="text-align:center">C2t1</td><td style="text-align:center">MBR ← M[MAR]</td><td style="text-align:center">MAR이 지정하는 메모리의 실제 데이터를 MBR에 전송</td></tr><tr><td style="text-align:center">C2t2</td><td style="text-align:center">AC ← AC + MBR</td><td style="text-align:center">누산기에 값과 MBR의 값을 더해 ADD 연산 실행</td></tr><tr><td style="text-align:center">C2t3</td><td style="text-align:center">F ← 0 OR R ← 1</td><td style="text-align:center">F = 0이면 Fetch로, R = 1이면 Interrupt로</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="interrupt-cycle">Interrupt Cycle<a href="#interrupt-cycle" class="hash-link" aria-label="Interrupt Cycle에 대한 직접 링크" title="Interrupt Cycle에 대한 직접 링크">​</a></h2>
<ul>
<li>인터럽트 발생시 복귀주소를 저장시키고 인터럽트 처리 프로그램의 첫 번째 명령으로 제어순서를 옮긴다.</li>
<li>인터럽트 단계는 항상 Fetch 단계로 이동된다.</li>
<li>메모리의 인터럽트 주소는 0번지에 저장되고, 인터럽트 벡터는 인터럽트 처리 프로그램의 주소 번지를 말한다.</li>
<li>현재 상태를 저장하고 인터럽트가 처리된다.</li>
<li>인터럽트 처리시 다음 실행주소를 PC에 넣고 인터럽트 벡터로 이동한다.</li>
</ul>
<table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C3t0</td><td style="text-align:center">MBR[AD] ← PC<br>PC ← 0</td><td style="text-align:center">다음 실행 명령 주소를 MBR의 주소로 전송<br> 복귀주소를 저장할 0번지를 PC에 전송</td></tr><tr><td style="text-align:center">C3t1</td><td style="text-align:center">MAR ← PC<br>PC ← PC + 1</td><td style="text-align:center">PC가 가진 0값 번지를 MAR에 전송<br>인터럽트 벡터 위치를 지정하기 위해 PC 값을 1로 세팅</td></tr><tr><td style="text-align:center">C3t2</td><td style="text-align:center">M[MAR] ← MBR<br>IEN ← 0</td><td style="text-align:center">MBR에 있는 다음 실행 명령 주소를 0번지에 저장<br>다른 인터럽트가 발생하지 않게 IEN에 0 전송</td></tr><tr><td style="text-align:center">C3t3</td><td style="text-align:center">F ← 0, R ← 0</td><td style="text-align:center">항상 Fetch로</td></tr></tbody></table>
<h1>주요 마이크로 오퍼레이션</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="and-1">AND<a href="#and-1" class="hash-link" aria-label="AND에 대한 직접 링크" title="AND에 대한 직접 링크">​</a></h2>
<ul>
<li>AC와 메모리의 내용을 AND 연산해서 AC에 저장</li>
<li>논리곱 연산</li>
<li>AC ← AC ∧ MBR</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="add">ADD<a href="#add" class="hash-link" aria-label="ADD에 대한 직접 링크" title="ADD에 대한 직접 링크">​</a></h2>
<ul>
<li>AC와 메모리의 내용을 더해서 AC에 저장</li>
<li>AC ← AC +MBR</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="lda">LDA<a href="#lda" class="hash-link" aria-label="LDA에 대한 직접 링크" title="LDA에 대한 직접 링크">​</a></h2>
<ul>
<li>메모리의 내용을 AC로 Load하는 명령</li>
<li>AC에 0을 전송하여 AC를 초기화하는 부분이 있어야함</li>
<li><strong>AC ← 0</strong></li>
<li>AC ← AC + MBR</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="sta">STA<a href="#sta" class="hash-link" aria-label="STA에 대한 직접 링크" title="STA에 대한 직접 링크">​</a></h2>
<ul>
<li>AC의 내용을 메모리에 저장</li>
<li>M[MAR] ← MBR</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="bun">BUN<a href="#bun" class="hash-link" aria-label="BUN에 대한 직접 링크" title="BUN에 대한 직접 링크">​</a></h2>
<ul>
<li>실행 명령의 위치를 변경하는 무조건 분기</li>
<li>Branch UNconditionally</li>
<li>PC ← MBR[AD]</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="bsa">BSA<a href="#bsa" class="hash-link" aria-label="BSA에 대한 직접 링크" title="BSA에 대한 직접 링크">​</a></h2>
<ul>
<li>복귀주소를 저장하고 부 프로그램을 호출하는 명령</li>
<li>Branch and Save Return Address</li>
</ul>
<table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C2t0</td><td style="text-align:center">MAR ← MBR[AD]<br>MBR[AD] ← PC<br>PC ← MBR[AD]</td><td style="text-align:center">복귀주소를 MAR에 전송<br>PC의 값을 MBR의 주소로 전송<br>부프로그램 호출직전 MBR의 주소를 PC로 전송</td></tr><tr><td style="text-align:center">C2t1</td><td style="text-align:center">M[MAR] ← MBR[AD]</td><td style="text-align:center">부프로그램 호출직전 복귀주소 저장</td></tr><tr><td style="text-align:center">C2t2</td><td style="text-align:center">PC ← PC + 1</td><td style="text-align:center">부 프로그램 시작</td></tr><tr><td style="text-align:center">C2t3</td><td style="text-align:center">F ← 0 OR R ← 1</td><td style="text-align:center">Fetch 또는 Interrupt</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="isz">ISZ<a href="#isz" class="hash-link" aria-label="ISZ에 대한 직접 링크" title="ISZ에 대한 직접 링크">​</a></h2>
<ul>
<li>메모리의 값을 읽고 값을 1 증가 시킨 후 그 값이 0이면 현재 명령을 건너 뛰고 다음으로 이동</li>
<li>IF(MBR=0) THEN ← PC + 1</li>
</ul>
<h1>제어기</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="제어데이터">제어데이터<a href="#제어데이터" class="hash-link" aria-label="제어데이터에 대한 직접 링크" title="제어데이터에 대한 직접 링크">​</a></h2>
<ul>
<li>제어장치가 제어신호를 발생하기 위한 자료</li>
<li>CPU가 특정한 메이저 상태와 타이밍 상태에 있을 때 제어 자료에 따른 제어 규칙에 의해 발생한다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="종류-1">종류<a href="#종류-1" class="hash-link" aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크">​</a></h3>
<ul>
<li>메이저 스테이트 사이의 변천을 제어하는 데이터</li>
<li>중앙처리장치의 제어점을 제어하는 데 이터</li>
<li>인스트럭션의 수행 순서를 결정하는데 필요한 제어데이터</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="단계">단계<a href="#단계" class="hash-link" aria-label="단계에 대한 직접 링크" title="단계에 대한 직접 링크">​</a></h3>
<table><thead><tr><th style="text-align:center">구분</th><th style="text-align:center">State간 변이</th><th style="text-align:center">제어점 제어</th><th style="text-align:center">수행 순서제어</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Fetch</strong></td><td style="text-align:center">명령어의 주소지정방식</td><td style="text-align:center">명령어</td><td style="text-align:center">PC</td></tr><tr><td style="text-align:center"><strong>Indirect</strong></td><td style="text-align:center">주소지정방식</td><td style="text-align:center">유효주소</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center"><strong>Execute</strong></td><td style="text-align:center">인터럽트 요청</td><td style="text-align:center">명령어 연산자</td><td style="text-align:center">PC</td></tr><tr><td style="text-align:center"><strong>Interrupt</strong></td><td style="text-align:center">-</td><td style="text-align:center">Interrupt따라 다름</td><td style="text-align:center">Interrupt따라 다름</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="구현">구현<a href="#구현" class="hash-link" aria-label="구현에 대한 직접 링크" title="구현에 대한 직접 링크">​</a></h2>
<ul>
<li>하드웨어적 고정배선제어장치</li>
<li>소프트웨어적 마이크로 프로그래밍 기법</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="고정배선-제어장치">고정배선 제어장치<a href="#고정배선-제어장치" class="hash-link" aria-label="고정배선 제어장치에 대한 직접 링크" title="고정배선 제어장치에 대한 직접 링크">​</a></h3>
<ul>
<li>독립 제어점에  제어신호를 가해야 할 조건들을 제어 데이터와 제어기의 상태로 표현한 후 이를 만족하는 조합논리회로를 설계하여 해당 제어점에 연결하는 방식</li>
<li>하드웨어적 구성방법</li>
<li>속도 빠름</li>
<li>비싸다.</li>
<li>RISC구조를 기본으로 하는 컴퓨터에서 주로 사용</li>
<li>한 번 만들어진 명령어 세트를 변경할 수 없음</li>
<li>회로 구성이 복잡</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="마이크로-프로그래밍">마이크로 프로그래밍<a href="#마이크로-프로그래밍" class="hash-link" aria-label="마이크로 프로그래밍에 대한 직접 링크" title="마이크로 프로그래밍에 대한 직접 링크">​</a></h3>
<ul>
<li>내부 제어 신호를 지정하는 여러가지 마이크로 인스트럭션으로 작성하는 것</li>
<li>소프트웨어적 구성방법</li>
<li>펌웨어를 이용하는 방식</li>
<li>마이크로 프로그램된 제어장치를 사용하는 컴퓨터는 주 메모리 외에 마이크로 프로그램이 저장되는 제어메모리(ROM)이 필요하다.</li>
<li>명령어 세트를 쉽게 변경할 수 있다.</li>
<li>다양한 어드레스 모드를 갖음</li>
<li>속도 느림</li>
<li>유지보수 및 수정 용이</li>
<li>복잡한 명령 세트를 가진 시스템에 적합</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="제어-메모리-번지-결정">제어 메모리 번지 결정<a href="#제어-메모리-번지-결정" class="hash-link" aria-label="제어 메모리 번지 결정에 대한 직접 링크" title="제어 메모리 번지 결정에 대한 직접 링크">​</a></h2>
<ul>
<li>제어 주소 레지스터(CAR) : 값을 1 증가<!-- -->
<ul>
<li>매핑의 결과값</li>
<li>주소 필드</li>
<li>서브루틴 레지스터 데이터</li>
</ul>
</li>
<li>명령 레지스터(IR) : 지정하는 번지로 무조건 분기, 주소 필드로부터 제어 메모리의 주소로 매핑</li>
<li>상태 레지스터(SR) : 조건에 따른 분기</li>
<li>서브루틴의 호출(call)과 복귀(return)</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="형식">형식<a href="#형식" class="hash-link" aria-label="형식에 대한 직접 링크" title="형식에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="수평-마이크로-명령">수평 마이크로 명령<a href="#수평-마이크로-명령" class="hash-link" aria-label="수평 마이크로 명령에 대한 직접 링크" title="수평 마이크로 명령에 대한 직접 링크">​</a></h3>
<ul>
<li>Horizontal Micro Instruction</li>
<li>한 비트가 한 개의 마이크로 동작을 관할하는 명령</li>
<li>마이크로 오퍼레이션 부가 nBit일 때 n개의 마이크로 동작 표현 가능</li>
<li>제어 비트를 디코딩 할 필요가 없다.</li>
<li>마이크로 명령 한 개로 여러 개의 하드웨어를 동시에 동작시킬 수 있다.</li>
<li>제어 워드의 길이가 길어진다.</li>
<li>비트가 충분히 활용되지 못함.</li>
<li>비용이 많이 든다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="수직-마이크로-명령">수직 마이크로 명령<a href="#수직-마이크로-명령" class="hash-link" aria-label="수직 마이크로 명령에 대한 직접 링크" title="수직 마이크로 명령에 대한 직접 링크">​</a></h3>
<ul>
<li>Vertical Micro Instruction</li>
<li>제어 메모리 외부에서 디코딩 회로를 필요로 하는 마이크로 명령</li>
<li>디코더의 출력을 제어신호로 사용</li>
<li>한 개의 마이크로 동작만 제어 가능</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="나노-명령">나노 명령<a href="#나노-명령" class="hash-link" aria-label="나노 명령에 대한 직접 링크" title="나노 명령에 대한 직접 링크">​</a></h3>
<ul>
<li>Nano Instruction</li>
<li>나노메모리(낮은 레벨의 메모리)에 저장된 마이크로 명령</li>
<li>수직 마이크로 명령을 수행하는 제어기에서 디코더를 ROM(나노메모리)로 바꿔 두 메모리 레벨로 구성</li>
<li>제어 메모리의 각 워드는 나노 메모리의 번지를 저장</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="제어장치-구현방식">제어장치 구현방식<a href="#제어장치-구현방식" class="hash-link" aria-label="제어장치 구현방식에 대한 직접 링크" title="제어장치 구현방식에 대한 직접 링크">​</a></h2>
<ul>
<li>상태 플리플롭 제어</li>
<li>PLA (Programmable Logic Array)</li>
<li>마이크로 프로그램 제어</li>
</ul>
<h1>입출력장치</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="입출력-제어장치">입출력 제어장치<a href="#입출력-제어장치" class="hash-link" aria-label="입출력 제어장치에 대한 직접 링크" title="입출력 제어장치에 대한 직접 링크">​</a></h2>
<ul>
<li>입출력장치와 컴퓨터 사이의 자료 전송을 제어하는 장치</li>
<li>데이터 버퍼 레지스터를 이용하여 두 장치간의 속도 차를 조절 = 데이터 버퍼링</li>
<li>제어 신호의 논리적, 물리적 변환 및 오류를 제어</li>
<li>DMA, 채널, 입출력 프로세서, 입출력 컴퓨터가 포함된다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="입출력-인터페이스">입출력 인터페이스<a href="#입출력-인터페이스" class="hash-link" aria-label="입출력 인터페이스에 대한 직접 링크" title="입출력 인터페이스에 대한 직접 링크">​</a></h2>
<ul>
<li>동작방식이나 데이터 형식이 다른 컴퓨터 내부의 장치끼리 2진 데이터를 원활하게 전송하기 위함</li>
<li>CPU와 주변장치의 전송속도, 동작방식, 워드형식의 차이 제어</li>
<li>동작방식이 다른 주변장치끼리의 차이 제어</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="입출력-버스">입출력 버스<a href="#입출력-버스" class="hash-link" aria-label="입출력 버스  에 대한 직접 링크" title="입출력 버스에 대한 직접 링크">​</a></h2>
<ul>
<li>주기억장치와 입출력장치 사이의 데이터 전송을 위해 <strong>모든 주변장치의 인터페이스에 공통으로 연결된 버스</strong></li>
<li>구성<!-- -->
<ul>
<li>데이터 버스</li>
<li>주소 버스</li>
<li>제어 버스</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="기억장치와-입출력장치의-차이">기억장치와 입출력장치의 차이<a href="#기억장치와-입출력장치의-차이" class="hash-link" aria-label="기억장치와 입출력장치의 차이에 대한 직접 링크" title="기억장치와 입출력장치의 차이에 대한 직접 링크">​</a></h2>
<ul>
<li>기억장치 : 전자적, 빠르다, 타율, 오류 적음, Word단위</li>
<li>입출력장치 : 기계적, 느리다, 자타율, 오류 많음, Byte(문자)단위</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="비동기-데이터-전송">비동기 데이터 전송<a href="#비동기-데이터-전송" class="hash-link" aria-label="비동기 데이터 전송에 대한 직접 링크" title="비동기 데이터 전송에 대한 직접 링크">​</a></h2>
<ul>
<li>비동기 데이터 전송을 하기 위해선 데이터 전송시각을 알기 위한 제어신호를 서로 교환하여 송수신 상태를 서로 맞춰야한다.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="스트로브-펄스">스트로브 펄스<a href="#스트로브-펄스" class="hash-link" aria-label="스트로브 펄스에 대한 직접 링크" title="스트로브 펄스에 대한 직접 링크">​</a></h3>
<ul>
<li>Strobe Pulse</li>
<li>데이터 버스와 한 개의 제어선</li>
<li>스트로브 신호 : 두 개의 독립적인 장치 사이의 비동기적인 데이터 전송을 하기 위해 전송 시각을 알리는 제어 신호</li>
<li>메모리와 CPU 사이의 정보를 교환할 때 사용</li>
<li>수신장치가 데이터를 받았는지는 모름</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="핸드쉐이킹">핸드쉐이킹<a href="#핸드쉐이킹" class="hash-link" aria-label="핸드쉐이킹에 대한 직접 링크" title="핸드쉐이킹에 대한 직접 링크">​</a></h3>
<ul>
<li>데이터 전송시 송신측과 수신측에서 입출력의 준비나 완료를 나타내는 신호를 사용하여 서로의 동작을 확인하면서 데이터를 전송</li>
<li>전송을 시작한 장치에 응답하는 제 2의 제어신호를 전송</li>
<li>높은 융통성과 신뢰성</li>
<li>병렬 입출력 데이터 전송방식의 기본으로 많이 사용</li>
<li>2~3개의 제어선 사용</li>
<li>RDY, STB 신호 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="스풀링">스풀링<a href="#스풀링" class="hash-link" aria-label="스풀링에 대한 직접 링크" title="스풀링에 대한 직접 링크">​</a></h2>
<ul>
<li>다중 프로그래밍 환경 아래에서 용량이 크고 신속한 액세스가 가능한 디스크를 이용해 각 사용자 프로그램이 입출력할 데이터를 직접 입출력장치로 보내지 않고 디스크에 모았다가 한꺼번에 입출력 시키는 방법</li>
<li>입출력장치의 공유 및 느린 처리속도를 보완</li>
<li>디스크의 일부를 매우 큰 버퍼로 사용한다.</li>
<li>큐 방식의 입출력을 수행</li>
<li>Simultaneous Peripheral Operation OnLine</li>
<li>보조기억장치에 저장</li>
<li>다중 작업</li>
<li>소프트웨어 구현</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="버퍼링">버퍼링<a href="#버퍼링" class="hash-link" aria-label="버퍼링에 대한 직접 링크" title="버퍼링에 대한 직접 링크">​</a></h2>
<ul>
<li>입출력 장치와 CPU의 속도차를 해결하기 위해 사용</li>
<li>주기억 장치에 저장</li>
<li>단일 작업</li>
<li>하드웨어 구현</li>
</ul>
<h1>입출력 제어방식</h1>
<ul>
<li>입출력 처리 능력 순서 : 프로그램 &lt; 인터럽트 &lt; DMA &lt; 채널</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="programmed-io">Programmed I/O<a href="#programmed-io" class="hash-link" aria-label="Programmed I/O에 대한 직접 링크" title="Programmed I/O에 대한 직접 링크">​</a></h2>
<ul>
<li>폴링</li>
<li>원하는 I/O가 완료되었는지 여부를 검사하기 위해 CPU의 Status Flag를 계속 조사해 I/O가 완료되었으면 MDR(MBR)과 AC사이의 자료 전송도 CPU가 직접 처리하는 방식</li>
<li>입출력의 대부분을 CPU가 해준다.</li>
<li>MDR(MBR), Flag(PSW), 장치번호 디코더로 구성</li>
<li>CPU가 계속 I/O에 관여해야되기 때문에 비효율적</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="interrupt-io">Interrupt I/O<a href="#interrupt-io" class="hash-link" aria-label="Interrupt I/O에 대한 직접 링크" title="Interrupt I/O에 대한 직접 링크">​</a></h2>
<ul>
<li>데이터 전송 준비가 되면 입출력 인터페이스가 컴퓨터에게 알려 I/O가 이루어지는 방식</li>
<li>입출력 인터페이스가 CPU에게 인터럽트 신호를 전송</li>
<li>수행중인 프로그램의 <strong>인스트럭션을 끝내고</strong> I/O 처리후 다시 복귀</li>
<li>대량 자료 전송시 CPU에 부담</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="dma-io">DMA I/O<a href="#dma-io" class="hash-link" aria-label="DMA I/O에 대한 직접 링크" title="DMA I/O에 대한 직접 링크">​</a></h2>
<ul>
<li>Direct Memory Access</li>
<li>입출력장치가 직접 주기억장치를 접근하여 데이터 블록을 입출력하는 방식</li>
<li>I/O가 CPU를 경유하지 않음</li>
<li>CPU는 I/O에 필요한 정보를 DMA 제어기에 전달해 I/O동작만을 개시하고 끝<!-- -->
<ul>
<li>I/O 장치의 주소</li>
<li>데이터 있는 주기억장치의 시작 주소</li>
<li>DMA 시작 명령</li>
<li>I/O 데이터 양</li>
<li>입력 또는 출력을 결정하는 명령</li>
</ul>
</li>
<li>빠른 데이터 전송 가능</li>
<li>DMA는 인터럽트 신호를 발생해 CPU에게 I/O 종료를 알림</li>
<li>블록으로 대용량 데이터 전송 가능</li>
<li>CPU의 <strong>Cycle Steal</strong> 해 메모리를 접근하여 I/O 데이터를 전송<!-- -->
<ul>
<li>데이터 채널과 CPU가 주기억장치를 동시에 접근할 때 우선순위를 전자에게 줌</li>
<li>CPU는 그동안 메모리 참조가 필요없는 오퍼레이션을 계속 진행</li>
<li>CPU의 상태 보존이 필요 없음</li>
</ul>
</li>
<li>CPU와 DMA 제어기는 메모리와 버스를 공유</li>
<li>명령 받고 =&gt; 버스 사용 요구 =&gt; 버스 사용 허가 =&gt; 데이터 전송 =&gt; 인터럽트 전송</li>
<li>한 개의 인스트럭션에 의해 한 개의 블록을 입출력</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="구성">구성<a href="#구성" class="hash-link" aria-label="구성에 대한 직접 링크" title="구성에 대한 직접 링크">​</a></h3>
<ul>
<li>인터페이스 회로</li>
<li>주소 레지스터 및 주소 라인</li>
<li>워드 카운트 레지스터 = 단어 계수기</li>
<li>제어 레지스터</li>
<li>데이터 레지스터</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="channel-io">Channel I/O<a href="#channel-io" class="hash-link" aria-label="Channel I/O에 대한 직접 링크" title="Channel I/O에 대한 직접 링크">​</a></h2>
<ul>
<li>I/O 프로세서</li>
<li>I/O를 위한 특별한 명령어를 I/O 프로세서에게 수행토록 하여 CPU 관여 없이 주기억장치와 입출력장치 사이에서 I/O를 하는 전용 프로세서</li>
<li>DMA의 한계를 극복하기 위해 고안</li>
<li>DMA의 방법으로 입출력을 수행하지만 확장된 개념</li>
<li>채널 제어기는 채널 명령어로 작성된 채널 프로그램을 해독하고 실행하여 I/O 처리</li>
<li>CPU로 I/O 명령어를 받으면 CPU와는 독립적으로 동작</li>
<li>주기억장치에 저장된 채널 프로그램의 수행과 데이터 전송을 위해 주기억장치에 직접 접근</li>
<li>I/O 장치는 제어장치를 통해 채널과 연결</li>
<li>I/O 채널은 CPU의 I/O 명령을 수행하지 않고 I/O 채널 내의 특별한 명령어를 수행</li>
<li>CPU와는 인터럽트로 통신</li>
<li>한 개의 인스트럭션에 의해 여러 개의 블록을 입출력</li>
<li>입출력장치와 주기억장치를 연결하는 중개자</li>
<li>입출력 전담장치</li>
<li>입출력 장치와 CPU사이의 존재하는 현저한 속도차를 극복하기 위한 장치</li>
<li>CPU의 명령을 받고 입출력을 시작하면 CPU와는 독립적으로 조작하는 장치</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="채널-명령어">채널 명령어<a href="#채널-명령어" class="hash-link" aria-label="채널 명령어에 대한 직접 링크" title="채널 명령어에 대한 직접 링크">​</a></h3>
<ul>
<li>명령코드</li>
<li>데이터 주소</li>
<li>플래그</li>
<li>워드 카운터</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="종류-2">종류<a href="#종류-2" class="hash-link" aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크">​</a></h3>
<ul>
<li>Selector Channel<!-- -->
<ul>
<li>선택 채널</li>
<li>고속 입출력장치(자기로 시작하는 친구들)와 입출력하기 위해 사용</li>
<li>특정 한 개의 장치를 독점해서 입출력</li>
</ul>
</li>
<li>MultiPlexer Channel<!-- -->
<ul>
<li>다중채널</li>
<li>저속 입출력장치(카드리터, 프린터)를 제어하는 채널</li>
<li>동시에 여러 개의 입출력장치 제어</li>
</ul>
</li>
<li>Block Multiplexer Channel<!-- -->
<ul>
<li>고속 입출력장치를 제어</li>
<li>동시에 여러 개의 입출력장치 제어</li>
</ul>
</li>
</ul>
<h1>인터럽트</h1>
<ul>
<li>프로그램 실행 도중 예기치 않은 상황이 발생하는 경우 현재 작업을 즉시 중단하고 발생된 상황을 우선 처리 후 실행 중인 작업으로 복귀</li>
<li>내부 인터럽트는 CPU의 하드웨어 신호에 의해 발생</li>
<li>소프트웨어 인터럽트는 명령어의 수행에 의해 발생</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="외부-인터럽트">외부 인터럽트<a href="#외부-인터럽트" class="hash-link" aria-label="외부 인터럽트에 대한 직접 링크" title="외부 인터럽트에 대한 직접 링크">​</a></h2>
<ul>
<li>입출력장치, 타이밍장치, 전원 등 외부 요인에 의해 발생</li>
<li>전원 이상 인터럽트 : 정전이거나 정원이상</li>
<li>기게 착오 인터럽트 : CPU의 기능적인 오류 동작 발생</li>
<li>외부 신호 인터럽트<!-- -->
<ul>
<li>Time Slice 를 알림</li>
<li>인터럽트 키를 누른 경우 (Ctrl + Alt + Del)</li>
<li>외부 장치로부터 인터럽트 요청이 있는 경우</li>
</ul>
</li>
<li>입출력 인터럽트<!-- -->
<ul>
<li>입출력 데이터의 오류나 이상현상 발생</li>
<li>입출력장치가 데이터 전송을 요구하거나 전송이 끝났을 때</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="내부-인터럽트">내부 인터럽트<a href="#내부-인터럽트" class="hash-link" aria-label="내부 인터럽트에 대한 직접 링크" title="내부 인터럽트에 대한 직접 링크">​</a></h2>
<ul>
<li>잘못된 명령이나 데이터를 사용할 때 발생</li>
<li><strong>트랩</strong></li>
<li>프로그램 검사 인터럽트<!-- -->
<ul>
<li>0으로 나누기</li>
<li>오버플로 또는 언더플로</li>
<li>프로그램에서 명령어 잘못 사용</li>
<li>부당한 기억장소의 참조</li>
<li>프로그램상 오류</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="소프트웨어-인터럽트">소프트웨어 인터럽트<a href="#소프트웨어-인터럽트" class="hash-link" aria-label="소프트웨어 인터럽트에 대한 직접 링크" title="소프트웨어 인터럽트에 대한 직접 링크">​</a></h2>
<ul>
<li>프로그램 처리중 <strong>명령의 요청에 의해 발 생</strong></li>
<li><strong>SVC 인터럽트</strong>
<ul>
<li>제어 프로그램 호출 인터럽트 = SuperVisor Call</li>
<li>사용자가 SVC 명령을 써서 의도적으로 호출한 경우</li>
<li>복잡한 입출력 처리를 해야하는 경우</li>
<li>기억장치 할당 및 오퍼레이터와 대화를 해야하는 경우</li>
</ul>
</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="인터럽트시-cpu확인-요소">인터럽트시 CPU확인 요소<a href="#인터럽트시-cpu확인-요소" class="hash-link" aria-label="인터럽트시 CPU확인 요소에 대한 직접 링크" title="인터럽트시 CPU확인 요소에 대한 직접 링크">​</a></h2>
<ul>
<li>프로그램 카운터 내용</li>
<li>사용한 모든 레지스터의 내용</li>
<li>상태 조건의 내용 = PSW = Status Register</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="동작-원리">동작 원리<a href="#동작-원리" class="hash-link" aria-label="동작 원리에 대한 직접 링크" title="동작 원리에 대한 직접 링크">​</a></h2>
<ol>
<li>인터럽트 요청 신호 발생</li>
<li>현재 인스트럭션까지 실행 후 프로그램 실행 중단</li>
<li>현재 프로그램 상태 보존</li>
<li>인터럽트 처리 루틴 실행</li>
<li>인터럽트 서비스(취급) 루틴 실행</li>
</ol>
<ul>
<li>처리기 상태 복구</li>
<li>인터럽트 원인 결정</li>
<li>처리기 레지스터의 상태 보존</li>
<li>상대적으로 낮은 레벨의 마스크 레지스터 클리어</li>
</ul>
<ol start="6">
<li>상태 복구</li>
<li>중단된 프로그램 실행 재개</li>
</ol>
<h1>인터럽트 우선순위</h1>
<ol>
<li>전원 이상 = Power Fail</li>
<li>기계 착오 = Machine Check</li>
<li>외부 신호 = External</li>
<li>입출력 = I/O</li>
<li>명령어 잘못</li>
<li>프로그램 = Program Check</li>
<li>SVC = Supervisor Call</li>
</ol>
<ul>
<li>Non Maskable Interrupt : 마스크 불가능 인터럽트로 0순위</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="폴링">폴링<a href="#폴링" class="hash-link" aria-label="폴링에 대한 직접 링크" title="폴링에 대한 직접 링크">​</a></h2>
<ul>
<li>소프트웨어적 인터럽트 우선순위 판별 방식</li>
<li>우선순위가 높은 인터럽트 자원의 인터럽트 요청 플래그를 검사해 해당하는 인터럽트 서비스 루틴을 수행</li>
<li>우선순위 변경이 쉽다.</li>
<li>자기디스크와 같이 속도가 빠른 장치에 높은 등급 부여</li>
<li>회로가 간단하고 융통성이 있음</li>
<li>별도의 하드웨어가 필요 없어 경제적</li>
<li>많은 인터럽트가 있을 때 모두 조사해야하므로 반응시간이 느림</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="벡터-인터럽트">벡터 인터럽트<a href="#벡터-인터럽트" class="hash-link" aria-label="벡터 인터럽트에 대한 직접 링크" title="벡터 인터럽트에 대한 직접 링크">​</a></h2>
<ul>
<li>하드웨어적인 인터럽트 판별 방식</li>
<li>CPU와 인터럽트를 요청할 수 있는 장치 사이에 장치 번호에 해당하는 버스를 연결하여 요청 장치의 번호를 CPU에게 알리는 방식</li>
<li>인터럽트를 발생한 장치가 프로세서에게 분기할 곳에 대한 정보를 제공</li>
<li>인터럽트 벡터 : 인터럽트 처리 루틴으로 분기하는 명령어만을 기억하는 기억장치의 특정 영역으로 분기번지가 저장됨</li>
<li>별도의 프로그램 루틴이 없어 응답속도가 빠름</li>
<li>회로가 복잡하고 융통성이 없음</li>
<li>추가 하드웨어가 필요하므로 비경제적</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="직렬-우선순위">직렬 우선순위<a href="#직렬-우선순위" class="hash-link" aria-label="직렬 우선순위에 대한 직접 링크" title="직렬 우선순위에 대한 직접 링크">​</a></h3>
<ul>
<li><strong>데이지 체인 방식</strong></li>
<li>모든 장치를 한 개의 회선에 <strong>직 렬</strong>로 연결</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="병렬-우선순위">병렬 우선순위<a href="#병렬-우선순위" class="hash-link" aria-label="병렬 우선순위에 대한 직접 링크" title="병렬 우선순위에 대한 직접 링크">​</a></h3>
<ul>
<li>인터럽트가 발생하는 각 장치를 개별적인 회선으로 연결</li>
<li>각 비트를 개별적으로 세트할 수 있는 <strong>Mask Register</strong> 사용</li>
<li>마스크 레지스터는 인터럽트 요청의 허락이 가능하다.</li>
<li>우선순위는 마스크 레지스터의 비트 위치에 의해서 결정</li>
<li>우선순위가 높은 것이 서비스 받고 있을 때 우선순위가 낮은 것을 비활성화시킬 수 있다.</li>
<li>높은 우선순위의 인터럽트는 낮은 인터럽트가 처리되는 중에도 우선 처리된다.</li>
</ul>
<h1>기억장치</h1>
<ul>
<li>주기억장치 : 시스템 프로그램영역과 사용자 프로그램영역으로 구성<!-- -->
<ul>
<li>반도체 : RAM, ROM</li>
<li>자기 : 자기 코어</li>
</ul>
</li>
<li>보조기억장치<!-- -->
<ul>
<li>DASD : 자기 디스크, 자기 드럼, 하드 디스크, 광디스크</li>
<li>SASD : 자기테이프</li>
</ul>
</li>
<li>특수기억장치 : 복수 모듈 기억장치, 연관기억장치, 캐시기억장치, 가상기억장치</li>
<li>광디스크의 종류 : 블루레이, DVD, Compact</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="계층구조">계층구조<a href="#계층구조" class="hash-link" aria-label="계층구조에 대한 직접 링크" title="계층구조에 대한 직접 링크">​</a></h2>
<ul>
<li>특수기억장치 : 레지스터, 캐시, 연관</li>
<li>주기억장치 : RAM, ROM, 자기코어</li>
<li>보조기억장치 : 자기디스크, 자기테이프</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="특성-결정-요소">특성 결정 요소<a href="#특성-결정-요소" class="hash-link" aria-label="특성 결정 요소에 대  한 직접 링크" title="특성 결정 요소에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="기억-용량">기억 용량<a href="#기억-용량" class="hash-link" aria-label="기억 용량에 대한 직접 링크" title="기억 용량에 대한 직접 링크">​</a></h3>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="access-time">Access Time<a href="#access-time" class="hash-link" aria-label="Access Time에 대한 직접 링크" title="Access Time에 대한 직접 링크">​</a></h3>
<ul>
<li>기억장치에 읽기 요청이 발생한 시간부터 요구한 정보를 꺼내서 사용 가능할 때까지의 시간</li>
<li>한 Word의 단위 정보를 읽거나 기록하는데 걸리는 시간</li>
<li>Access Time = Seek Time + Latency Time(Search Time) + Transmission Time</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="cycle-time">Cycle Time<a href="#cycle-time" class="hash-link" aria-label="Cycle Time에 대한 직접 링크" title="Cycle Time에 대한 직접 링크">​</a></h3>
<ul>
<li>기억장치에 읽기 신호를 보낸 후 다시 읽기 신호를 보낼 수 있을 때까지의 시간 간격</li>
<li>Cycle Time ≥ Access Time</li>
<li>DRAM : Cycle Time = Access Time + Refresh Time</li>
<li>자기코어 : Cycle Time = Access Time + Restoration Time</li>
<li><strong>기타 모든 장치</strong> : Cycle Time = Access Time</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="bandwitdh">Bandwitdh<a href="#bandwitdh" class="hash-link" aria-label="Bandwitdh에 대한 직접 링크" title="Bandwitdh에 대한 직접 링크">​</a></h3>
<ul>
<li>대역폭 = 전송률 = 밴드폭</li>
<li>메모리에서 또는 메모리까지 1초동안 전송되는 최대한의 정보량</li>
<li>기억장치의 자료 처리 속도를 나타내는 단위</li>
<li>하드웨어 특성상 주기억장치가 제공할 수 있는 정보 전달능력의 한계를 의미</li>
<li>메모리 워드의 길이가 작을수록 대역폭이 좋음</li>
<li>전송  단위 : bps = Baud = 보</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="구분">구분<a href="#구분" class="hash-link" aria-label="구분에 대한 직접 링크" title="구분에 대한 직접 링크">​</a></h2>
<table><thead><tr><th style="text-align:center">구분방식</th><th>내용</th></tr></thead><tbody><tr><td style="text-align:center">내용보존여부</td><td>파괴성 메모리 : 읽으면 내용이 파괴되므로 재저장시간이 필요<br> 비파괴성 메모리</td></tr><tr><td style="text-align:center">전원차단시<br>내용소멸여부</td><td>휘발성메모리 : RAM<br> 비휘발성 메모리 : ROM, 자기코어, 보조기억장치</td></tr><tr><td style="text-align:center">재충전 여부</td><td>정적메모리(SRAM) : 전원이 공급되면 내용이 계속 유지<br> 전원이 공급되도 일정시간 후 내용 지워져 재충전필요</td></tr><tr><td style="text-align:center">접근 방식</td><td>순차접근 : 자기테이프<br> 직접접근 : 자기테이프 제외 모든장치</td></tr></tbody></table>
<h1>주기억장치</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="rom">ROM<a href="#rom" class="hash-link" aria-label="ROM에 대한 직접 링크" title="ROM에 대한 직접 링크">​</a></h2>
<ul>
<li>Read Only Memory</li>
<li>읽기전용</li>
<li>비휘발성 메모리</li>
<li>BIOS, 자가진단프로그램 등 변경 가능성이 거의 없는 시스템 소프트웨어 탑재</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="종류-3">종류<a href="#종류-3" class="hash-link" aria-label="종류에 대한 직접 링크" title="종류에 대한 직접 링크">​</a></h3>
<ul>
<li>Mask ROM : 제조 공장에서 프로그램되어 나옴, 내용 변경 불가</li>
<li>PROM : Programmable ROM, 한 번만 쓰기 가능</li>
<li>EPROM : Erasable PROM, 자외선을 사용해 내용을 지울 수 있음</li>
<li>EAROM : Erasable Alterable ROM, 전기적 특성을 이용하여 기록된 정보 일부를 바꿀 수 있는 ROM</li>
<li>EEPROM : Electonic EPROM, 전기를 이용해 내용 수정 가능</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="ram">RAM<a href="#ram" class="hash-link" aria-label="RAM에 대한 직접 링크" title="RAM에 대한 직접 링크">​</a></h2>
<ul>
<li>Random Access Memory, Read Write Memory</li>
<li>현재 사용중인 프로그램이나 데이터가 저장</li>
<li>휘발성 메모리 = Volatile Memory</li>
<li>정보가 저장된 위치는 주소로 구분</li>
</ul>
<table><thead><tr><th style="text-align:center">구분</th><th style="text-align:center">동적 램</th><th style="text-align:center">정적 램</th></tr></thead><tbody><tr><td style="text-align:center">구성</td><td style="text-align:center">콘덴서</td><td style="text-align:center">플리플롭</td></tr><tr><td style="text-align:center">특징</td><td style="text-align:center">방전되므로주기적인 재충전</td><td style="text-align:center">전원 공급시에 계속 유지</td></tr><tr><td style="text-align:center">소모전력</td><td style="text-align:center">적음</td><td style="text-align:center">많음</td></tr><tr><td style="text-align:center">속도</td><td style="text-align:center">느림</td><td style="text-align:center">빠름</td></tr><tr><td style="text-align:center">집적도</td><td style="text-align:center">높음</td><td style="text-align:center">낮음</td></tr><tr><td style="text-align:center">가격</td><td style="text-align:center">저가</td><td style="text-align:center">고가</td></tr><tr><td style="text-align:center">용도</td><td style="text-align:center">일반적</td><td style="text-align:center">캐시메모리</td></tr></tbody></table>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="자기-코어">자기 코어<a href="#자기-코어" class="hash-link" aria-label="자기 코어에 대한 직접 링크" title="자기 코어에 대한 직접 링크">​</a></h2>
<ul>
<li>전류 일치 기술에 의하여 기억장소를 선별</li>
<li>데이터를 읽으면 내용이 지워지 는 <strong>파괴 메모리</strong></li>
<li>Dectructive Read Out Memory</li>
<li>내용을 읽은 후 지워진 내용을 기록하기 위한 재저장 시간 필요</li>
<li>현재 거의 사용되지 않음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="구성-1">구성<a href="#구성-1" class="hash-link" aria-label="구성에 대한 직접 링크" title="구성에 대한 직접 링크">​</a></h3>
<ul>
<li>구동선 : X,Y축 번지 선택선 2개</li>
<li>센스선 : 자기 코어의 상태를 검출하는 선 1개</li>
<li>금지선 : 불필요하게 자화되었을 때 금지 전류를 흘려 자화를 소진시키는 선 1개</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="반도체-기억소자-구성">반도체 기억소자 구성<a href="#반도체-기억소자-구성" class="hash-link" aria-label="반도체 기억소자 구성에 대한 직접 링크" title="반도체 기억소자 구성에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="ram-1">RAM<a href="#ram-1" class="hash-link" aria-label="RAM에 대한 직접 링크" title="RAM에 대한 직접 링크">​</a></h3>
<ul>
<li>CS1, CS2 : 칩 선택선</li>
<li>RD : 입력 신호선</li>
<li>WR : 출력 신호선</li>
<li><strong>AD</strong> : 주소선<!-- -->
<ul>
<li>MAR과 PC의 수와 같음</li>
<li>주소선이 n개이면 2^n개의 워드 지정 가능</li>
</ul>
</li>
<li>Data Bus : 워드의 크기<!-- -->
<ul>
<li>MBR = IR = 단어의 크기</li>
<li>버스가 10Bit이면 워드의 크기가 10Bit</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="rom-1">ROM<a href="#rom-1" class="hash-link" aria-label="ROM에 대한 직접 링크" title="ROM에 대한 직접 링크">​</a></h3>
<ul>
<li>CS1, CS2 : 칩 선택선</li>
<li><strong>AD</strong> : 주소선</li>
<li>Data Bus : 워드의 크기</li>
</ul>
<h1>보조기억장치</h1>
<ul>
<li>주기억 장치의 단점 보완</li>
<li>속도는 느리지만 전원이 차단되도 내용 유지</li>
<li>  저장용량이 큼</li>
<li>CPU와 직접 자료교환이 불가능</li>
<li>주기억장치에 데이터를 저장할 때 DMA를 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="자기-테이프">자기 테이프<a href="#자기-테이프" class="hash-link" aria-label="자기 테이프에 대한 직접 링크" title="자기 테이프에 대한 직접 링크">​</a></h2>
<ul>
<li>순차처리 = SASD</li>
<li>블록단위로 데이터를 전송</li>
<li>블록 사이에는 데이터를 기록할 수 없는 공간인 <strong>갭</strong>이 있다.</li>
<li>BOT : Beginning Of Tape</li>
<li>EOT : End Of Tape</li>
<li>BPI : Byte Per Inch, 1인치에 기억할 수 있는 바이트 수</li>
<li>IRG : Inter Record Gap, 레코드와 레코드 사이의 갭</li>
<li>IBG : Inter Block Gap, 블록과 블록 사이의 갭</li>
<li>Block : 한 개 이상의 논리 레코드의 집합 = 물리 레코드</li>
<li>블로킹 : 한 개 이상의 논리적 레코드를 묶어서 테이프에 기록하는 방식<!-- -->
<ul>
<li>IRG가 줄어든다.</li>
<li>기억공간 낭비 감소</li>
<li>Access Time 감소</li>
<li>입출력 횟수 감소</li>
</ul>
</li>
<li>Blocking Factor : 하나의 블록을 구성하는 논리 레코드의 갯수</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="자기-디스크">자기 디스크<a href="#자기-디스크" class="hash-link" aria-label="자기 디스크에 대한 직접 링크" title="자기 디스크에 대한 직접 링크">​</a></h2>
<ul>
<li>DASD</li>
<li>회전축에 여러장의 디스크를 연결하고, 디스크 상하면마다 R/W Head를 액세스암에 연결하여 구성</li>
<li>가장 윗면과 가장 아랫면은 사용하지 않는다.</li>
<li>트랙 : 디스크 표면에서 회전푹을 중심으로 데이터가 기록되는 동심원</li>
<li>섹터 : 트랙들을 일정한 크기로 구분한 부분이며 정보 기록의 기본 단위</li>
<li>실린더 : 서로 다른 면들에 있는 동일 위치의 트랙들의 모임</li>
<li>Random Access와 Sequential Access 방식을 모두 사용</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="디스크의-3요소">디스크의 3요소<a href="#디스크의-3요소" class="hash-link" aria-label="디스크의 3요소에 대한 직접 링크" title="디스크의 3요소에 대한 직접 링크">​</a></h3>
<ul>
<li>디스크</li>
<li>액세스암</li>
<li>헤드</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="access-time-1">Access Time<a href="#access-time-1" class="hash-link" aria-label="Access Time에 대한 직접 링크" title="Access Time에 대한 직접 링크">​</a></h3>
<ul>
<li>Access Time = Seek Time + Latency Time + Transmission Time</li>
<li>Seek Time : 탐색시간으로 R/W Head가 특정 트랙까지 이동하는데 걸리는 시간</li>
<li>Latency Time : R/W Head가 특정 트랙까지 이동한 후 디스크가 회전하여 트랙에 포함되어 있는 특정 섹터가 R/W Head까지 도달하는데 걸리는 시간<!-- -->
<ul>
<li>Search Time = Rotational Delay Time</li>
</ul>
</li>
<li>Transmission Time : 전송시간으로 R/W Head가 액세스한 섹터와 주기억장치 간의 자료전송에 걸리는 시간</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="자기-드럼">자기 드럼<a href="#자기-드럼" class="hash-link" aria-label="자기 드럼에 대한 직접 링크" title="자기 드럼에 대한 직접 링크">​</a></h2>
<ul>
<li>각 트랙마다 고정된 R/W Head를 두고 있다.</li>
<li>DASD</li>
<li>Access Time = Latency Time + Transmission Time</li>
</ul>
<h1>연관기억장치</h1>
<ul>
<li>기억장치에서 기억된 내용의 일부를 이용하여 액세스하는 자료를 찾는 기억장치</li>
<li>CAM = Content Addressable Memory = 연상기억장치</li>
<li>정보 검색 빠름</li>
<li>캐시 메모리나 가상 메모리 관리기법에서 사용하는 <strong>매핑 테이블에 사용</strong></li>
<li>외부 인자와 내용을 비교하기 위한 병렬 판독 논리회로를 가지고 있음</li>
<li>하드웨어 비용 증가</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="구조">구조<a href="#구조" class="hash-link" aria-label="구조에 대한 직접 링크" title="구조에 대한 직접 링크">​</a></h2>
<ul>
<li>데이터 레지스터 : 인수 레지스터, 찾고자 하는 내용의 일부를 기억하는 레지스터</li>
<li>키 레지스터 : 마스크 레지스터, 검색에 사용할 비트를 결정하는 레지스터</li>
<li>매치 레지스터 : 일치 지시기, 데이터를 찾은 경우 찾았다고 표시하기 위해 사용</li>
</ul>
<h1>복수모듈기억장치</h1>
<ul>
<li>독자적으로 데이터를 저장할 수 있는 기억장치 모듈을 여러 개 가진 기억장치</li>
<li>주기억장치와 CPU의 속도 차이 문제점을 개선</li>
<li>기억장치의 버스를 시분할하여 사용</li>
<li>각각의 기억장치는 자체 어드레스 레지스터와 버퍼 레지스터를 가지고 독자적으로 데이터를 저장</li>
<li>인터리빙 기법에 의해 기억장치를 구성하는 모듈 수만큼 단어(워드)들에 동시 접근 가능</li>
<li>버스가 많으면 모든 모듈 동시 병렬 접근 가능</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="메모리-인터리빙">메모리 인터리빙<a href="#메모리-인터리빙" class="hash-link" aria-label="메모리 인터리빙에 대한 직접 링크" title="메모리 인터리빙에 대한 직접 링크">​</a></h2>
<ul>
<li>Memory Interleaving = 디스크 인터리빙</li>
<li>여러 개의 독립 모듈로 이루어진 복수 모듈 메모리와 CPU 간의 주소 버스가 한 개로만 구성되어 있으면 같은 시각에 CPU로부터 여러 모듈로 동시에 주소를 전달할 수 없다.</li>
<li>CPU가 각 모듈로 전송할 주소를 교대로 배치한 후 차례대로 전송하여 여러 모듈을 병행 접근하는 기법</li>
<li>중앙처리장치와 기억장치 사이의 실질적인 대역폭 효율을 높일 수 있다.</li>
<li>캐시 기억장치, 고속 DMA에서 사용</li>
<li>CPU 유휴시간 감소</li>
</ul>
<h1>캐시 메모리</h1>
<ul>
<li>CPU와 주기억장치의 속도차를 줄이기 위해 사용</li>
<li>고속 Buffer Memory</li>
<li>자주 사용하는 프로그램과 데이터를 기억</li>
<li>메모리 계층에서 가장 빠른 소자</li>
<li>캐시 주소표는 검색 시간을 단축시키기 위해 연관기억장치(CAM)을 사용</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="설계-고려사항">설계 고려사항<a href="#설계-고려사항" class="hash-link" aria-label="설계 고려사항에 대한 직접 링크" title="설계 고려사항에 대한 직접 링크">​</a></h2>
<ul>
<li>캐시 크기</li>
<li>전송 블록 크기</li>
<li>교체 알고리즘</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="매핑-프로세스">매핑 프로세스<a href="#매핑-프로세스" class="hash-link" aria-label="매핑 프로세스에 대한 직접 링크" title="매핑 프로세스에 대한 직접 링크">​</a></h2>
<p>주기억장치로부터 캐시 메모리로 데이터를 전송하는 방법</p>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="직접-매핑">직접 매핑<a href="#직접-매핑" class="hash-link" aria-label="직접 매핑에 대한 직접 링크" title="직접 매핑에 대한 직접 링크">​</a></h3>
<ul>
<li>Direct Mapping</li>
<li>주기억장치의 블록들이 지정된 한 개의 캐시 라인으로만 매핑되는 방법</li>
<li>간단하고 구현 비용이 적다</li>
<li>적중률이 낮다</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="어소시에이티브-매핑">어소시에이티브 매핑<a href="#어소시에이티브-매핑" class="hash-link" aria-label="어소시에이티브 매핑에 대한 직접 링크" title="어소시에이티브 매핑에 대한 직접 링크">​</a></h3>
<ul>
<li>Assciative Mapping = 연관 매핑</li>
<li>직접 매핑의 단점 보완</li>
<li>모든 태그를 병렬로 검사하기 때문에 복잡하고 비용이 높음</li>
<li>거의 사용안함</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="세트-어소시에이티브-매핑">세트-어소시에이티브 매핑<a href="#세트-어소시에이티브-매핑" class="hash-link" aria-label="세트-어소시에이티브 매핑에 대한 직접 링크" title="세트-어소시에이티브 매핑에 대한 직접 링크">​</a></h3>
<ul>
<li>직접 매핑과 연관 매핑의 장점만 취함</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="쓰기-정책">쓰기 정책<a href="#쓰기-정책" class="hash-link" aria-label="쓰기 정책에 대한 직접 링크" title="쓰기 정책에 대한 직접 링크">​</a></h2>
<p>저장되어 있는 데이터 수정이 발생할 때 수정된 내용을 주기억장치에 갱신하기 위해 시기와 방법을 결정하는 것</p>
<ul>
<li>Wirte-Through : 캐시에 쓰기 동작이 이루어질 때마다 캐시 메모리와 주기억장치의 내용을 동시 갱신</li>
<li>Write-Back : 캐시에 쓰기 동작이 이루어지는 동안은 캐시의 내용만이 갱신, 캐시의 내용이 캐시로부터 제거될 때 주기억장치에 복사</li>
<li>Write-Once : 캐시에 쓰기 동작이 이루어질 때 한 번만 기록하고 이후의 기록은 모두 무시</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="적중률">적중률<a href="#적중률" class="hash-link" aria-label="적중률에 대한 직접 링크" title="적중률에 대한 직접 링크">​</a></h2>
<ul>
<li>캐시메모리에 접근하는 경우 원하는 정보가 캐시 메모리에 기억되어 있을 때 적중되었다고 함</li>
<li>캐시 기억장치가 있는 컴퓨터의 성능을 나타네내는 척도</li>
<li>적중률 = 적중횟수 / 총 접근 횟수</li>
<li>미스율 = 1 - 적중률</li>
</ul>
<h1>가상기억장치</h1>
<ul>
<li><strong>기억 용량이 작은 주기억장치를 큰 용량을 가진 것</strong>처럼 사용할 수 있는 기법</li>
<li>보조기억장치를 이  용한 주기억장치의 용량 확보</li>
<li>소프트웨어적 방법으로 구현</li>
<li>프로그램을 여러 블록으로 나눠서 보조기억장치에 보관하고 프로그램 실행시 필요 부분만 주기억장치에 적재</li>
<li><strong>오버레이 문제가 자동적으로 해결</strong></li>
<li>보조기억장치 접근이 빈번하면 시스템 처리 효율이 저하</li>
<li>DASD에만 가능</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="주소">주소<a href="#주소" class="hash-link" aria-label="주소에 대한 직접 링크" title="주소에 대한 직접 링크">​</a></h2>
<ul>
<li>가상주소 : 논리주소로 보조기억장치 상의 주소</li>
<li>실기억주소 : 물리적주소로 주기억장치 상의 주소</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="관리">관리<a href="#관리" class="hash-link" aria-label="관리에 대한 직접 링크" title="관리에 대한 직접 링크">​</a></h2>
<ul>
<li>페이징 기법 : OS가 보조기억장치에 있는 프로그램을 동일한 크기의 블록으로 나눠서 관리</li>
<li>세그먼트 기법 : 사용자가 보조기억장치에 있는 프로그램을 가변적인 크기의 블록으로 나눠서 관리</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="관리전략">관리전략<a href="#관리전략" class="hash-link" aria-label="관리전략에 대한 직접 링크" title="관리전략에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="반입-전략">반입 전략<a href="#반입-전략" class="hash-link" aria-label="반입 전략에 대한 직접 링크" title="반입 전략에 대한 직접 링크">​</a></h3>
<ul>
<li>Fetch</li>
<li>보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인가?</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="배치-전략">배치 전략<a href="#배치-전략" class="hash-link" aria-label="배치 전략에 대한 직접 링크" title="배치 전략에 대한 직접 링크">​</a></h3>
<ul>
<li>Placement</li>
<li>새로 반입되는 포르개림이나 데이터를 주기억장치 어디에 위치시킬 것인가를 결정</li>
<li>최초, 최적, 최악접합이 있음</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="교체-전략">교체 전략<a href="#교체-전략" class="hash-link" aria-label="교체 전략에 대한 직접 링크" title="교체 전략에 대한 직접 링크">​</a></h3>
<ul>
<li>Replacement</li>
<li>주기억장치의 영역이 이미 사용중인 상태에서 새로운 프로그램을 주기억장치에 배치할 때 어떤 방식을 사용할지 결정하는 전략</li>
<li>FIFO, OPT, LRU, NUR, LFU, MFU 등</li>
<li>Page Fault 발생시 교체할 페이지를 결정해서 보조기억장치의 이전 위치에 기억시키고 새 페이지를 교체한 페이지의 위치에 놓는 것을 스테이징이라 한다</li>
<li>스테이징 : 느린 장치에서 바른 장치로 옮겨가는 것</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="주소-매핑">주소 매핑<a href="#주소-매핑" class="hash-link" aria-label="주소 매핑에 대한 직접 링크" title="주소 매핑에 대한 직접 링크">​</a></h2>
<ul>
<li>가상주소를 실 기억주소로 변환하는 작업</li>
<li>가상주소 형식 : 페이지 번호와 변위값</li>
<li>실기억주소 형식 : 페이지 프레임과 변위값</li>
<li>페이지 맵 테이블 : 디스크 페이지 번호와 페이지 프레임 번호, 상태 비트</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="변환-순서">변환 순서<a href="#변환-순서" class="hash-link" aria-label="변환 순서에 대한 직접 링크" title="변환 순서에 대한 직접 링크">​</a></h3>
<ul>
<li>페이지 번호에 해당하는 페이지 프레임 번호와 가상주소의 변위 주소값을 이용해 실 기억주소를 만듦</li>
<li>실기억주소를 이용하여 주기억장치를 액세스</li>
</ul>
<h1>  병렬 컴퓨터</h1>
<ul>
<li>I/O 채널 또는 프로세서와 같은 다수의 프로세서에서 동시에 여러 프로세스를 처리하는 것</li>
<li>일부 하드웨어 오류가 발생해도 전체 시스템은 동작</li>
<li>처리 속도가 빠름</li>
<li>프로그램 작성이 어려움</li>
<li>기억장치 공유</li>
<li>특수한 업무에 적용 : 예보, 인공지능, 역학계산, 모의실험, 유도탄 등</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="flynn의-분류">Flynn의 분류<a href="#flynn의-분류" class="hash-link" aria-label="Flynn의 분류에 대한 직접 링크" title="Flynn의 분류에 대한 직접 링크">​</a></h2>
<p>플린의 분류, 명령 흐름과 자료 흐름을 고려하여 분류</p>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="sisd">SISD<a href="#sisd" class="hash-link" aria-label="SISD에 대한 직접 링크" title="SISD에 대한 직접 링크">​</a></h3>
<ul>
<li>Single Instruction stream Single Data stream</li>
<li>현재 보통 컴퓨터 구조</li>
<li>명령 하나가 자료 하나를 처리</li>
<li>파이프라인에 의한 시간적 병렬 처리 가능</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="simd">SIMD<a href="#simd" class="hash-link" aria-label="SIMD에 대한 직접 링크" title="SIMD에 대한 직접 링크">​</a></h3>
<ul>
<li>Single Instruction stream Multi Data Stream</li>
<li>한 개의 명령으로 여러 데이터를 동시에 처리하는 구조</li>
<li>배열 처리기에 의한 동기적 병렬처리가 가능</li>
<li>다수의 처리기가 한 개의 제어장치에 의해 제어</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="misd">MISD<a href="#misd" class="hash-link" aria-label="MISD에 대한 직접 링크" title="MISD에 대한 직접 링크">​</a></h3>
<ul>
<li>Multi Instruction stream Single Data stream</li>
<li>다수의 처리기에 의해 각각의 명령들이 하나의 데이터를 처리하는 구조</li>
<li><strong>실제로 사용되지 않음</strong></li>
<li>파이프라인에 의한 비동기적 병렬처리 가능</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="mimd">MIMD<a href="#mimd" class="hash-link" aria-label="MIMD에 대한 직접 링크" title="MIMD에 대한 직접 링크">​</a></h3>
<ul>
<li>Multi Instruction stream Multi Data stream</li>
<li>다수의 처리기가 각각 다른 명령 흐름과 자료 흐름을 가지고 여러 개의 자료를 처리하는 구조</li>
<li>각 처리기 사이에에서 상호작용(Interaction)이 일어남</li>
<li>멀티 프로세서에 의한 비동기적 병렬처리 가능</li>
<li>Tightly Coupled System = 다중 처리기</li>
<li>Loosely Coupled System = 분산 처리 시스템</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="feng의-분류">Feng의 분류<a href="#feng의-분류" class="hash-link" aria-label="Feng의 분류에 대한 직접 링크" title="Feng의 분류에 대한 직접 링크">​</a></h2>
<p>팽은 병렬 수행 정도에 따라 분류</p>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="wsbs">WSBS<a href="#wsbs" class="hash-link" aria-label="WSBS에 대한 직접 링크" title="WSBS에 대한 직접 링크">​</a></h3>
<ul>
<li>Word-Serial, Bit-Serial</li>
<li>한 번에 한 비트씩 처리하는 방식 (초기 컴퓨터)</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="wpbs">WPBS<a href="#wpbs" class="hash-link" aria-label="WPBS에 대한 직접 링크" title="WPBS에 대한 직접 링크">​</a></h3>
<ul>
<li>Word-Parallel, Bit-Serial</li>
<li>단어를 묶어서 그 중 한 개의 비트 슬라이스 단위를 순차적으로 처리</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="wsbp">WSBP<a href="#wsbp" class="hash-link" aria-label="WSBP에 대한 직접 링크" title="WSBP에 대한 직접 링크">​</a></h3>
<ul>
<li>Word-Sreial, Bit-Parallel</li>
<li>한 번에 한 단어씩 병렬로 처리</li>
<li>현재의 컴퓨터</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="wpbp">WPBP<a href="#wpbp" class="hash-link" aria-label="WPBP에 대한 직접 링크" title="WPBP에 대한 직접 링크">​</a></h3>
<ul>
<li>Word-Parallel, Bit-Parellel</li>
<li>단어별 병렬, 비트별 병렬 처리</li>
</ul>
<h1>병렬 처리 기법</h1>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="파이프라인-프로세서">파이프라인 프로세서<a href="#파이프라인-프로세서" class="hash-link" aria-label="파이프라인 프로세서에 대한 직접 링크" title="파이프라인 프로세서에 대한 직접 링크">​</a></h2>
<ul>
<li>CPU 처리속도를 높이기 위해 여러개의 인스트럭션을 동시에 병렬처리하는 장치</li>
<li>시간적 병렬처리</li>
<li>명령인출 =&gt; 명령 해독 =&gt; 오퍼랜드 인출 =&gt; 명령 실행</li>
<li>스칼라 프로세서를 이용하는 기법</li>
<li>파이프라인이 차고 나면 연산속도가 빠르다.</li>
<li>같은 연산이 반복되면 효율적이지만 아니면 구조가 복잡하고 시간이 오래 걸린다.</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="벡터-프로세서">벡터 프로세서<a href="#벡터-프로세서" class="hash-link" aria-label="벡터 프로세서에 대한 직접 링크" title="벡터 프로세서에 대한 직접 링크">​</a></h2>
<p>산술 및 논리연산, 비교, 내적연산, 최대, 최소값 구하기 등 벡터 연산 명령을 효율적으로 수행하도록 구성된 처리기</p>
<h3 class="anchor anchorWithStickyNavbar_lHFp" id="시스톨릭-프로세서">시스톨릭 프로세서<a href="#시스톨릭-프로세서" class="hash-link" aria-label="시스톨릭 프로세서에 대한 직접 링크" title="시스톨릭 프로세서에 대한 직접 링크">​</a></h3>
<ul>
<li>데이터 흐름과 제어 흐름이 규칙적인 특징을 갖는 시스톨릭 알고리즘을 이용하여 수행하는 처리기</li>
<li>파이프라인화 된 벡터 프로세서와 배열 프로세서의 특징을 결합한 것</li>
<li>초고밀도 직접회로(VLSI) 기법을 이용  하여 구현</li>
<li>응용의 한계성과 프로그래밍의 어려움이 있음</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="배열-프로세서">배열 프로세서<a href="#배열-프로세서" class="hash-link" aria-label="배열 프로세서에 대한 직접 링크" title="배열 프로세서에 대한 직접 링크">​</a></h2>
<ul>
<li>배열처리기는 PE(Processing Element)라 불리는 다수의 연산기를 갖는 <strong>동기적 병렬 처리기</strong></li>
<li>명령 해독 및 제어는 제어장치가 하고, PE들는 명령 해독 능력이 결여된 수동적 장치로 명령처리만 한다.</li>
<li>PE를 중복 이용해서 공간적 병렬성을 얻는다.</li>
<li>벡터 계산이나 행렬 계산에 적합</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_lHFp" id="데이터-플로우-컴퓨터">데이터 플로우 컴퓨터<a href="#데이터-플로우-컴퓨터" class="hash-link" aria-label="데이터 플로우 컴퓨터에 대한 직접 링크" title="데이터 플로우 컴퓨터에 대한 직접 링크">​</a></h2>
<ul>
<li>데이터 흐름 컴퓨터는 PC(Program Counter)가 필요 없다.</li>
<li>제어 흐름 컴퓨터와는 반대되는 개념</li>
<li>인스트럭션의 필요한 피연산자가 모두 준비되었을 때 인스트럭션을 수행하고 결과를 필요로하는 인스트럭션에 보내주는 방식</li>
</ul></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_kDTu"><div class="col"><b>태그:</b><ul class="tags_EkOm padding--none margin-left--sm"><li class="tag_HzC1"><a class="tag_dB_l tagRegular_GaPB" href="/tags/정보처리/">정보처리</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/2017/02/01/Nginx-for-Windows/"><div class="pagination-nav__sublabel">이전 게시물</div><div class="pagination-nav__label">Nginx for Windows - 1. Setup</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/2017/01/23/database-정리/"><div class="pagination-nav__sublabel">다음 게시물</div><div class="pagination-nav__label">Database 정리</div></a></nav></main><div class="col col--2"><div class="tableOfContents_D45X thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#기본-공식" class="table-of-contents__link toc-highlight">기본 공식</a></li><li><a href="#카르노-맵" class="table-of-contents__link toc-highlight">카르노 맵</a></li><li><a href="#반가산기" class="table-of-contents__link toc-highlight">반가산기</a></li><li><a href="#전가산기" class="table-of-contents__link toc-highlight">전가산기</a></li><li><a href="#병렬가산기" class="table-of-contents__link toc-highlight">병렬가산기</a></li><li><a href="#반감산기" class="table-of-contents__link toc-highlight">반감산기</a></li><li><a href="#디코더" class="table-of-contents__link toc-highlight">디코더</a></li><li><a href="#인코더" class="table-of-contents__link toc-highlight">인코더</a></li><li><a href="#멀티플렉서" class="table-of-contents__link toc-highlight">멀티플렉서</a></li><li><a href="#디멀티플렉서" class="table-of-contents__link toc-highlight">디멀티플렉서</a></li><li><a href="#플리플롭" class="table-of-contents__link toc-highlight">플리플롭</a><ul><li><a href="#특성표" class="table-of-contents__link toc-highlight">특성표</a></li><li><a href="#여기표" class="table-of-contents__link toc-highlight">여기표</a></li><li><a href="#rs-플립플롭" class="table-of-contents__link toc-highlight">RS 플립플롭</a></li><li><a href="#d-플립플롭" class="table-of-contents__link toc-highlight">D 플립플롭</a></li><li><a href="#jk-플립플롭" class="table-of-contents__link toc-highlight">JK 플립플롭</a></li><li><a href="#t-플립플롭" class="table-of-contents__link toc-highlight">T 플립플롭</a></li><li><a href="#ms-플립플롭" class="table-of-contents__link toc-highlight">M/S 플립플롭</a></li></ul></li><li><a href="#비트" class="table-of-contents__link toc-highlight">비트</a></li><li><a href="#니블" class="table-of-contents__link toc-highlight">니블</a></li><li><a href="#바이트" class="table-of-contents__link toc-highlight">바이트</a></li><li><a href="#워드" class="table-of-contents__link toc-highlight">워드</a></li><li><a href="#필드" class="table-of-contents__link toc-highlight">필드</a></li><li><a href="#레코드" class="table-of-contents__link toc-highlight">레코드</a></li><li><a href="#블록" class="table-of-contents__link toc-highlight">블록</a></li><li><a href="#파일" class="table-of-contents__link toc-highlight">파일</a></li><li><a href="#데이터베이스" class="table-of-contents__link toc-highlight">데이터베이스</a></li><li><a href="#2진수" class="table-of-contents__link toc-highlight">2진수</a></li><li><a href="#8진수" class="table-of-contents__link toc-highlight">8진수</a></li><li><a href="#16진수" class="table-of-contents__link toc-highlight">16진수</a></li><li><a href="#뺄셈" class="table-of-contents__link toc-highlight">뺄셈</a></li><li><a href="#2진연산" class="table-of-contents__link toc-highlight">2진연산</a><ul><li><a href="#음수연산" class="table-of-contents__link toc-highlight">음수연산</a></li></ul></li><li><a href="#10진연산" class="table-of-contents__link toc-highlight">10진연산</a><ul><li><a href="#언팩연산" class="table-of-contents__link toc-highlight">언팩연산</a></li><li><a href="#팩연산" class="table-of-contents__link toc-highlight">팩연산</a></li></ul></li><li><a href="#ieee-표준" class="table-of-contents__link toc-highlight">IEEE 표준</a></li><li><a href="#연산" class="table-of-contents__link toc-highlight">연산</a><ul><li><a href="#덧셈-및-뺄셈" class="table-of-contents__link toc-highlight">덧셈 및 뺄셈</a></li><li><a href="#곱셈" class="table-of-contents__link toc-highlight">곱셈</a></li><li><a href="#나눗셈" class="table-of-contents__link toc-highlight">나눗셈</a></li></ul></li><li><a href="#bcd" class="table-of-contents__link toc-highlight">BCD</a></li><li><a href="#ascii" class="table-of-contents__link toc-highlight">ASCII</a></li><li><a href="#ebcdic" class="table-of-contents__link toc-highlight">EBCDIC</a></li><li><a href="#bcd-코드" class="table-of-contents__link toc-highlight">BCD 코드</a></li><li><a href="#excess3-코드" class="table-of-contents__link toc-highlight">Excess3 코드</a></li><li><a href="#gray-코드" class="table-of-contents__link toc-highlight">Gray 코드</a></li><li><a href="#패리티-코드" class="table-of-contents__link toc-highlight">패리티 코드</a><ul><li><a href="#홀수-패리티" class="table-of-contents__link toc-highlight">홀수 패리티</a></li><li><a href="#짝수-패리티" class="table-of-contents__link toc-highlight">짝수 패리티</a></li></ul></li><li><a href="#해밍-코드" class="table-of-contents__link toc-highlight">해밍 코드</a></li><li><a href="#코드-분류" class="table-of-contents__link toc-highlight">코드 분류</a></li><li><a href="#제어장치" class="table-of-contents__link toc-highlight">제어장치</a><ul><li><a href="#구성요소" class="table-of-contents__link toc-highlight">구성요소</a></li></ul></li><li><a href="#연산장치" class="table-of-contents__link toc-highlight">연산장치</a></li><li><a href="#레지스터" class="table-of-contents__link toc-highlight">레지스터</a><ul><li><a href="#자료전송" class="table-of-contents__link toc-highlight">자료전송</a></li><li><a href="#주요-레지스터" class="table-of-contents__link toc-highlight">주요 레지스터</a></li></ul></li><li><a href="#버스" class="table-of-contents__link toc-highlight">버스</a><ul><li><a href="#종류" class="table-of-contents__link toc-highlight">종류</a></li></ul></li><li><a href="#연산자부" class="table-of-contents__link toc-highlight">연산자부</a></li><li><a href="#모드부" class="table-of-contents__link toc-highlight">모드부</a></li><li><a href="#자료부" class="table-of-contents__link toc-highlight">자료부</a></li><li><a href="#설계시-고려사항" class="table-of-contents__link toc-highlight">설계시 고려사항</a></li><li><a href="#기능" class="table-of-contents__link toc-highlight">기능</a><ul><li><a href="#함수-연산-기능" class="table-of-contents__link toc-highlight">함수 연산 기능</a></li><li><a href="#자료-전달-기능" class="table-of-contents__link toc-highlight">자료 전달 기능</a></li><li><a href="#제어-기능" class="table-of-contents__link toc-highlight">제어 기능</a></li><li><a href="#입출력-기능" class="table-of-contents__link toc-highlight">입출력 기능</a></li></ul></li><li><a href="#and" class="table-of-contents__link toc-highlight">AND</a></li><li><a href="#or" class="table-of-contents__link toc-highlight">OR</a></li><li><a href="#xor" class="table-of-contents__link toc-highlight">XOR</a></li><li><a href="#not" class="table-of-contents__link toc-highlight">NOT</a></li><li><a href="#논리-shift" class="table-of-contents__link toc-highlight">논리 Shift</a></li><li><a href="#rotate" class="table-of-contents__link toc-highlight">Rotate</a></li><li><a href="#산술-shift" class="table-of-contents__link toc-highlight">산술 Shift</a><ul><li><a href="#shift-left" class="table-of-contents__link toc-highlight">Shift Left</a></li><li><a href="#shift-right" class="table-of-contents__link toc-highlight">Shift Right</a></li></ul></li><li><a href="#3주소-명령어" class="table-of-contents__link toc-highlight">3주소 명령어</a><ul><li><a href="#장점" class="table-of-contents__link toc-highlight">장점</a></li><li><a href="#단점" class="table-of-contents__link toc-highlight">단점</a></li></ul></li><li><a href="#2주소-명령어" class="table-of-contents__link toc-highlight">2주소 명령어</a><ul><li><a href="#장점-1" class="table-of-contents__link toc-highlight">장점</a></li><li><a href="#단점-1" class="table-of-contents__link toc-highlight">단점</a></li></ul></li><li><a href="#1주소-명령어" class="table-of-contents__link toc-highlight">1주소 명령어</a></li><li><a href="#0주소-명령어" class="table-of-contents__link toc-highlight">0주소 명령어</a></li><li><a href="#고려사항" class="table-of-contents__link toc-highlight">고려사항</a></li><li><a href="#암시적-주소지정방식" class="table-of-contents__link toc-highlight">암시적 주소지정방식</a></li><li><a href="#즉시적-주소지정방식" class="table-of-contents__link toc-highlight">즉시적 주소지정방식</a></li><li><a href="#직접-주소지정방식" class="table-of-contents__link toc-highlight">직접 주소지정방식</a></li><li><a href="#간접-주소지정방식" class="table-of-contents__link toc-highlight">간접 주소지정방식</a></li><li><a href="#계산에-의한-주소지정방식" class="table-of-contents__link toc-highlight">계산에 의한 주소지정방식</a></li><li><a href="#마이크로-사이클-타임" class="table-of-contents__link toc-highlight">마이크로 사이클 타임</a><ul><li><a href="#동기-고정식" class="table-of-contents__link toc-highlight">동기 고정식</a></li><li><a href="#동기-가변식" class="table-of-contents__link toc-highlight">동기 가변식</a></li><li><a href="#비동기식" class="table-of-contents__link toc-highlight">비동기식</a></li></ul></li><li><a href="#fetch-cycle" class="table-of-contents__link toc-highlight">Fetch Cycle</a></li><li><a href="#indirect-cycle" class="table-of-contents__link toc-highlight">Indirect Cycle</a></li><li><a href="#execute-cycle" class="table-of-contents__link toc-highlight">Execute Cycle</a></li><li><a href="#interrupt-cycle" class="table-of-contents__link toc-highlight">Interrupt Cycle</a></li><li><a href="#and-1" class="table-of-contents__link toc-highlight">AND</a></li><li><a href="#add" class="table-of-contents__link toc-highlight">ADD</a></li><li><a href="#lda" class="table-of-contents__link toc-highlight">LDA</a></li><li><a href="#sta" class="table-of-contents__link toc-highlight">STA</a></li><li><a href="#bun" class="table-of-contents__link toc-highlight">BUN</a></li><li><a href="#bsa" class="table-of-contents__link toc-highlight">BSA</a></li><li><a href="#isz" class="table-of-contents__link toc-highlight">ISZ</a></li><li><a href="#제어데이터" class="table-of-contents__link toc-highlight">제어데이터</a><ul><li><a href="#종류-1" class="table-of-contents__link toc-highlight">종류</a></li><li><a href="#단계" class="table-of-contents__link toc-highlight">단계</a></li></ul></li><li><a href="#구현" class="table-of-contents__link toc-highlight">구현</a><ul><li><a href="#고정배선-제어장치" class="table-of-contents__link toc-highlight">고정배선 제어장치</a></li><li><a href="#마이크로-프로그래밍" class="table-of-contents__link toc-highlight">마이크로 프로그래밍</a></li></ul></li><li><a href="#제어-메모리-번지-결정" class="table-of-contents__link toc-highlight">제어 메모리 번지 결정</a></li><li><a href="#형식" class="table-of-contents__link toc-highlight">형식</a><ul><li><a href="#수평-마이크로-명령" class="table-of-contents__link toc-highlight">수평 마이크로 명령</a></li><li><a href="#수직-마이크로-명령" class="table-of-contents__link toc-highlight">수직 마이크로 명령</a></li><li><a href="#나노-명령" class="table-of-contents__link toc-highlight">나노 명령</a></li></ul></li><li><a href="#제어장치-구현방식" class="table-of-contents__link toc-highlight">제어장치 구현방식</a></li><li><a href="#입출력-제어장치" class="table-of-contents__link toc-highlight">입출력 제어장치</a></li><li><a href="#입출력-인터페이스" class="table-of-contents__link toc-highlight">입출력 인터페이스</a></li><li><a href="#입출력-버스" class="table-of-contents__link toc-highlight">입출력 버스</a></li><li><a href="#기억장치와-입출력장치의-차이" class="table-of-contents__link toc-highlight">기억장치와 입출력장치의 차이</a></li><li><a href="#비동기-데이터-전송" class="table-of-contents__link toc-highlight">비동기 데이터 전송</a><ul><li><a href="#스트로브-펄스" class="table-of-contents__link toc-highlight">스트로브 펄스</a></li><li><a href="#핸드쉐이킹" class="table-of-contents__link toc-highlight">핸드쉐이킹</a></li></ul></li><li><a href="#스풀링" class="table-of-contents__link toc-highlight">스풀링</a></li><li><a href="#버퍼링" class="table-of-contents__link toc-highlight">버퍼링</a></li><li><a href="#programmed-io" class="table-of-contents__link toc-highlight">Programmed I/O</a></li><li><a href="#interrupt-io" class="table-of-contents__link toc-highlight">Interrupt I/O</a></li><li><a href="#dma-io" class="table-of-contents__link toc-highlight">DMA I/O</a><ul><li><a href="#구성" class="table-of-contents__link toc-highlight">구성</a></li></ul></li><li><a href="#channel-io" class="table-of-contents__link toc-highlight">Channel I/O</a><ul><li><a href="#채널-명령어" class="table-of-contents__link toc-highlight">채널 명령어</a></li><li><a href="#종류-2" class="table-of-contents__link toc-highlight">종류</a></li></ul></li><li><a href="#외부-인터럽트" class="table-of-contents__link toc-highlight">외부 인터럽트</a></li><li><a href="#내부-인터럽트" class="table-of-contents__link toc-highlight">내부 인터럽트</a></li><li><a href="#소프트웨어-인터럽트" class="table-of-contents__link toc-highlight">소프트웨어 인터럽트</a></li><li><a href="#인터럽트시-cpu확인-요소" class="table-of-contents__link toc-highlight">인터럽트시 CPU확인 요소</a></li><li><a href="#동작-원리" class="table-of-contents__link toc-highlight">동작 원리</a></li><li><a href="#폴링" class="table-of-contents__link toc-highlight">폴링</a></li><li><a href="#벡터-인터럽트" class="table-of-contents__link toc-highlight">벡터 인터럽트</a><ul><li><a href="#직렬-우선순위" class="table-of-contents__link toc-highlight">직렬 우선순위</a></li><li><a href="#병렬-우선순위" class="table-of-contents__link toc-highlight">병렬 우선순위</a></li></ul></li><li><a href="#계층구조" class="table-of-contents__link toc-highlight">계층구조</a></li><li><a href="#특성-결정-요소" class="table-of-contents__link toc-highlight">특성 결정 요소</a><ul><li><a href="#기억-용량" class="table-of-contents__link toc-highlight">기억 용량</a></li><li><a href="#access-time" class="table-of-contents__link toc-highlight">Access Time</a></li><li><a href="#cycle-time" class="table-of-contents__link toc-highlight">Cycle Time</a></li><li><a href="#bandwitdh" class="table-of-contents__link toc-highlight">Bandwitdh</a></li></ul></li><li><a href="#구분" class="table-of-contents__link toc-highlight">구분</a></li><li><a href="#rom" class="table-of-contents__link toc-highlight">ROM</a><ul><li><a href="#종류-3" class="table-of-contents__link toc-highlight">종류</a></li></ul></li><li><a href="#ram" class="table-of-contents__link toc-highlight">RAM</a></li><li><a href="#자기-코어" class="table-of-contents__link toc-highlight">자기 코어</a><ul><li><a href="#구성-1" class="table-of-contents__link toc-highlight">구성</a></li></ul></li><li><a href="#반도체-기억소자-구성" class="table-of-contents__link toc-highlight">반도체 기억소자 구성</a><ul><li><a href="#ram-1" class="table-of-contents__link toc-highlight">RAM</a></li><li><a href="#rom-1" class="table-of-contents__link toc-highlight">ROM</a></li></ul></li><li><a href="#자기-테이프" class="table-of-contents__link toc-highlight">자기 테이프</a></li><li><a href="#자기-디스크" class="table-of-contents__link toc-highlight">자기 디스크</a><ul><li><a href="#디스크의-3요소" class="table-of-contents__link toc-highlight">디스크의 3요소</a></li><li><a href="#access-time-1" class="table-of-contents__link toc-highlight">Access Time</a></li></ul></li><li><a href="#자기-드럼" class="table-of-contents__link toc-highlight">자기 드럼</a></li><li><a href="#구조" class="table-of-contents__link toc-highlight">구조</a></li><li><a href="#메모리-인터리빙" class="table-of-contents__link toc-highlight">메모리 인터리빙</a></li><li><a href="#설계-고려사항" class="table-of-contents__link toc-highlight">설계 고려사항</a></li><li><a href="#매핑-프로세스" class="table-of-contents__link toc-highlight">매핑 프로세스</a><ul><li><a href="#직접-매핑" class="table-of-contents__link toc-highlight">직접 매핑</a></li><li><a href="#어소시에이티브-매핑" class="table-of-contents__link toc-highlight">어소시에이티브 매핑</a></li><li><a href="#세트-어소시에이티브-매핑" class="table-of-contents__link toc-highlight">세트-어소시에이티브 매핑</a></li></ul></li><li><a href="#쓰기-정책" class="table-of-contents__link toc-highlight">쓰기 정책</a></li><li><a href="#적중률" class="table-of-contents__link toc-highlight">적중률</a></li><li><a href="#주소" class="table-of-contents__link toc-highlight">주소</a></li><li><a href="#관리" class="table-of-contents__link toc-highlight">관리</a></li><li><a href="#관리전략" class="table-of-contents__link toc-highlight">관리전략</a><ul><li><a href="#반입-전략" class="table-of-contents__link toc-highlight">반입 전략</a></li><li><a href="#배치-전략" class="table-of-contents__link toc-highlight">배치 전략</a></li><li><a href="#교체-전략" class="table-of-contents__link toc-highlight">교체 전략</a></li></ul></li><li><a href="#주소-매핑" class="table-of-contents__link toc-highlight">주소 매핑</a><ul><li><a href="#변환-순서" class="table-of-contents__link toc-highlight">변환 순서</a></li></ul></li><li><a href="#flynn의-분류" class="table-of-contents__link toc-highlight">Flynn의 분류</a><ul><li><a href="#sisd" class="table-of-contents__link toc-highlight">SISD</a></li><li><a href="#simd" class="table-of-contents__link toc-highlight">SIMD</a></li><li><a href="#misd" class="table-of-contents__link toc-highlight">MISD</a></li><li><a href="#mimd" class="table-of-contents__link toc-highlight">MIMD</a></li></ul></li><li><a href="#feng의-분류" class="table-of-contents__link toc-highlight">Feng의 분류</a><ul><li><a href="#wsbs" class="table-of-contents__link toc-highlight">WSBS</a></li><li><a href="#wpbs" class="table-of-contents__link toc-highlight">WPBS</a></li><li><a href="#wsbp" class="table-of-contents__link toc-highlight">WSBP</a></li><li><a href="#wpbp" class="table-of-contents__link toc-highlight">WPBP</a></li></ul></li><li><a href="#파이프라인-프로세서" class="table-of-contents__link toc-highlight">파이프라인 프로세서</a></li><li><a href="#벡터-프로세서" class="table-of-contents__link toc-highlight">벡터 프로세서</a><ul><li><a href="#시스톨릭-프로세서" class="table-of-contents__link toc-highlight">시스톨릭 프로세서</a></li></ul></li><li><a href="#배열-프로세서" class="table-of-contents__link toc-highlight">배열 프로세서</a></li><li><a href="#데이터-플로우-컴퓨터" class="table-of-contents__link toc-highlight">데이터 플로우 컴퓨터</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Support Me</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://www.buymeacoffee.com/LOUB2kN" target="_blank" rel="noopener noreferrer" style="cursor: pointer;">
                <img src="https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png" style="height: auto !important;width: auto !important;">
              </a></li></ul></div><div class="col footer__col"><div class="footer__title">Feeds</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://gracefullight.dev/rss.xml" target="_blank" rel="noopener noreferrer" class="footer__link-item">RSS<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lTcV"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://gracefullight.dev/atom.xml" target="_blank" rel="noopener noreferrer" class="footer__link-item">Atom<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lTcV"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div></div></footer></div>
</body>
</html>